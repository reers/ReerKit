<SYSTEM>Document for ReerKit</SYSTEM>

# Overview

ReerKit is a collection of native Swift extensions that provide convenient methods, syntactic sugar, and performance improvements for various native data types, UIKit, and Cocoa classes for iOS, macOS, tvOS, watchOS, and Linux platforms. All system type extensions in the framework have the re infix added to avoid ambiguity issues when calling the same name extension, such as

```
SGVsbG\n8gV29ybGQh".re.base64Decoded

"123".re.md5String

view.re.addSwiftUIView(Color.red)
```

# ReerInfix
Using the bridge below allows all system extension properties and methods to have an infix, such as `"aString".re.md5`

```
/// Wrapper for ReerKit compatible types. This type provides an extension point for
/// convenience methods in ReerKit.
public struct Reer<Base> {

    public let base: Base

    public init(_ base: Base)
}

/// Represents an object type that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerCompatible : AnyObject {
}

/// Represents a value type that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerCompatibleValue {
}

extension ReerCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<Self>.Type { get set }
}

extension ReerCompatibleValue {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<Self>.Type { get set }
}

/// Wrapper for ReerKit compatible types with a generic parameter. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerGeneric<Base, T> {

    public internal(set) var base: Base { get }

    public init(_ base: Base)
}

/// Represents a type with a generic parameter that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerGenericCompatible {

    associatedtype T
}

public extension ReerGenericCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerGeneric<Self, T> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerGeneric<Self, T>.Type { get set }
}

/// Wrapper for ReerKit compatible types with 2 generic parameters. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerGeneric2<Base, T1, T2> {

    public internal(set) var base: Base { get }

    public init(_ base: Base)
}

/// Represents a type with 2 generic parameters that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerGeneric2Compatible {

    associatedtype T1

    associatedtype T2
}

public extension ReerGeneric2Compatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerGeneric2<Self, T1, T2> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerGeneric2<Self, T1, T2>.Type { get set }
}

/// Wrapper for ReerKit compatible types in a reference way. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerReference<Base> {

    public internal(set) var base: UnsafeMutablePointer<Base> { get }

    public init(_ base: inout Base)
}

/// Represents a type that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerReferenceCompatible {
}

public extension ReerReferenceCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerReference<Self> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerReference<Self>.Type { get set }
}

/// Wrapper for ReerKit compatible types with a generic parameter in a reference way. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerReferenceGeneric<Base, T> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

/// Represents a type with a generic parameter that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerReferenceGenericCompatible {

    associatedtype T
}

public extension ReerReferenceGenericCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerReferenceGeneric<Self, T> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerReferenceGeneric<Self, T>.Type { get set }
}

/// Wrapper for ReerKit compatible types with a generic parameter in a reference way. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerReferenceGeneric2<Base, U1, U2> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

/// Represents a type with a generic parameter that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerReferenceGeneric2Compatible {

    associatedtype U1

    associatedtype U2
}

public extension ReerReferenceGeneric2Compatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerReferenceGeneric2<Self, U1, U2> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerReferenceGeneric2<Self, U1, U2>.Type { get set }
}

public extension Numeric {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<`Self`> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<`Self`>.Type { get set }
}

public extension Sequence {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<`Self`> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<`Self`>.Type { get set }
}

public struct ReerForEquatable<Base> {

    public internal(set) var base: Base { get }

    public init(_ base: Base)
}

public extension Equatable {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForEquatable<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForEquatable<Self>.Type { get set }
}

public struct ReerForMutableCollection<Base> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

public extension MutableCollection {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForMutableCollection<Self> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForMutableCollection<Self>.Type { get set }
}

public struct ReerForStringProtocol<Base> {

    public let base: Base

    public init(_ base: Base)
}

public extension StringProtocol {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForStringProtocol<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForStringProtocol<Self>.Type { get set }
}

public struct ReerForRangeReplaceableCollection<Base> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

public extension RangeReplaceableCollection {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForRangeReplaceableCollection<Self> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForRangeReplaceableCollection<Self>.Type { get set }
}

public struct ReerForOptionSet<Base> {

    public let base: Base

    public init(_ base: Base)
}

public extension OptionSet {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForOptionSet<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForOptionSet<Self>.Type { get set }
}

public struct ReerForContiguousBytes<Base> {

    public let base: Base

    public init(_ base: Base)
}

public extension ContiguousBytes {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForContiguousBytes<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForContiguousBytes<Self>.Type { get set }
}
```

# API List

## GlobalFunctions

```
import Dispatch
/// ReerKit: Get current queue label.
/// - Returns: Queue label string.
public func currentQueueLabel() -> String

/// ReerKit: Execute a closure on main queue asynchronously.
public func asyncOnMainQueue(_ action: @escaping () -> Void)

/// ReerKit: Execute a closure on main queue synchronously.
public func syncOnMainQueue(_ action: @escaping () -> Void)

/// ReerKit: Execute a closure on global queue asynchronously.
public func asyncOnGlobalQueue(qos: DispatchQoS.QoSClass = .default, action: @escaping () -> Void)

/// ReerKit: Execute a closure on global queue synchronously.
public func syncOnGlobalQueue(qos: DispatchQoS.QoSClass = .default, action: @escaping () -> Void)

/// ReerKit: Delay to execute a closure on the queue.
public func delay(_ interval: Double, onQueue queue: DispatchQueue = .main, action: @escaping () -> Void)

import Darwin
/// ReerKit: Get info by name via `sysctl`
/// e.g.
/// hw.model
/// kern.osversion
/// kern.hostname
public func sysctl(by name: String) -> String

/// ReerKit: Return a `Bool` value, the probability of it being `true` is the input value.
public func trueWithProbability(_ percent: Double) -> Bool

/// ReerKit: Return a `Bool` value, the probability of it being `false` is the input value.
public func falseWithProbability(_ percent: Double) -> Bool
```

```
/// ReerKit: An once token type that wrapped an internal string.
public struct OnceToken : Hashable {

    /// Create a token with an internal pointer.
    public init()

    public init(_ value: String)
}

/// ReerKit: Invoke the passed closure only once during the life time of the process.
/// It will create an once token by combining #fileID, #function, #line.
///
///     once {
///         print("do something")
///     }
///
/// - Parameters:
///   - fileID: No need to pass it, just use the default.
///   - function: No need to pass it, just use the default.
///   - line: No need to pass it, just use the default.
///   - execute: The closure need to be executed.
public func once(fileID: String = #fileID, function: String = #function, line: Int = #line, execute: () -> Void)

/// ReerKit: Invoke the passed closure only once during the life time of the process.
/// It need an once token parameter, seealso `OnceToken`.
///
///     let token = OnceToken()
///     once(token) {
///         print("do something")
///     }
///
/// - Parameters:
///   - token: An unique once token.
///   - execute: The closure need to be executed.
public func once(_ token: OnceToken, execute: () -> Void)

/// ReerKit: Cancel the once token mark, that means you can execute the action again with the same token.
/// - Parameter token: The token that need to cancel marking.
public func deonce(_ token: OnceToken)
```

```
import ObjectiveC
/// ReerKit: Use just like objective-c `@synchronized`.
///
///     let obj = NSObject()
///     synchronized(obj) {
///         // do something
///     }
/// - Parameters:
///   - token: A reference type object.
///   - execute: An action need to be executed synchronizely.
public func synchronized<Result>(_ token: AnyObject, execute: () throws -> Result) rethrows -> Result
```

```
import ObjectiveC

/// ReerKit: Global function to observe deinit for the object.
public func observeDeinit<Object>(for object: Object?, onDeinit: @escaping () -> Void) where Object : AnyObject
```

```
/// Get module name from a swift file ID.
/// - Parameter fileId: No need to pass it, just use the default.
/// - Returns: Module name, return `""` if failed.
public func moduleName(fileId: String = #fileID) -> String
```

## DataStructure

### Tree

```
/// Define a generic N-ary tree data structure as a class with parent pointers
public class Tree<E> {

    /// The value stored in the node
    public var value: E

    /// The children of the node
    public var children: [Tree<E>] { get set }

    /// The parent node; weak to prevent retain cycles
    public weak var parent: Tree<E>?

    /// Computed property to count the total number of nodes in the tree
    public var count: Int { get }

    /// Initialize a node with a value
    public init(value: E)

    /// Add a child node with a value
    @discardableResult
    public func addChild(value: E) -> Tree<E>

    /// Add an existing tree as a child
    @discardableResult
    public func addChild(_ child: Tree<E>) -> Tree<E>
}

/// Extension to add traversal methods to the N-ary tree
extension Tree {

    /// Pre-order traversal (Root, Children)
    public func traversePreorder(process: (E) -> Void)

    /// Post-order traversal (Children, Root)
    public func traversePostorder(process: (E) -> Void)

    /// Level-order traversal with level information
    public func traverseLevelOrder(process: (E, Int) -> Void)
}

/// Extension to add inversion methods to the N-ary tree
extension Tree {

    /// Function to invert (mirror) the N-ary tree in place
    public func invert()

    /// Function to get a new inverted (mirrored) N-ary tree
    public func inverted() -> Tree<E>
}

extension Tree : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Tree {

    /// Prints the tree structure as a string.
    public func printTreeString()

    /// Generates a string representation of the tree structure.
    ///
    /// ```swift
    /// Root
    /// ├── Child2
    /// ├── Child1
    /// │   └── Grandchild2
    /// │       └── GreatGrandchild0
    /// └── Child0
    ///     ├── Grandchild1
    ///     └── Grandchild0
    /// ```
    ///
    /// - Returns: A string representing the tree structure.
    public func treeString() -> String
}
```

### BinaryTree

```
/// Define a generic binary tree data structure as a class with parent pointers
public class BinaryTree<E> {

    /// The value stored in the node
    public var value: E

    /// The left child of the node
    public var left: BinaryTree<E>? { get set }

    /// The right child of the node
    public var right: BinaryTree<E>? { get set }

    /// The parent node; weak to prevent retain cycles
    public weak var parent: BinaryTree<E>?

    /// Computed property to count the total number of nodes in the tree
    public var count: Int { get }

    /// Initialize a node with a value
    public init(value: E)

    /// Set a left child with a value
    @discardableResult
    public func setLeft(value: E) -> BinaryTree<E>

    /// Set a right child with a value
    @discardableResult
    public func setRight(value: E) -> BinaryTree<E>
}

/// Extension to add traversal methods to the binary tree
extension BinaryTree {

    /// In-order traversal (Left, Root, Right)
    public func traverseInorder(process: (E) -> Void)

    /// Pre-order traversal (Root, Left, Right)
    public func traversePreorder(process: (E) -> Void)

    /// Post-order traversal (Left, Right, Root)
    public func traversePostorder(process: (E) -> Void)

    /// Level-order traversal with level information
    public func traverseLevelOrder(process: (E, Int) -> Void)
}

/// Extension to add inversion methods to the binary tree
extension BinaryTree {

    /// Function to invert (mirror) the binary tree in place
    public func invert()

    /// Function to get a new inverted (mirrored) binary tree
    public func inverted() -> BinaryTree<E>
}

extension BinaryTree : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension BinaryTree {

    public func printTreeString(showLabel: Bool = false, showEmptyNode: Bool = true)

    /// Generates a string representation of the tree structure.
    ///
    /// ```swift
    /// 1
    /// ├── R: 3
    /// │   ├── R: 6
    /// │   │   ├── R: •
    /// │   │   └── L: 7
    /// │   └── L: •
    /// └── L: 2
    ///     ├── R: 5
    ///     └── L: 4
    ///
    /// 1
    /// ├── R: 3
    /// │   └── R: 6
    /// │       └── L: 7
    /// └── L: 2
    ///     ├── R: 5
    ///     └── L: 4
    ///
    /// 1
    /// ├── 3
    /// │   ├── 6
    /// │   │   ├── •
    /// │   │   └── 7
    /// │   └── •
    /// └── 2
    ///     ├── 5
    ///     └── 4
    /// ```
    ///
    /// - Parameters:
    ///   - showLabel: If `true`, includes "L:" and "R:" labels to indicate left and right children.
    ///   - showEmptyNode: If `true`, includes placeholder `•` for empty child nodes.
    /// - Returns: A string representing the tree structure.
    public func treeString(showLabel: Bool = true, showEmptyNode: Bool = true) -> String
}
```

### Queue

```
public struct Queue<E> {

    public init()

    public var count: Int { get }

    public var isEmpty: Bool { get }

    public mutating func enqueue(_ element: E)

    @discardableResult
    public mutating func dequeue() -> E?

    public var front: E? { get }
}

extension Queue : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}
```

### BoundedQueue

```
/// ReerKit: A first-in-first-out queue with a fixed capacity.
public struct BoundedQueue<E> {

    public enum OverflowBehavior {

        case rejectNew

        case dequeueOldest
    }

    public init(maxSize: Int, overflowBehavior: OverflowBehavior)

    public var count: Int { get }

    public var isEmpty: Bool { get }

    @discardableResult
    public mutating func enqueue(_ element: E) -> Bool

    @discardableResult
    public mutating func dequeue() -> E?

    public var front: E? { get }
}

extension BoundedQueue : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}
```

### OrderedDictionary

```
/// ReerKit: A dictionary with guaranteed keys ordering.
///
///     var dict = OrderedDictionary<String, Int>()
///     dict.append(1, forKey: "foo")
///     dict.append(2, forKey: "bar")
///
///     dict["foo"] // 1
///     dict["bar"] // 2
///     dict["qux"] // nil
///     dict.map { $0.key } // ["foo", "bar"], in this order.
public struct OrderedDictionary<Key, Value> where Key : Hashable {

    public private(set) var keys: [Key] { get }

    public private(set) var dictionary: [Key : Value] { get }

    public var values: [Value] { get }

    /// Creates an empty ordered dictionary.
    public init()

    /// Creates an empty ordered dictionary.
    public init(minimumCapacity: Int)

    /// Returns the value associated with key, or nil.
    public subscript(key: Key) -> Value? { get set }

    /// Returns the value associated with key, or the default value.
    public subscript(key: Key, default defaultValue: Value) -> Value { get set }

    /// Appends the given value for the given key.
    ///
    /// - precondition: There is no value associated with key yet.
    public mutating func appendValue(_ value: Value, forKey key: Key)

    /// Updates the value stored in the dictionary for the given key, or
    /// appends a new key-value pair if the key does not exist.
    ///
    /// Use this method instead of key-based subscripting when you need to know
    /// whether the new value supplants the value of an existing key. If the
    /// value of an existing key is updated, updateValue(_:forKey:) returns the
    /// original value. If the given key is not present in the dictionary, this
    /// method appends the key-value pair and returns nil.
    @discardableResult
    public mutating func updateValue(_ value: Value, forKey key: Key) -> Value?

    /// Removes the value associated with key.
    @discardableResult
    public mutating func removeValue(forKey key: Key) -> Value?

    /// Returns a new ordered dictionary containing the keys of this dictionary
    /// with the values transformed by the given closure.
    public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> OrderedDictionary<Key, T>

    /// Returns a new ordered dictionary containing only the key-value pairs
    /// that have non-nil values as the result of transformation by the
    /// given closure.
    public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> OrderedDictionary<Key, T>

    public func filter(_ isIncluded: ((key: Key, value: Value)) throws -> Bool) rethrows -> OrderedDictionary<Key, Value>

    public mutating func merge<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Sequence, S.Element == (Key, Value)

    public mutating func merge<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Sequence, S.Element == (key: Key, value: Value)

    public func merging<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> OrderedDictionary<Key, Value> where S : Sequence, S.Element == (Key, Value)

    public func merging<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> OrderedDictionary<Key, Value> where S : Sequence, S.Element == (key: Key, value: Value)
}

extension OrderedDictionary : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> (key: Key, value: Value) { get }
}

extension OrderedDictionary : ExpressibleByDictionaryLiteral {

    /// Creates an instance initialized with the given key-value pairs.
    public init(dictionaryLiteral elements: (Key, Value)...)
}

extension OrderedDictionary : Equatable where Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: OrderedDictionary, rhs: OrderedDictionary) -> Bool
}

extension OrderedDictionary : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Dictionary {

    public init(_ orderedDictionary: OrderedDictionary<Key, Value>)
}
```

### OrderedSet

```
/// ReerKit: An ordered set is an ordered collection of instances of `Element` in which
/// uniqueness of the objects is guaranteed.
///
///     var set = OrderedSet<String>()
///     set.append("a")
///     set.insert("b", at: 1)
///     set.append("c")
///     set.map { Int($0)! } // [1, 2, 3], in this order.
public struct OrderedSet<Element> where Element : Hashable {

    /// Creates an empty ordered set.
    public init()

    /// Creates an empty ordered set.
    public init(_ array: [Element])

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!"
    ///
    /// - Complexity: O(1)
    public var isEmpty: Bool { get }

    /// Array value of the ordered set.
    public var elements: [Element] { get }

    public func contains(_ member: Element) -> Bool

    /// Append a new member to the end of the set, if the set doesn't
    /// already contain it.
    ///
    /// - Parameter newElement: The element to add to the set.
    ///
    /// - Returns: A pair `(inserted, index)`, where `inserted` is a Boolean value
    ///    indicating whether the operation added a new element, and `index` is
    ///    the index of `item` in the resulting set.
    ///
    /// - Complexity: The operation is expected to perform O(1) copy, hash, and
    ///    compare operations on the `Element` type, if it implements high-quality
    ///    hashing.
    @discardableResult
    public mutating func append(_ newElement: Element) -> (inserted: Bool, index: Int)

    /// Insert a new member to this set at the specified index, if the set doesn't
    /// already contain it.
    ///
    /// - Parameter newElement: The element to insert.
    /// - Parameter index: The index will insert at.
    /// - Returns: A pair `(inserted, index)`, where `inserted` is a Boolean value
    ///    indicating whether the operation added a new element, and `index` is
    ///    the index of `item` in the resulting set. If `inserted` is false, then
    ///    the returned `index` may be different from the index requested.
    ///
    /// - Complexity: The operation is expected to perform amortized
    ///    O(`self.count`) copy, hash, and compare operations on the `Element`
    ///    type, if it implements high-quality hashing. (Insertions need to make
    ///    room in the storage array to add the inserted element.)
    @discardableResult
    public mutating func insert(_ newElement: Element, at index: Int) -> (inserted: Bool, index: Int)

    /// Remove and return the element at the beginning of the ordered set.
    @discardableResult
    public mutating func removeFirst() -> Element

    /// Remove and return the element at the end of the ordered set.
    @discardableResult
    public mutating func removeLast() -> Element

    @discardableResult
    public mutating func remove(_ member: Element) -> Element?

    /// Remove all elements.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)
}

extension OrderedSet : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> Element { get }
}

extension OrderedSet : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral elements: Element...)
}

extension OrderedSet : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension OrderedSet : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: OrderedSet, rhs: OrderedSet) -> Bool
}
```

### Stack

```
public struct Stack<E> {

    public init()

    public var count: Int { get }

    public var isEmpty: Bool { get }

    public mutating func push(_ element: E)

    @discardableResult
    public mutating func pop() -> E?

    public var top: E? { get }

    public mutating func removeAll()
}

extension Stack : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}
```

### LinkedList

```
/// A doubly linked list implementation.
public final class LinkedList<E> {

    public private(set) var count: Int { get }

    public var isEmpty: Bool { get }

    public init()

    public func insert(_ element: E, at index: Int)

    public func append(_ element: E)

    @discardableResult
    public func remove(at index: Int) -> E

    public func removeFirst()

    public func removeLast()

    public func removeAll()

    public func set(_ element: E, at index: Int)

    public subscript(index: Int) -> E { get }
}

extension LinkedList where E : Equatable {

    public func firstIndex(of element: E) -> Int?

    public func lastIndex(of element: E) -> Int?

    public func contains(element: E) -> Bool

    public func removeAll(_ element: E)

    public func removeAll(_ elements: [E])

    public func removeAll(where shouldBeRemoved: (E) throws -> Bool) rethrows
}

extension LinkedList : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public convenience init(arrayLiteral elements: E...)
}

extension LinkedList {

    public var array: [E] { get }

    public func reverse()
}

extension LinkedList : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension LinkedList {

    public func map<T>(transform: (E) -> T) -> LinkedList<T>

    public func filter(predicate: (E) -> Bool) -> LinkedList<E>
}

extension LinkedList : Sequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> LinkedListIterator<E>
}

public struct LinkedListIterator<E> : IteratorProtocol {

    internal let linkedList: LinkedList<E>

    internal init(linkedList: LinkedList<E>)

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> E?
}
```

## Lock

### MutexLock

```
import Darwin

/// ReerKit: A wrapper class for pthread mutex, providing a simple interface for thread synchronization.
public final class MutexLock {

    public init()

    /// Acquires the lock, blocking the current thread until the lock can be obtained.
    public func lock()

    /// ReerKit: Attempts to acquire the lock without blocking.
    /// Returns true if the lock was successfully locked and false if the lock was already locked.
    @discardableResult
    public func tryLock() -> Bool

    /// Releases the lock.
    public func unlock()

    /// ReerKit: Executes a closure returning a value while acquiring the lock.
    ///
    /// - Parameter execute: The closure to run while holding the lock.
    ///
    /// - Returns: The value the closure generated.
    ///
    /// - Throws: Rethrows any error that the closure might throw.
    public func around<Result>(_ execute: () throws -> Result) rethrows -> Result
}
```

### ReadWriteLock

```
import Darwin

/// ReerKit: Represents a reader-writer lock. Note that this implementation is not recursive.
public final class ReadWriteLock {

    public init()

    public func readLock()

    /// ReerKit: Returns true if the lock was succesfully locked and false if the lock was already locked.
    @discardableResult
    public func tryReadLock() -> Bool

    public func readUnlock()

    public func writeLock()

    /// ReerKit: Returns true if the lock was succesfully locked and false if the lock was already locked.
    @discardableResult
    public func tryWriteLock() -> Bool

    public func writeUnlock()

    public func readAround<Result>(_ execute: () throws -> Result) rethrows -> Result

    public func writeAround<Result>(_ execute: () throws -> Result) rethrows -> Result
}
```

### UnfairLock

```
import os.lock

/// ReerKit: A wrapper of `os_unfair_lock`
public final class UnfairLock {

    public init()

    public func lock()

    /// ReerKit: Returns true if the lock was succesfully locked and false if the lock was already locked.
    @discardableResult
    public func tryLock() -> Bool

    public func unlock()

    /// ReerKit: Executes a closure returning a value while acquiring the lock.
    ///
    /// - Parameter execute: The closure to run.
    ///
    /// - Returns: The value the closure generated.
    public func around<Result>(_ execute: () throws -> Result) rethrows -> Result
}
```

## Math

### LinearFunction

```
import CoreGraphics

/// ReerKit: Represents a linear function of the form y = mx + b
public struct LinearFunction : CustomStringConvertible {

    /// The slope (m) of the linear function
    public let slope: Double

    /// The y-intercept (b) of the linear function
    public let intercept: Double

    /// Initializes a LinearFunction with a given slope and y-intercept
    /// - Parameters:
    ///   - slope: The slope of the line
    ///   - intercept: The y-intercept of the line
    public init(slope: Double, intercept: Double)

    /// Initializes a LinearFunction from two points on the line
    /// - Parameters:
    ///   - point1: The first point on the line
    ///   - point2: The second point on the line
    public init(point1: CGPoint, point2: CGPoint)

    /// Calculates the y value for a given x value
    ///
    ///     let linear = LinearFunction(slope: 2, intercept: 5)
    ///     let y = linear(x: 3)
    ///
    /// - Parameter x: The x value
    /// - Returns: The corresponding y value
    public func callAsFunction(x: Double) -> Double

    /// Calculates the x value for a given y value
    ///
    ///     let linear = LinearFunction(slope: 2, intercept: 5)
    ///     let x = linear(y: 11)
    ///
    /// - Parameter y: The y value
    /// - Returns: The corresponding x value
    public func callAsFunction(y: Double) -> Double

    /// A string representation of the linear function
    public var description: String { get }
}
```

## PropertyWrapper

### Clamped

```
@propertyWrapper 
public struct Clamped<Value> where Value : Comparable {

    public init(wrappedValue: Value, _ range: ClosedRange<Value>)

    public var wrappedValue: Value { get set }
}
```

### Locked

```
import os.lock

/// ReerKit: A lock protects the property with an `os_unfair_lock`
@propertyWrapper 
public final class Locked<T> {

    public init(wrappedValue: T)

    public var wrappedValue: T { get set }

    public var projectedValue: Locked<T> { get }

    public func read<U>(_ execute: (T) throws -> U) rethrows -> U

    @discardableResult
    public func write<U>(_ execute: (inout T) throws -> U) rethrows -> U
}
```

### Rounded

```
@propertyWrapper 
public struct Rounded<Value> where Value : FloatingPoint {

    public let rule: FloatingPointRoundingRule

    public init(wrappedValue: Value, rule: FloatingPointRoundingRule = .toNearestOrAwayFromZero)

    public var wrappedValue: Value { get set }
}
```

### RWLocked

```
import Darwin

/// ReerKit: A read write lock wrapper grants multiple readers and single-writer guarantees on a value.
@propertyWrapper 
public final class RWLocked<T> {

    public init(wrappedValue: T)

    public var wrappedValue: T { get set }

    public var projectedValue: RWLocked<T> { get }

    public func read<U>(_ execute: (T) throws -> U) rethrows -> U

    @discardableResult
    public func write<U>(_ execute: (inout T) throws -> U) rethrows -> U
}
```

### Trimmed

```
@propertyWrapper
public struct Trimmed {

    public init(wrappedValue: String)

    public var wrappedValue: String { get set }
}
```

## Weak

### weak

```
/// Weak wrapper for AnyObject.
public final class Weak<T> where T : AnyObject {

    public private(set) weak var object: T? { get }

    public init(_ object: T)
}

extension Weak : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Weak<T>, rhs: Weak<T>) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}
```

### WeakProxy

```
import Foundation

/// A proxy used to hold a weak object.
/// It can be used to avoid retain cycles, such as the target in Timer or CADisplayLink.
public class WeakProxy : NSObject {

    /// The proxy target.
    public weak var target: NSObject?

    /// Creates a new weak proxy for target.
    public init(target: NSObject)

    public override func forwardingTarget(for aSelector: Selector!) -> Any?

    public override func responds(to aSelector: Selector!) -> Bool

    public override func isEqual(_ object: Any?) -> Bool

    public override var hash: Int { get }

    public override var superclass: AnyClass? { get }

    public override func isProxy() -> Bool

    public override func isKind(of aClass: AnyClass) -> Bool

    public override func isMember(of aClass: AnyClass) -> Bool

    public override func conforms(to aProtocol: Protocol) -> Bool

    public override var description: String { get }

    public override var debugDescription: String { get }
}
```

### WeakMap

```
public protocol WeakOption {}

/// Use phantom types to express weak option.
public enum WeakKey : WeakOption {}
public enum WeakValue : WeakOption {}
public enum WeakKeyValue : WeakOption {}

/// A map class that weak refering every AnyObject element.
/// If the object element's key or value released, its weak wrapper `Weak<T>` will remove from the internal map automatically.
/// This class is not thread-safe and should not be accessed concurrently from multiple threads.
/// 
///     var aa: NSObject? = NSObject()
///     let bb: NSObject? = NSObject()
///     let map: WeakMap<WeakValue, String, NSObject> = .init(["aa": aa!, "bb": bb!])
///
public class WeakMap<Option, Key, Value> where Option : WeakMap.WeakOption, Key : Hashable {

    public var count: Int { get }

    public var keys: [Key] { get }

    public var values: [Value] { get }
}

extension WeakMap where Option == WeakMap.WeakKey, Key : AnyObject {

    public convenience init(_ weakKeyMap: [Key : Value] = [:])

    public subscript(key: Key) -> Value? { get set }

    @discardableResult
    public func removeValue(forKey key: Key) -> Value?

    @discardableResult
    public func updateValue(_ value: Value, forKey key: Key) -> Value?

    public func forEach(_ body: ((key: Key, value: Value)) throws -> Void) rethrows
}

extension WeakMap where Option == WeakMap.WeakValue, Value : AnyObject {

    public convenience init(_ weakValueMap: [Key : Value] = [:])

    public subscript(key: Key) -> Value? { get set }

    @discardableResult
    public func removeValue(forKey key: Key) -> Value?

    @discardableResult
    public func updateValue(_ value: Value, forKey key: Key) -> Value?

    public func forEach(_ body: ((key: Key, value: Value)) throws -> Void) rethrows
}

extension WeakMap where Option == WeakMap.WeakKeyValue, Key : AnyObject, Value : AnyObject {

    public convenience init(_ weakKeyValueMap: [Key : Value] = [:])

    public subscript(key: Key) -> Value? { get set }

    @discardableResult
    public func removeValue(forKey key: Key) -> Value?

    @discardableResult
    public func updateValue(_ value: Value, forKey key: Key) -> Value?

    public func forEach(_ body: ((key: Key, value: Value)) throws -> Void) rethrows
}
```

### WeakSet

```
/// A set class that weak refering every AnyObject element.
/// If the object element released, its weak wrapper `Weak<T>` will remove from the internal set automatically.
/// This class is not thread-safe and should not be accessed concurrently from multiple threads.
///
///     var aa: NSObject? = NSObject()
///     let bb: NSObject? = NSObject()
///     let set = WeakSet([aa!, bb!])
///
public class WeakSet<T> : ExpressibleByArrayLiteral where T : AnyObject {

    public init()

    public init(_ objects: [T])

    /// Creates an instance initialized with the given elements.
    public required convenience init(arrayLiteral elements: T...)

    public var allObjects: [T] { get }

    public var count: Int { get }

    public func contains(_ object: T) -> Bool

    public func add(_ object: T)

    public func addObjects(_ objects: [T])

    public func remove(_ object: T)

    public func removeObjects(_ objects: [T])

    public func removeAll()

    public func copy() -> WeakSet<T>
}

extension WeakSet : Sequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> WeakSetIterator<T>
}

public struct WeakSetIterator<T> : IteratorProtocol where T : AnyObject {

    internal let weakSet: WeakSet<T>

    internal init(_ weakSet: WeakSet<T>)

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> T?
}
```

## Utility

### RETimer

```
import Dispatch
import os.lock
import Foundation

/// ReerKit: A timer based on `DispatchSource`.
///
///                           fireDate
///     schedule()   callbackImmediatelyWhenFired  default first callback
///         |                     |                      |
///         |--------delay--------|-------interval-------|-------interval-------|
public final class RETimer {

    public enum State {

        case initial

        case running

        case suspended

        case invalidated
    }

    /// A number of seconds.
    public typealias TimeInterval = Double

    public private(set) var repeats: Bool { get }

    public private(set) var timeInterval: TimeInterval { get }

    public private(set) var state: State { get }

    public typealias RETimerAction = (_ timer: RETimer) -> Void

    /// Total elapsed time since the timer started, excluding paused durations.
    public var totalElapsedTime: TimeInterval { get }

    /// ReerKit: Initializes a timer object with the specified time interval and block.
    /// You must call `schedule()` yourself after creating the timer.
    ///
    /// - Parameters:
    ///   - delay: The delay interval after `schedule` method is invoked.
    ///   - timeInterval: The number of seconds between firings of the timer. If timeInterval is less than or equal to 0.0, this method chooses the nonnegative value of 0.0001 seconds instead.
    ///   - repeats: If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - callbackImmediatelyWhenFired: When should callback when time is fired, default is `false`, and its behavior is the same as `Foundation.Timer`
    ///   - action: A closure to be executed when the timer fires. The closure takes a single Timer parameter and has no return value.
    public init(delay: TimeInterval = 0, timeInterval: TimeInterval, repeats: Bool = true, queue: DispatchQueue = .main, callbackImmediatelyWhenFired: Bool = false, action: @escaping RETimerAction)

    /// ReerKit: Creates a timer and schedules it with a delay interval.
    /// - Parameters:
    ///   - delay: The delay interval after `schedule` method is invoked.
    ///   - timeInterval: The number of seconds between firings of the timer. If timeInterval is less than or equal to 0.0, this method chooses the nonnegative value of 0.0001 seconds instead.
    ///   - repeats: If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - callbackImmediatelyWhenFired: When should callback when time is fired, default is `false`, and its behavior is the same as `Foundation.Timer`
    ///   - action: A closure to be executed when the timer fires. The closure takes a single Timer parameter and has no return value.
    /// - Returns: A timer instance.
    public class func scheduledTimer(delay: TimeInterval = 0, timeInterval: TimeInterval, repeats: Bool = true, queue: DispatchQueue = .main, callbackImmediatelyWhenFired: Bool = false, action: @escaping RETimerAction) -> RETimer

    /// ReerKit: Creates a timer and schedules it on a fire date.
    /// - Parameters:
    ///   - fireDate: The fire date of the timer.
    ///   - timeInterval: The number of seconds between firings of the timer. If timeInterval is less than or equal to 0.0, this method chooses the nonnegative value of 0.0001 seconds instead.
    ///   - repeats: If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - callbackImmediatelyWhenFired: When should callback when time is fired, default is `false`, and its behavior is the same as `Foundation.Timer`
    ///   - action: A closure to be executed when the timer fires. The closure takes a single Timer parameter and has no return value.
    /// - Returns: A timer instance.
    public static func scheduledTimer(fireDate: Date, timeInterval: TimeInterval, repeats: Bool = true, queue: DispatchQueue = .main, callbackImmediatelyWhenFired: Bool = false, action: @escaping RETimerAction) -> RETimer

    /// ReerKit: Schedules a timer.
    @discardableResult
    public func schedule() -> Bool

    /// ReerKit: Resumes the timer when timer is suspended.
    ///
    /// - Important: Do NOT use `resume` to start the timer, it will not work.
    public func resume()

    /// ReerKit: Suspends the timer.
    public func suspend()

    /// ReerKit: Stops the timer from ever firing again.
    public func invalidate()
}

public extension RETimer {

    /// ReerKit: Execute the closure after the delay interval.
    /// - Parameters:
    ///   - delay: The delay interval.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - action: A closure to be executed after the delay.
    public static func after(_ delay: TimeInterval, queue: DispatchQueue = .main, action: @escaping () -> Void)

    /// ReerKit: Creates a timer that fires every second, providing the timer instance, display seconds, and passed duration.
    ///
    /// This method creates a timer that fires every second, calling the `action` closure with the timer, the number of seconds that have passed, and the total elapsed time excluding any paused durations. Internally, it uses a more frequent interval for increased accuracy, especially when resuming from a suspended state.
    ///
    /// **Usage example:**
    /// ```swift
    /// let timer = RETimer.scheduledTimerEverySecond { timer, displaySeconds, passedDuration in
    ///     print("Timer fired! Display Seconds: \(displaySeconds), Passed Duration: \(passedDuration)")
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - queue: The dispatch queue on which to execute the timer. Defaults to the main queue.
    ///   - action: A closure to be executed every second. The closure takes three parameters:
    ///     - `timer`: The `RETimer` instance.
    ///     - `displaySeconds`: An `Int` representing the number of seconds that have passed since the timer started.
    ///     - `passedDuration`: A `TimeInterval` representing the total elapsed time excluding any paused durations.
    /// - Returns: An instance of `RETimer` configured to fire every second.
    public static func scheduledTimerEverySecond(queue: DispatchQueue = .main, action: @escaping (_ timer: RETimer, _ displaySeconds: Int, _ passedDuration: TimeInterval) -> Void) -> RETimer
}
```

### CountdownTimer

```
import Foundation
import Dispatch

/// A class that represents a countdown timer with customizable intervals and durations.
public final class CountdownTimer {

    /// The time interval between each tick of the timer.
    public let interval: TimeInterval

    /// The total number of times the timer should tick.
    public let times: Int

    /// The total duration of the countdown.
    public let totalDuration: TimeInterval

    /// The action to be performed on each tick of the timer.
    public let action: (CountdownTimer) -> Void

    /// The number of ticks remaining.
    public private(set) var leftTimes: Int { get }

    /// The remaining duration of the countdown.
    public var leftDuration: TimeInterval { get }

    /// Indicates whether the countdown has finished.
    public var finished: Bool { get }

    /// Initializes a new countdown timer with a specified interval and number of ticks.
    ///
    /// - Parameters:
    ///   - interval: The time interval between each tick.
    ///   - times: The total number of ticks.
    ///   - action: The action to be performed on each tick.
    public init(interval: TimeInterval, times: Int, action: @escaping (CountdownTimer) -> Void)

    /// Initializes a new countdown timer with a specified number of ticks and total duration.
    ///
    /// - Parameters:
    ///   - times: The total number of ticks.
    ///   - totalDuration: The total duration of the countdown.
    ///   - action: The action to be performed on each tick.
    public init(times: Int, totalDuration: TimeInterval, action: @escaping (CountdownTimer) -> Void)

    /// Creates and returns a new countdown timer with the specified interval and number of ticks.
    ///
    /// - Parameters:
    ///   - interval: The time interval between each tick.
    ///   - times: The total number of ticks.
    ///   - action: The action to be performed on each tick.
    /// - Returns: A new countdown timer that has already started.
    public static func scheduledTimer(withInterval interval: TimeInterval, times: Int, action: @escaping (CountdownTimer) -> Void) -> CountdownTimer

    /// Creates and returns a new countdown timer with the specified number of ticks and total duration.
    ///
    /// - Parameters:
    ///   - times: The total number of ticks.
    ///   - totalDuration: The total duration of the countdown.
    ///   - action: The action to be performed on each tick.
    /// - Returns: A new countdown timer that has already started.
    public static func scheduledTimer(withTimes times: Int, totalDuration: TimeInterval, action: @escaping (CountdownTimer) -> Void) -> CountdownTimer

    /// ReerKit: Countdown timer with a total seconds be set, and call back every second.
    ///
    /// ```
    /// var countdownTimer = CountdownTimer.scheduledTimer(withTotalSeconds: 60) {
    ///     [weak self] displaySeconds, leftDuration, passedDuration in
    ///
    ///     let minutes = Int(Double(displaySeconds) / 60.0)
    ///     let seconds = Int(Double(displaySeconds) - minutes.re.double * 60.0)
    ///     self?.timeLabel.text = String(format: "%02d:%02d", minutes, seconds)
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - totalSeconds: Total seconds with `Int`
    ///   - action: Called back every second, carrying the displayed number of seconds, remaining time, and elapsed time.
    /// - Returns: A countdown timer.
    public static func scheduledTimer(withTotalSeconds totalSeconds: Int, action: @escaping (_ displaySeconds: Int, _ leftDuration: TimeInterval, _ passedDuration: TimeInterval) -> Void) -> CountdownTimer

    /// Starts the countdown timer.
    public func fire()

    /// Resumes the countdown timer if it was suspended.
    public func resume()

    /// Suspends the countdown timer.
    public func suspend()

    /// Invalidates the countdown timer, preventing it from ever firing again.
    public func invalidate()

    /// Resets the countdown timer to its initial state.
    public func reset()
}
```

### Throttler

```
import Foundation

public final class Throttler {

    public enum PerformMode {

        case first

        case last
    }

    public init(queue: DispatchQueue = .main, performMode: PerformMode = .first)

    public func execute(interval: TimeInterval, action: @escaping () -> Void)

    public func execute(deadline: DispatchTime, action: @escaping () -> Void)

    public func execute(wallDeadline: DispatchWallTime, action: @escaping () -> Void)
}
```

### Debouncer

```
import Foundation

/// A class that provides debouncing functionality for executing actions after a specified delay.
public final class Debouncer {

    /// The current work item representing the debounced action.
    public private(set) var workItem: DispatchWorkItem { get }

    /// Initializes a new Debouncer instance.
    ///
    /// - Parameter queue: The dispatch queue to use for executing the debounced action. Defaults to the main queue.
    public init(queue: DispatchQueue = .main)

    /// Executes the given action after the specified time interval, cancelling any previously scheduled action.
    ///
    /// - Parameters:
    ///   - interval: The time interval to wait before executing the action.
    ///   - action: The action to be executed.
    public func execute(interval: TimeInterval, action: @escaping () -> Void)

    /// Executes the given action at the specified dispatch time, cancelling any previously scheduled action.
    ///
    /// - Parameters:
    ///   - deadline: The dispatch time at which to execute the action.
    ///   - action: The action to be executed.
    public func execute(deadline: DispatchTime, action: @escaping () -> Void)

    /// Executes the given action at the specified wall clock time, cancelling any previously scheduled action.
    ///
    /// - Parameters:
    ///   - wallDeadline: The wall clock time at which to execute the action.
    ///   - action: The action to be executed.
    public func execute(wallDeadline: DispatchWallTime, action: @escaping () -> Void)
}
```

### Invocation

```
import ObjectiveC
import Foundation

/// A wrapper for Objective-C `NSInvocation`
public class Invocation {

    /// Get instance method for a Objc class.
    /// - Parameters:
    ///   - selector: Method selector
    ///   - instance: A Class or instance.
    /// - Returns: A signature, actually a `NSMethodSignature` instance.
    public static func instanceMethodSignatureForSelector(_ selector: Selector, of instance: any NSObjectProtocol) -> Any?

    /// Get class method for a Objc class.
    /// - Parameters:
    ///   - selector: Method selector
    ///   - cls: Class type.
    /// - Returns: A signature, actually a `NSMethodSignature` instance.
    public static func classMethodSignatureForSelector(_ selector: Selector, of cls: AnyClass) -> Any?

    /// Initializer
    /// - Parameter signature: Method signature returned from invoking ``Invocation/classMethodSignatureForSelector(_:of:)`` or ``Invocation/instanceMethodSignatureForSelector(_:of:)``
    public init(signature: Any)

    /// Set selector will be invoking.
    public func setSelector(_ selector: Selector)

    /// Set argument for the method.
    /// - Parameters:
    ///   - arg: argument using a inout var as `NSObject`
    ///   - index: usually from 2, 0 is `self`, 1 is `_cmd`
    public func setArgument(_ arg: inout any NSObjectProtocol, atIndex index: Int)

    public func retainArguments()

    public func invoke(withTarget target: Any)

    /// Get return value after invoking.
    /// - Parameter ret: return value using a inout var as `NSObject`
    public func getReturnValue(_ ret: inout Any)
}
```

### Keychain

```
import Security
import Foundation

/// A helper class to interact with the Keychain for storing, retrieving, and deleting key-value pairs securely.
public final class Keychain {

    /// The keychain service identifier.
    internal let service: String

    /// The access group for shared keychain items.
    internal var accessGroup: String?

    /// Indicates whether the keychain item should be synchronized to other devices through iCloud.
    public var synchronizable: Bool

    /// Initializes a new instance of Keychain with the specified service and access group.
    /// - Parameters:
    ///   - service: The keychain service identifier. Defaults to the app's bundle identifier.
    ///   - accessGroup: The access group for shared keychain items.
    ///   - synchronizable: synchronize to iCloud or not.
    public init(service: String = Bundle.main.bundleIdentifier ?? "com.reers.keychain", accessGroup: String? = nil, synchronizable: Bool = false)

    /// Stores the provided data in the keychain under the specified key.
    /// - Parameters:
    ///   - value: The data to store in the keychain.
    ///   - key: The key under which to store the data.
    ///   - access: The accessibility level of the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func setData(_ value: Data, forKey key: String, withAccess access: Keychain.Accessibility = .whenUnlocked) -> Keychain.Status

    /// Stores the provided string in the keychain under the specified key.
    /// - Parameters:
    ///   - value: The string to store in the keychain.
    ///   - key: The key under which to store the string.
    ///   - access: The accessibility level of the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func setString(_ value: String, forKey key: String, withAccess access: Keychain.Accessibility = .whenUnlocked) -> Keychain.Status

    /// Retrieves the data stored in the keychain for the specified key.
    /// - Parameter key: The key for which to retrieve the data.
    /// - Returns: A tuple containing the data if found and a status indicating the result of the keychain operation.
    public func getData(_ key: String) -> (data: Data?, status: Keychain.Status)

    /// Retrieves the string stored in the keychain for the specified key.
    /// - Parameter key: The key for which to retrieve the string.
    /// - Returns: A tuple containing the string if found and a status indicating the result of the keychain operation.
    public func getString(_ key: String) -> (string: String?, status: Keychain.Status)

    /// Deletes the keychain item for the specified key.
    /// - Parameter key: The key for which to delete the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func remove(forKey key: String) -> Keychain.Status

    /// Updates the keychain item with the provided data for the specified key.
    /// - Parameters:
    ///   - value: The new data to store in the keychain.
    ///   - key: The key for which to update the keychain item.
    ///   - access: The accessibility level of the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func update(_ value: Data, forKey key: String, withAccess access: Keychain.Accessibility = .whenUnlocked) -> Keychain.Status

    /// Retrieves all keys stored in the keychain for the current service.
    /// - Returns: A tuple containing an array of keys and a status indicating the result of the keychain operation.
    public func allKeys() -> (keys: [String], status: Keychain.Status)

    /// Deletes all keychain items for the current service.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func removeAll() -> Keychain.Status
}

extension Keychain {

    /// Enum representing the accessibility levels for keychain items.
    public enum Accessibility : RawRepresentable {

        /// Item data can only be accessed while the device is unlocked.
        /// This is recommended for items that only need to be accessible while the application is in the foreground.
        /// Items with this attribute will migrate to a new device when using encrypted backups.
        case whenUnlocked

        /// Item data can only be accessed once the device has been unlocked after a restart.
        /// This is recommended for items that need to be accessible by background applications.
        /// Items with this attribute will migrate to a new device when using encrypted backups.
        case afterFirstUnlock

        /// Item data can only be accessed while the device is unlocked.
        /// This class is only available if a passcode is set on the device.
        /// This is recommended for items that only need to be accessible while the application is in the foreground.
        /// Items with this attribute will never migrate to a new device, so after a backup is restored to a new device, these items will be missing.
        /// No items can be stored in this class on devices without a passcode.
        /// Disabling the device passcode will cause all items in this class to be deleted.
        case whenPasscodeSetThisDeviceOnly

        /// Item data can only be accessed while the device is unlocked.
        /// This is recommended for items that only need to be accessible while the application is in the foreground.
        /// Items with this attribute will never migrate to a new device, so after a backup is restored to a new device, these items will be missing.
        case whenUnlockedThisDeviceOnly

        /// Item data can only be accessed once the device has been unlocked after a restart.
        /// This is recommended for items that need to be accessible by background applications.
        /// Items with this attribute will never migrate to a new device, so after a backup is restored to a new device these items will be missing.
        case afterFirstUnlockThisDeviceOnly

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }
}

extension Keychain {

    /// A collection of constants representing keychain attribute keys.
    public struct Attribute {

        /// The service associated with the keychain item.
        public static var service: String { get }

        /// The access group for the keychain item.
        public static var accessGroup: String { get }

        /// The accessibility of the keychain item.
        public static var accessible: String { get }

        /// The account associated with the keychain item.
        public static var account: String { get }

        /// Indicates whether the keychain item is synchronized to other devices through iCloud.
        public static var synchronizable: String { get }

        /// The class of the keychain item.
        public static var `class`: String { get }

        /// A value that indicates the maximum number of results returned.
        public static var matchLimit: String { get }

        /// A Boolean value that indicates whether to return the data from a keychain item.
        public static var returnData: String { get }

        /// The data value of the keychain item.
        public static var valueData: String { get }

        /// A persistent reference to a keychain item.
        public static var returnReference: String { get }

        /// A Boolean value that indicates whether to return a dictionary of attributes for the keychain item.
        public static var returnAttributes: String { get }

        /// A value that specifies that all matching items should be returned.
        public static var matchLimitAll: String { get }
    }
}

extension Keychain {

    /// Enum representing possible status codes returned by keychain APIs.
    public enum Status : OSStatus {

        case success

        case unimplemented

        case diskFull

        case io

        case opWr

        case param

        case wrPerm

        case allocate

        case userCanceled

        case badReq

        case internalComponent

        case notAvailable

        case readOnly

        case authFailed

        case noSuchKeychain

        case invalidKeychain

        case duplicateKeychain

        case duplicateCallback

        case invalidCallback

        case duplicateItem

        case itemNotFound

        case bufferTooSmall

        case dataTooLarge

        case noSuchAttr

        case invalidItemRef

        case invalidSearchRef

        case noSuchClass

        case noDefaultKeychain

        case interactionNotAllowed

        case readOnlyAttr

        case wrongSecVersion

        case keySizeNotAllowed

        case noStorageModule

        case noCertificateModule

        case noPolicyModule

        case interactionRequired

        case dataNotAvailable

        case dataNotModifiable

        case createChainFailed

        case invalidPrefsDomain

        case inDarkWake

        case aclNotSimple

        case policyNotFound

        case invalidTrustSetting

        case noAccessForItem

        case invalidOwnerEdit

        case trustNotAvailable

        case unsupportedFormat

        case unknownFormat

        case keyIsSensitive

        case multiplePrivKeys

        case passphraseRequired

        case invalidPasswordRef

        case invalidTrustSettings

        case noTrustSettings

        case pkcs12VerifyFailure

        case invalidCertificate

        case notSigner

        case policyDenied

        case invalidKey

        case decode

        case `internal`

        case unsupportedAlgorithm

        case unsupportedOperation

        case unsupportedPadding

        case itemInvalidKey

        case itemInvalidKeyType

        case itemInvalidValue

        case itemClassMissing

        case itemMatchUnsupported

        case useItemListUnsupported

        case useKeychainUnsupported

        case useKeychainListUnsupported

        case returnDataUnsupported

        case returnAttributesUnsupported

        case returnRefUnsupported

        case returnPersitentRefUnsupported

        case valueRefUnsupported

        case valuePersistentRefUnsupported

        case returnMissingPointer

        case matchLimitUnsupported

        case itemIllegalQuery

        case waitForCallback

        case missingEntitlement

        case upgradePending

        case mpSignatureInvalid

        case otrTooOld

        case otrIDTooNew

        case serviceNotAvailable

        case insufficientClientID

        case deviceReset

        case deviceFailed

        case appleAddAppACLSubject

        case applePublicKeyIncomplete

        case appleSignatureMismatch

        case appleInvalidKeyStartDate

        case appleInvalidKeyEndDate

        case conversionError

        case appleSSLv2Rollback

        case quotaExceeded

        case fileTooBig

        case invalidDatabaseBlob

        case invalidKeyBlob

        case incompatibleDatabaseBlob

        case incompatibleKeyBlob

        case hostNameMismatch

        case unknownCriticalExtensionFlag

        case noBasicConstraints

        case noBasicConstraintsCA

        case invalidAuthorityKeyID

        case invalidSubjectKeyID

        case invalidKeyUsageForPolicy

        case invalidExtendedKeyUsage

        case invalidIDLinkage

        case pathLengthConstraintExceeded

        case invalidRoot

        case crlExpired

        case crlNotValidYet

        case crlNotFound

        case crlServerDown

        case crlBadURI

        case unknownCertExtension

        case unknownCRLExtension

        case crlNotTrusted

        case crlPolicyFailed

        case idpFailure

        case smimeEmailAddressesNotFound

        case smimeBadExtendedKeyUsage

        case smimeBadKeyUsage

        case smimeKeyUsageNotCritical

        case smimeNoEmailAddress

        case smimeSubjAltNameNotCritical

        case sslBadExtendedKeyUsage

        case ocspBadResponse

        case ocspBadRequest

        case ocspUnavailable

        case ocspStatusUnrecognized

        case endOfData

        case incompleteCertRevocationCheck

        case networkFailure

        case ocspNotTrustedToAnchor

        case recordModified

        case ocspSignatureError

        case ocspNoSigner

        case ocspResponderMalformedReq

        case ocspResponderInternalError

        case ocspResponderTryLater

        case ocspResponderSignatureRequired

        case ocspResponderUnauthorized

        case ocspResponseNonceMismatch

        case codeSigningBadCertChainLength

        case codeSigningNoBasicConstraints

        case codeSigningBadPathLengthConstraint

        case codeSigningNoExtendedKeyUsage

        case codeSigningDevelopment

        case resourceSignBadCertChainLength

        case resourceSignBadExtKeyUsage

        case trustSettingDeny

        case invalidSubjectName

        case unknownQualifiedCertStatement

        case mobileMeRequestQueued

        case mobileMeRequestRedirected

        case mobileMeServerError

        case mobileMeServerNotAvailable

        case mobileMeServerAlreadyExists

        case mobileMeServerServiceErr

        case mobileMeRequestAlreadyPending

        case mobileMeNoRequestPending

        case mobileMeCSRVerifyFailure

        case mobileMeFailedConsistencyCheck

        case notInitialized

        case invalidHandleUsage

        case pvcReferentNotFound

        case functionIntegrityFail

        case internalError

        case memoryError

        case invalidData

        case mdsError

        case invalidPointer

        case selfCheckFailed

        case functionFailed

        case moduleManifestVerifyFailed

        case invalidGUID

        case invalidHandle

        case invalidDBList

        case invalidPassthroughID

        case invalidNetworkAddress

        case crlAlreadySigned

        case invalidNumberOfFields

        case verificationFailure

        case unknownTag

        case invalidSignature

        case invalidName

        case invalidCertificateRef

        case invalidCertificateGroup

        case tagNotFound

        case invalidQuery

        case invalidValue

        case callbackFailed

        case aclDeleteFailed

        case aclReplaceFailed

        case aclAddFailed

        case aclChangeFailed

        case invalidAccessCredentials

        case invalidRecord

        case invalidACL

        case invalidSampleValue

        case incompatibleVersion

        case privilegeNotGranted

        case invalidScope

        case pvcAlreadyConfigured

        case invalidPVC

        case emmLoadFailed

        case emmUnloadFailed

        case addinLoadFailed

        case invalidKeyRef

        case invalidKeyHierarchy

        case addinUnloadFailed

        case libraryReferenceNotFound

        case invalidAddinFunctionTable

        case invalidServiceMask

        case moduleNotLoaded

        case invalidSubServiceID

        case attributeNotInContext

        case moduleManagerInitializeFailed

        case moduleManagerNotFound

        case eventNotificationCallbackNotFound

        case inputLengthError

        case outputLengthError

        case privilegeNotSupported

        case deviceError

        case attachHandleBusy

        case notLoggedIn

        case algorithmMismatch

        case keyUsageIncorrect

        case keyBlobTypeIncorrect

        case keyHeaderInconsistent

        case unsupportedKeyFormat

        case unsupportedKeySize

        case invalidKeyUsageMask

        case unsupportedKeyUsageMask

        case invalidKeyAttributeMask

        case unsupportedKeyAttributeMask

        case invalidKeyLabel

        case unsupportedKeyLabel

        case invalidKeyFormat

        case unsupportedVectorOfBuffers

        case invalidInputVector

        case invalidOutputVector

        case invalidContext

        case invalidAlgorithm

        case invalidAttributeKey

        case missingAttributeKey

        case invalidAttributeInitVector

        case missingAttributeInitVector

        case invalidAttributeSalt

        case missingAttributeSalt

        case invalidAttributePadding

        case missingAttributePadding

        case invalidAttributeRandom

        case missingAttributeRandom

        case invalidAttributeSeed

        case missingAttributeSeed

        case invalidAttributePassphrase

        case missingAttributePassphrase

        case invalidAttributeKeyLength

        case missingAttributeKeyLength

        case invalidAttributeBlockSize

        case missingAttributeBlockSize

        case invalidAttributeOutputSize

        case missingAttributeOutputSize

        case invalidAttributeRounds

        case missingAttributeRounds

        case invalidAlgorithmParms

        case missingAlgorithmParms

        case invalidAttributeLabel

        case missingAttributeLabel

        case invalidAttributeKeyType

        case missingAttributeKeyType

        case invalidAttributeMode

        case missingAttributeMode

        case invalidAttributeEffectiveBits

        case missingAttributeEffectiveBits

        case invalidAttributeStartDate

        case missingAttributeStartDate

        case invalidAttributeEndDate

        case missingAttributeEndDate

        case invalidAttributeVersion

        case missingAttributeVersion

        case invalidAttributePrime

        case missingAttributePrime

        case invalidAttributeBase

        case missingAttributeBase

        case invalidAttributeSubprime

        case missingAttributeSubprime

        case invalidAttributeIterationCount

        case missingAttributeIterationCount

        case invalidAttributeDLDBHandle

        case missingAttributeDLDBHandle

        case invalidAttributeAccessCredentials

        case missingAttributeAccessCredentials

        case invalidAttributePublicKeyFormat

        case missingAttributePublicKeyFormat

        case invalidAttributePrivateKeyFormat

        case missingAttributePrivateKeyFormat

        case invalidAttributeSymmetricKeyFormat

        case missingAttributeSymmetricKeyFormat

        case invalidAttributeWrappedKeyFormat

        case missingAttributeWrappedKeyFormat

        case stagedOperationInProgress

        case stagedOperationNotStarted

        case verifyFailed

        case querySizeUnknown

        case blockSizeMismatch

        case publicKeyInconsistent

        case deviceVerifyFailed

        case invalidLoginName

        case alreadyLoggedIn

        case invalidDigestAlgorithm

        case invalidCRLGroup

        case certificateCannotOperate

        case certificateExpired

        case certificateNotValidYet

        case certificateRevoked

        case certificateSuspended

        case insufficientCredentials

        case invalidAction

        case invalidAuthority

        case verifyActionFailed

        case invalidCertAuthority

        case invalidCRLAuthority

        case invalidCRLEncoding

        case invalidCRLType

        case invalidCRL

        case invalidFormType

        case invalidID

        case invalidIdentifier

        case invalidIndex

        case invalidPolicyIdentifiers

        case invalidTimeString

        case invalidReason

        case invalidRequestInputs

        case invalidResponseVector

        case invalidStopOnPolicy

        case invalidTuple

        case multipleValuesUnsupported

        case notTrusted

        case noDefaultAuthority

        case rejectedForm

        case requestLost

        case requestRejected

        case unsupportedAddressType

        case unsupportedService

        case invalidTupleGroup

        case invalidBaseACLs

        case invalidTupleCredendtials

        case invalidEncoding

        case invalidValidityPeriod

        case invalidRequestor

        case requestDescriptor

        case invalidBundleInfo

        case invalidCRLIndex

        case noFieldValues

        case unsupportedFieldFormat

        case unsupportedIndexInfo

        case unsupportedLocality

        case unsupportedNumAttributes

        case unsupportedNumIndexes

        case unsupportedNumRecordTypes

        case fieldSpecifiedMultiple

        case incompatibleFieldFormat

        case invalidParsingModule

        case databaseLocked

        case datastoreIsOpen

        case missingValue

        case unsupportedQueryLimits

        case unsupportedNumSelectionPreds

        case unsupportedOperator

        case invalidDBLocation

        case invalidAccessRequest

        case invalidIndexInfo

        case invalidNewOwner

        case invalidModifyMode

        case missingRequiredExtension

        case extendedKeyUsageNotCritical

        case timestampMissing

        case timestampInvalid

        case timestampNotTrusted

        case timestampServiceNotAvailable

        case timestampBadAlg

        case timestampBadRequest

        case timestampBadDataFormat

        case timestampTimeNotAvailable

        case timestampUnacceptedPolicy

        case timestampUnacceptedExtension

        case timestampAddInfoNotAvailable

        case timestampSystemFailure

        case signingTimeMissing

        case timestampRejection

        case timestampWaiting

        case timestampRevocationWarning

        case timestampRevocationNotification

        case unexpectedError
    }
}

extension Keychain.Status : RawRepresentable {

    /// Initializes a Keychain.Status from an OSStatus code.
    /// - Parameter status: The OSStatus code.
    public init(status: OSStatus)
}
```

### Reachability

```
import Foundation
import SystemConfiguration
import Dispatch

/// The ``Reachability`` class listens for reachability changes of hosts and addresses for both cellular and
/// WiFi network interfaces.
///
/// Reachability can be used to determine background information about why a network operation failed, or to retry
/// network requests when a connection is established. It should not be used to prevent a user from initiating a network
/// request, as it's possible that an initial request may be required to establish reachability.
open class Reachability {

    /// Defines the various states of network reachability.
    public enum Status {

        /// It is unknown whether the network is reachable.
        case unknown

        /// The network is not reachable.
        case none

        /// The network is reachable on the associated `ConnectionType`.
        case reachable(ConnectionType)

        internal init(_ flags: SCNetworkReachabilityFlags)
    }

    /// Defines the various connection types detected by reachability flags.
    public enum ConnectionType {

        /// The connection type is either over Ethernet or WiFi.
        case ethernetOrWiFi

        /// The connection type is a cellular connection.
        case cellular
    }

    /// A closure executed when the network reachability status changes. The closure takes a single argument: the
    /// network reachability status.
    public typealias OnChangedCallback = (Status) -> Void

    /// Default ``Reachability`` for the zero address and a `callbackQueue` of `.main`.
    public static let `default`: Reachability.Reachability?

    /// Whether the network is currently reachable.
    open var isReachable: Bool { get }

    /// Whether the network is currently reachable over the cellular interface.
    ///
    /// - Note: Using this property to decide whether to make a high or low bandwidth request is not recommended.
    ///         Instead, set the `allowsCellularAccess` on any `URLRequest`s being issued.
    ///
    open var isReachableOnCellular: Bool { get }

    /// Whether the network is currently reachable over Ethernet or WiFi interface.
    open var isReachableOnEthernetOrWiFi: Bool { get }

    /// `DispatchQueue` on which reachability will update.
    public let reachabilityQueue: DispatchQueue

    /// Flags of the current reachability type, if any.
    open var flags: SCNetworkReachabilityFlags? { get }

    /// The current network reachability status.
    open var status: Status { get }

    /// Mutable state storage.
    internal struct MutableState {

        /// A closure executed when the network reachability status changes.
        internal var callback: OnChangedCallback?

        /// `DispatchQueue` on which listeners will be called.
        internal var callbackQueue: DispatchQueue?

        /// Previously calculated status.
        internal var previousStatus: Status?
    }

    /// Creates an instance with the specified host.
    ///
    /// - Note: The `host` value must *not* contain a scheme, just the hostname.
    ///
    /// - Parameters:
    ///   - host:          Host used to evaluate network reachability. Must *not* include the scheme (e.g. `https`).
    public convenience init?(host: String)

    /// Creates an instance that monitors the address 0.0.0.0.
    ///
    /// Reachability treats the 0.0.0.0 address as a special token that causes it to monitor the general routing
    /// status of the device, both IPv4 and IPv6.
    public convenience init?()

    /// Starts listening for changes in network reachability status.
    ///
    /// - Note: Stops and removes any existing listener.
    ///
    /// - Parameters:
    ///   - queue:    `DispatchQueue` on which to call the `callback` closure. `.main` by default.
    ///   - callback: `OnChangedCallback` closure called when reachability changes.
    ///
    /// - Returns: `true` if listening was started successfully, `false` otherwise.
    @discardableResult
    open func startListening(onQueue queue: DispatchQueue = .main, onChanged callback: @escaping OnChangedCallback) -> Bool

    /// Stops listening for changes in network reachability status.
    open func stopListening()

    /// Calls the `callback` closure of the `callbackQueue` if the computed status hasn't changed.
    ///
    /// - Note: Should only be called from the `reachabilityQueue`.
    ///
    /// - Parameter flags: `SCNetworkReachabilityFlags` to use to calculate the status.
    internal func notifyWhenChanged(_ flags: SCNetworkReachabilityFlags)
}

extension Reachability.Status : Equatable {
}

extension SCNetworkReachabilityFlags {

    internal var isReachable: Bool { get }

    internal var isConnectionRequired: Bool { get }

    internal var canConnectAutomatically: Bool { get }

    internal var canConnectWithoutUserInteraction: Bool { get }

    internal var isActuallyReachable: Bool { get }

    internal var isCellular: Bool { get }

    /// Human readable `String` for all states, to help with debugging.
    internal var readableDescription: String { get }
}
```

### TypeNameDescribable

```
import Foundation

/// Return type name of an instance or a type, using by conforming this protocol.
public protocol TypeNameDescribable {

    var typeName: String { get }

    static var typeName: String { get }

    var fullTypeName: String { get }

    static var fullTypeName: String { get }
}

extension TypeNameDescribable {

    /// Return type name of an instance without module name prefix.
    ///
    ///     ModuleA.Foo().typeName -> "Foo"
    public var typeName: String { get }

    /// Return type name of a type without module name prefix.
    ///
    ///     ModuleA.Foo.typeName -> "Foo"
    public static var typeName: String { get }

    /// Return full type name of a type with module name prefix.
    /// But if the instance is an objective-c class object, it still return a name without module name prefix.
    ///
    ///     ModuleA.Foo().typeName -> "ModuleA.Foo"
    public var fullTypeName: String { get }

    /// Return full type name of a type with module name prefix.
    /// But if the type is an objective-c class, it still return a name without module name prefix.
    ///
    ///     ModuleA.Foo().typeName -> "ModuleA.Foo"
    public static var fullTypeName: String { get }
}
/// Get module name from a swift file ID.
/// - Parameter fileId: No need to pass it, just use the default.
/// - Returns: Module name, return `""` if failed.
public func moduleName(fileId: String = #fileID) -> String
```

### Vibrator

```
import UIKit

public struct Vibrator {

    public enum FeedbackStyle : Int {

        case light

        case medium

        case heavy

        case soft

        case rigid

        case selectionChanged

        case success

        case warning

        case error

        internal var impactStyle: UIImpactFeedbackGenerator.FeedbackStyle { get }

        internal var notificationType: UINotificationFeedbackGenerator.FeedbackType { get }
    }

    public static func occur(_ style: FeedbackStyle, intensity: CGFloat = 1.0)
}
```

### Memory

```
import Darwin

public enum MemoryAlign : Int {

    case one, two, four, eight
}

public enum StringMemoryType : UInt8 {

    case text

    case taggedPointer

    case heap

    case unknow
}



/// ReerKit: Utilities for checking memory structure.
public struct Memory<T> {

    /// ReerKit: Get memory data for the variable in byte array format
    public static func bytes(ofVal v: inout T) -> [UInt8]

    /// ReerKit: Get the memory data pointed to by the reference in byte array format.
    public static func bytes(ofRef v: T) -> [UInt8]

    /// ReerKit: Get memory data for the variable in string format
    /// 
    /// - Parameter alignment: Represent how many bytes are grouped together
    /// - Parameter v: The value type value.
    /// - Returns: Get memory data.
    public static func string(ofVal v: inout T, alignment: MemoryAlign? = nil) -> String

    /// ReerKit: Get the memory data pointed to by the reference in string format
    ///
    /// - Parameter alignment: Represent how many bytes are grouped together
    /// - Parameter v: The reference type value
    /// - Returns: Get memory data.
    public static func string(ofRef v: T, alignment: MemoryAlign? = nil) -> String

    /// ReerKit: Get the memory address of the variable
    public static func pointer(ofVal v: inout T) -> UnsafeRawPointer

    /// ReerKit: Get the address of the memory pointed to by the reference
    public static func pointer(ofRef v: T) -> UnsafeRawPointer

    /// ReerKit: Get the memory size occupied by the variable
    public static func size(ofVal v: inout T) -> Int

    /// ReerKit: Get the size of the memory pointed to by the reference
    public static func size(ofRef v: T) -> Int
}

public extension <<error type>> {

    public mutating func memoryType() -> StringMemoryType
}
```

### MulticastDelegate

```
public protocol MulticastDelegateProtocol {

    associatedtype Delegate

    func add(delegate: Delegate)

    func remove(delegate: Delegate)

    func removeAllDelegates()
}

/// `MulticastDelegate` lets you easily create a "multicast delegate" for a given protocol or class.
/// The delegate will be a weak reference in `MulticastDelegate`, and will be removed automatically
/// from `delegates` after it released.
public final class MulticastDelegate<T> {

    /// ReerKit: Initialize a new `MulticastDelegate`, and delete references will be weak.
    public init()

    /// ReerKit: Use the property to check if no delegates are contained there.
    public var isEmpty: Bool { get }

    /// ReerKit: Add a delegate.
    public func add(_ delegate: T)

    /// ReerKit: Remove a previously-added delegate.
    public func remove(_ delegate: T)

    public func removeAllDelegates()

    @available(*, deprecated, renamed: "notify(_:)", message: "Use notify(_:) instead.")
    public func invoke(_ invocation: (T) -> Void)

    /// ReerKit: Notify a closure on each delegate.
    public func notify(_ function: (T) -> Void)

    /// ReerKit: Checks if the multicast delegate contains the given delegate.
    public func contains(_ delegate: T) -> Bool
}
```

### NanoID

```
import Security

public struct NanoID {

    /// Generate a new identifier
    ///
    /// - Parameters:
    ///   - alphabet: alphabet to use, exclude to use instance default
    ///   - size: size to use, exclude to use instance default
    ///   - randomizer: randomizer to use, exclude to use instance default
    public static func generate(alphabet: Alphabet = .default, size: UInt = 21, randomizer: Randomizer = defaultRandomizer) -> String

    public static var defaultRandomizer: Randomizer
}

extension NanoID {

    public struct Alphabet {

        internal let characters: [Character]

        public var size: Int { get }

        /// ReerKit: Initializes an alphabet given one or more strings
        /// - Parameter alphabet: Strings to build the alphabet from
        public init(_ alphabet: String...)

        /// Returns a single character from the alphabet
        ///
        /// - Parameter index: The position of the character to return
        public func character(at index: Int) -> Character

        /// Returns a single character from the alphabet given a byte
        ///
        /// - Parameter byte: The byte used to determine the character's position
        public func character(from byte: UInt8) -> Character

        public static let numbers: NanoID.NanoID.Alphabet

        public static let lowercaseLetters: NanoID.NanoID.Alphabet

        public static let uppercaseLetters: NanoID.NanoID.Alphabet

        public static let letters: NanoID.NanoID.Alphabet

        public static let `default`: NanoID.NanoID.Alphabet
    }
}

public protocol Randomizer {

    func getCharacters(count: UInt, from alphabet: NanoID.Alphabet) -> [Character]
}

public struct SecureRandomizer : Randomizer {

    public func getCharacters(count: UInt, from alphabet: NanoID.Alphabet) -> [Character]
}

public struct IntRandomizer : Randomizer {

    public func getCharacters(count: UInt, from alphabet: NanoID.Alphabet) -> [Character]
}
```

### KeyboardManager

```
import UIKit
import ObjectiveC
import CoreFoundation

/// The protocol defines the method you can use
/// to receive system keyboard change information.
public protocol KeyboardObserver : AnyObject {

    func keyboardChanged(with transition: KeyboardTransition)
}

/// System keyboard transition information.
/// Use `convert(rect:toView:)` to convert frame to specified view.
public struct KeyboardTransition {

    public var toHidden: Bool

    public var toVisible: Bool

    public var fromFrame: CGRect

    public var toFrame: CGRect

    public var animationDuration: TimeInterval

    public var animationCurve: UIView.AnimationCurve

    public var animationOption: UIView.AnimationOptions
}

/// A KeyboardManager object lets you get the system keyboard information,
/// and track the keyboard visible/frame/transition.
///
/// You should access this class in main thread and add observer before keyboard will show.
public final class KeyboardManager : NSObject {

    public static let shared: KeyboardManager.KeyboardManager

    /// Get the keyboard window. nil if there's no keyboard window.
    public var keyboardWindow: UIWindow? { get }

    /// Get the keyboard view. nil if there's no keyboard view.
    public var keyboardView: UIView? { get }

    /// Whether the keyboard is visible.
    public var isKeyboardVisible: Bool { get }

    /// Get the keyboard frame. CGRect.null if there's no keyboard view.
    /// Use convert(rect:toView:) to convert frame to specified view.
    public var keyboardFrame: CGRect { get }

    /// Add an observer to manager to get keyboard change information.
    /// This method makes a weak reference to the observer.
    public func addObserver(_ observer: KeyboardObserver)

    /// Remove an observer from manager.
    /// No need to remove observer in `deinit` method, ``KeyboardManager`` will remove observer automatically.
    public func removeObserver(_ observer: KeyboardObserver)

    public func convertRect(_ rect: CGRect, toView view: UIView?) -> CGRect
}
```

## StandardLibrary+REExtensions

### AnyObjectExtensionable

#### Associatable

```
import ObjectiveC

/// The ability to use the convenient association functions.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol Associatable {
}

/// ReerKit: Policies related to associative references.
public enum AssociationPolicy {

    /// Specifies a weak reference to the associated object.
    case assign

    /// Specifies a strong reference to the associated object.
    /// The association is not made atomically.
    case retain

    /// Specifies that the associated object is copied.
    /// The association is not made atomically.
    case copy

    /// Specifies a strong reference to the associated object.
    /// The association is made atomically.
    case retainAtomic

    /// Specifies that the associated object is copied.
    /// The association is made atomically.
    case copyAtomic
}


public struct AssociationKey {

    internal let address: UnsafeRawPointer

    /// ReerKit: Create an ObjC association key.
    ///
    /// - warning: The key must be uniqued.
    public init()

    /// ReerKit: Create an ObjC association key from a `StaticString`.
    ///
    ///     let key1 = AssociationKey("SomeString" as StaticString)
    ///     let key2 = AssociationKey(#function as StaticString)
    ///
    /// - precondition: `key` has a pointer representation.
    public init(_ key: StaticString)

    /// ReerKit: Create an ObjC association key from a `Selector`.
    ///
    ///     @objc var foo: String {
    ///         get {
    ///             re.associatedValue(forKey: AssociationKey(#selector(getter: self.foo)), default: "23")
    ///         }
    ///     }
    ///
    /// - Parameter key: An @objc function or computed property selector.
    public init(_ key: Selector)
}

public extension <<error type>> {

    /// ReerKit: Sets an associated value for self using a given key and association policy.
    ///
    ///     let obj = NSObject()
    ///     let key = AssociationKey("bar" as StaticString)
    ///     obj.re.setAssociatedValue(123, forKey: key)
    ///
    /// - Parameters:
    ///   - value: The source value for the association.
    ///   - key: The key for the association.
    ///   - policy: The policy for the association. For possible values, see `AssociationPolicy`
    public func setAssociatedValue(_ value: Any?, forKey key: AssociationKey, withPolicy policy: AssociationPolicy = .retain)

    /// ReerKit: Returns the value associated on self for a given key.
    ///
    ///     let value: Int? = obj.re.associatedValue(forKey: key)
    ///
    /// - Parameter key: The key for the association.
    /// - Returns: The value associated with the key.
    public func associatedValue<Value>(forKey key: AssociationKey) -> Value?

    /// ReerKit: Returns the value associated on self for a given key.
    ///
    ///     let value = obj.re.associatedValue(forKey: key, default: 123)
    ///
    /// - Parameters:
    ///   - key: The key for the association.
    ///   - default: Default value for the result.
    /// - Returns: The value associated with the key.
    public func associatedValue<Value>(forKey key: AssociationKey, default: Value) -> Value

    /// ReerKit: Sets an associated weak object for self using a given key.
    ///
    ///     let obj = NSObject()
    ///     let key = AssociationKey("bar" as StaticString)
    ///     obj.re.setAssociatedWeakObject(NSObject(), forKey: key)
    ///     let value: Int? = obj.re.associatedValue(forKey: key)
    ///
    /// - Parameters:
    ///   - object: The source object for the association.
    ///   - key: The key for the association.
    public func setAssociatedWeakObject<Object>(_ object: Object, forKey key: AssociationKey) where Object : AnyObject

    /// ReerKit: Returns the weak object associated on self for a given key.
    ///
    ///     let obj = obj.re.associatedWeakObject(forKey: key) as NSObject?
    ///
    /// - Parameters:
    ///   - key: The key for the association.
    /// - Returns: The object associated with the key.
    public func associatedWeakObject<Object>(forKey key: AssociationKey) -> Object? where Object : AnyObject
}
```

#### DeinitObservable

```
/// The ability to observe AnyObject deinit.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol DeinitObservable: ReerCompatible {}
public extension Reer where Base: AnyObject {
    func onDeinit(perform action: @escaping () -> Void)
}
```

#### OnceExecutable

```
/// The ability to execute a closure once.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol OnceExecutable: ReerCompatible {}

public typealias OnceKey = AssociationKey

public extension Reer where Base: AnyObject {

    /// ReerKit: Execute the passed closure once by a key during the object life time.
    ///
    ///     let obj = NSObject()
    ///     func test() {
    ///         obj.re.executeOnce(byKey: key) { print("once") }
    ///     }
    ///     test()
    ///     test()
    ///     obj.re.executeOnce(byKey: key) { print("once") }
    ///     // output: once
    @discardableResult
    public func executeOnce<Result>(byKey key: OnceKey, _ execute: @escaping () throws -> Result) rethrows -> Result

    /// ReerKit: Execute the passed closure once by a auto generated key during the object life time.
    ///
    ///     let obj = NSObject()
    ///     func test() {
    ///         obj.re.executeOnce { print("once") }
    ///     }
    ///     test()
    ///     test()
    ///     // output: once
    @discardableResult
    public func executeOnce<Result>(fileID: String = #fileID, function: String = #function, line: Int = #line, _ execute: @escaping () throws -> Result) rethrows -> Result
}
```

#### Swizzlable

```
import ObjectiveC

/// The ability to swizzle method conveniently.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol Swizzlable: ReerCompatible {}

public extension Reer where Base: AnyObject {

    /// ReerKit: Swizzle instance method of the class.
    /// Also you can use ability from Swift, see `@_dynamicReplacement(for: )`
    ///
    /// - Parameters:
    ///   - originalSelector: The selector must be a `@objc dynamic` method.
    ///   - swizzledSelector: The selector must be a `@objc` method.
    /// - Returns: Successful or not.
    @discardableResult
    public static func swizzleInstanceMethod(_ originalSelector: Selector, with swizzledSelector: Selector) -> Bool

    /// ReerKit: Swizzle class method of the class.
    /// Also you can use ability from Swift, see `@_dynamicReplacement(for: )`
    ///
    /// - Parameters:
    ///   - originalSelector: The selector must be a `@objc dynamic` method.
    ///   - swizzledSelector: The selector must be a `@objc` method.
    /// - Returns: Successful or not.
    @discardableResult
    public static func swizzleClassMethod(_ originalSelector: Selector, with swizzledSelector: Selector) -> Bool
}
```

### Array+REExtensions

```
import Foundation

extension Array: ReerReferenceGenericCompatible {
    public typealias T = Element
}

public extension ReerReferenceGeneric where Base == Array<T> {

    /// ReerKit: Insert an element at the beginning of array.
    ///
    ///     var array = [2, 3, 4, 5]
    ///     array.re.prepend(1) -> [1, 2, 3, 4, 5]
    ///
    /// - Parameter newElement: element to insert.
    public mutating func prepend(_ newElement: T)

    /// ReerKit: Safely swap values at given index positions.
    ///
    ///     var array = [1, 2, 3, 4, 5]
    ///     array.re.swapAt(3, 0) -> [4, 2, 3, 1, 5]
    ///     array.re.swapAt(3, 10) -> [1, 2, 3, 4, 5]
    ///
    /// - Parameters:
    ///   - index: index of first element.
    ///   - otherIndex: index of other element.
    public mutating func swapAt(_ index: Base.Index, _ otherIndex: Base.Index)
}

public extension ReerReferenceGeneric where Base == Array<T>, T: Equatable {

    /// ReerKit: Appends a new element to the array only if it doesn't already exist
    /// - Parameter newElement: The element to append
    /// - Complexity: O(n), where n is the length of the array
    public mutating func appendIfNotExist(_ newElement: T)

    /// ReerKit: Appends multiple elements to the array, excluding any duplicates
    /// - Parameter newElements: An array of elements to append
    /// - Complexity: O(n*m), where n is the length of the current array
    ///   and m is the length of newElements
    public mutating func appendIfNotExist(contentsOf newElements: [T])

    /// ReerKit: Remove all instances of an item from array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removeAll(2) -> [1, 3, 4, 5]
    ///        ["h", "e", "l", "l", "o"].re.removeAll("l") -> ["h", "e", "o"]
    ///
    /// - Parameter item: item to remove.
    /// - Returns: self after removing all instances of item.
    @discardableResult
    public mutating func removeAll(_ item: T) -> [T]

    /// ReerKit: Remove all instances contained in items parameter from array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removeAll([2,5]) -> [1, 3, 4]
    ///        ["h", "e", "l", "l", "o"].re.removeAll(["l", "h"]) -> ["e", "o"]
    ///
    /// - Parameter items: items to remove.
    /// - Returns: self after removing all instances of all items in given array.
    @discardableResult
    public mutating func removeAll(_ items: [T]) -> [T]

    /// ReerKit: Remove all duplicate elements from Array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removeDuplicates() -> [1, 2, 3, 4, 5]
    ///        ["h", "e", "l", "l", "o"].re.removeDuplicates() -> ["h", "e", "l", "o"]
    ///
    /// - Returns: Return array with all duplicate elements removed.
    @discardableResult
    public mutating func removeDuplicates() -> [T]
}

extension Array: ReerGenericCompatible {}

public extension ReerGeneric where Base == Array<T>, T: Equatable {

    /// ReerKit: Removing all duplicate elements from Array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removingDuplicates() -> [1, 2, 3, 4, 5]
    ///        ["h", "e", "l", "l", "o"].re.removingDuplicates() -> ["h", "e", "l", "o"]
    ///
    /// - Returns: Return array with all duplicate elements removed.
    public func removingDuplicates() -> [T]

    /// ReerKit: Returns an array with all duplicate elements removed using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Equatable.
    /// - Returns: an array of unique elements.
    public func removingDuplicates<U>(byKeyPath path: KeyPath<T, U>) -> [T] where U : Equatable

    /// ReerKit: Returns an array with all duplicate elements removed using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Hashable.
    /// - Returns: an array of unique elements.
    public func removingDuplicates<U>(byKeyPath path: KeyPath<T, U>) -> [T] where U : Hashable
}

public extension ReerGeneric where Base == Array<T> {

    /// ReerKit: JSON Data from array.
    ///
    /// - Parameter prettify: set true to prettify data (default is false).
    /// - Returns: optional JSON Data (if applicable).
    public func jsonData(prettify: Bool = false) -> Data?

    /// ReerKit: JSON String from array.
    ///
    ///        array.re.jsonString() -> "[{\"abc\":123}]"
    ///
    /// - Parameter prettify: set true to prettify string (default is false).
    /// - Returns: optional JSON String (if applicable).
    public func jsonString(prettify: Bool = false) -> String?
}
```

### BinaryFloatingPoint

```
import Foundation

public extension Reer where Base: BinaryFloatingPoint {

    /// ReerKit: Returns a rounded value with the specified number of decimal places and rounding rule. If `numberOfDecimalPlaces` is negative, `0` will be used.
    ///
    ///     let num = 3.1415927
    ///     num.re.rounded(3, rule: .up) -> 3.142
    ///     num.re.rounded(3, rule: .down) -> 3.141
    ///     num.re.rounded(2, rule: .awayFromZero) -> 3.15
    ///     num.re.rounded(4, rule: .towardZero) -> 3.1415
    ///     num.re.rounded(-1, rule: .toNearestOrEven) -> 3
    ///
    /// - Parameters:
    ///   - numberOfDecimalPlaces: The expected number of decimal places.
    ///   - rule: The rounding rule to use.
    /// - Returns: The rounded value.
    public func rounded(_ numberOfDecimalPlaces: Int, rule: FloatingPointRoundingRule = .toNearestOrAwayFromZero) -> Base
}
```

### BinaryInteger

```
public extension Reer where Base: BinaryInteger {

    /// ReetKit: The raw bytes of the integer.
    ///
    ///     var number = Int16(-128)
    ///     print(number.re.bytes)
    ///     // prints "[255, 128]"
    ///
    public var bytes: [UInt8] { get }
}

public extension BinaryInteger {

    /// ReetKit: Creates a `BinaryInteger` from a raw byte representaion.
    ///
    ///     var number = Int16.re(bytes: [0xFF, 0b1111_1101])
    ///     print(number!)
    ///     // prints "-3"
    ///
    /// - Parameter bytes: An array of bytes representing the value of the integer.
    ///
    public static func re(bytes: [UInt8]) -> Self?
}
```

### Bool

```
extension Bool: ReerCompatibleValue {}
public extension Reer where Base == Bool {

    /// ReerKit: Return 1 if true, or 0 if false.
    ///
    ///     false.re.int -> 0
    ///     true.re.int -> 1
    ///
    public var int: Int { get }

    /// ReerKit: Return "true" if true, or "false" if false.
    ///
    ///     false.re.string -> "false"
    ///     true.re.string -> "true"
    ///
    public var string: String { get }
}
```

### Character

```
extension Character: ReerCompatibleValue {}
public extension Reer where Base == Character {

    /// ReerKit: Check if character is emoji.
    ///
    ///     Character("😀").re.isEmoji -> true
    ///
    public var isEmoji: Bool { get }

    /// ReerKit: Integer from character (if applicable).
    ///
    ///     Character("1").re.int -> 1
    ///     Character("A").re.int -> nil
    ///
    public var int: Int? { get }

    /// ReerKit: String from character.
    ///
    ///     Character("a").re.string -> "a"
    ///
    public var string: String { get }

    /// ReerKit: Return the character lowercased.
    ///
    ///     Character("A").re.lowercased -> Character("a")
    ///
    public var lowercased: Character { get }

    /// ReerKit: Return the character uppercased.
    ///
    ///     Character("a").re.uppercased -> Character("A")
    ///
    public var uppercased: Character { get }
}

public extension Reer where Base == Character {

    /// ReerKit: Random character.
    ///
    ///    Character.re.random() -> k
    ///
    /// - Returns: A random character.
    public static func randomAlphanumeric() -> Character
}
```

### Collection

```
import Dispatch

public extension Reer where Base: Collection {

    /// ReerKit: The full range of the collection.
    public var fullRange: Range<Base.Index> { get }
}

public extension Reer where Base: Collection {

    /// ReerKit: Performs `each` closure for each element of collection in parallel.
    ///
    ///        array.re.forEachInParallel { item in
    ///            print(item)
    ///        }
    ///
    /// - Parameter each: closure to run for each element.
    public func forEachInParallel(_ each: (Base.Element) -> Void)

    /// ReerKit: Safe protects the array from out of bounds by use of optional.
    ///
    ///        let arr = [1, 2, 3, 4, 5]
    ///        arr.re[1] -> 2
    ///        arr.re[10] -> nil
    ///
    /// - Parameter index: index of element to access element.
    public subscript(index: Base.Index) -> Base.Element? { get }

    /// ReerKit: Returns an array of slices of length "size" from the array. If array can't be split evenly, the final slice will be the remaining elements.
    ///
    ///     [0, 2, 4, 7].re.group(by: 2) -> [[0, 2], [4, 7]]
    ///     [0, 2, 4, 7, 6].re.group(by: 2) -> [[0, 2], [4, 7], [6]]
    ///
    /// - Parameter size: The size of the slices to be returned.
    /// - Returns: grouped self.
    public func group(by size: Int) -> [[Base.Element]]?

    /// ReerKit: Get all indices where condition is met.
    ///
    ///     [1, 7, 1, 2, 4, 1, 8].re.indices(where: { $0 == 1 }) -> [0, 2, 5]
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: all indices where the specified condition evaluates to true (optional).
    public func indices(where condition: (Base.Element) throws -> Bool) rethrows -> [Base.Index]?

    /// ReerKit: Calls the given closure with an array of size of the parameter slice.
    ///
    ///     [0, 2, 4, 7].re.forEach(slice: 2) { print($0) } -> // print: [0, 2], [4, 7]
    ///     [0, 2, 4, 7, 6].re.forEach(slice: 2) { print($0) } -> // print: [0, 2], [4, 7], [6]
    ///
    /// - Parameters:
    ///   - slice: size of array in each interation.
    ///   - body: a closure that takes an array of slice size as a parameter.
    public func forEach(slice: Int, body: ([Base.Element]) throws -> Void) rethrows

    public func forEach(_ body: (Base.Element, Int) throws -> Void) rethrows
}

public extension Reer where Base: Collection, Base.Element: Equatable {

    /// ReerKit: All indices of specified item.
    ///
    ///        [1, 2, 2, 3, 4, 2, 5].re.indices(of 2) -> [1, 2, 5]
    ///        [1.2, 2.3, 4.5, 3.4, 4.5].re.indices(of 2.3) -> [1]
    ///        ["h", "e", "l", "l", "o"].re.indices(of "l") -> [2, 3]
    ///
    /// - Parameter item: item to check.
    /// - Returns: an array with all indices of the given item.
    public func indices(of item: Base.Element) -> [Base.Index]
}

public extension Reer where Base: Collection, Base.Element: BinaryInteger {

    /// ReerKit: Average of all elements in array.
    ///
    /// - Returns: the average of the array's elements.
    public func average() -> Double
}

public extension Reer where Base: Collection, Base.Element: FloatingPoint {

    /// ReerKit: Average of all elements in array.
    ///
    ///        [1.2, 2.3, 4.5, 3.4, 4.5].re.average() = 3.18
    ///
    /// - Returns: average of the array's elements.
    public func average() -> Base.Element
}
```

### Comparable

```
public extension ReerForEquatable where Base: Comparable {

    /// ReetKit: Returns true if value is in the provided range.
    ///
    ///     1.re.isBetween(5...7) // false
    ///     7.re.isBetween(6...12) // true
    ///     date.re.isBetween(date1...date2)
    ///     "c".re.isBetween(a...d) // true
    ///     0.32.re.isBetween(0.31...0.33) // true
    ///
    /// - Parameter range: Closed range against which the value is checked to be included.
    /// - Returns: `true` if the value is included in the range, `false` otherwise.
    public func isBetween(_ range: ClosedRange<Base>) -> Bool

    /// ReetKit: Returns value limited within the provided range.
    ///
    ///     1.re.clamped(to: 3...8) // 3
    ///     4.re.clamped(to: 3...7) // 4
    ///     "c".re.clamped(to: "e"..."g") // "e"
    ///     0.32.re.clamped(to: 0.1...0.29) // 0.29
    ///
    /// - Parameter range: Closed range that limits the value.
    /// - Returns: A value limited to the range, i.e. between `range.lowerBound` and `range.upperBound`.
    public func clamped(to range: ClosedRange<Base>) -> Base
}
```

### Decodable

```
import Foundation

public extension Decodable {

    /// ReerKit: Parsing the model in Decodable type.
    /// - Parameters:
    ///   - data: Data.
    ///   - decoder: JSONDecoder. Initialized by default.
    public static func re(data: Data, using decoder: JSONDecoder = .init()) -> Self?
}
```

### Dictionary

```
import Foundation

public protocol DMLDictionary : Collection {

    associatedtype Key : ExpressibleByStringLiteral, Hashable

    associatedtype Value

    func value(forKey key: Key) -> Value?
}

extension Dictionary : DMLDictionary where Key : ExpressibleByStringLiteral {

    public typealias Key = Key

    public typealias Value = Value

    public func value(forKey key: Key) -> Value?
}

@dynamicMemberLookup public struct DML<Base> where Base : main.DMLDictionary {

    public init(_ base: Base)

    public subscript(dynamicMember member: Base.Key) -> Base.Value? { get }
}

public extension Dictionary where Key : ExpressibleByStringLiteral {

    public var dml: DML<`Self`> { get set }
}

extension Dictionary : ReerGeneric2Compatible {

    public typealias T1 = Key

    public typealias T2 = Value
}

public extension ReerGeneric2 where Base == Dictionary<T1, T2> {

    /// ReerKit: Query string from dictionary.
    public var queryString: String { get }

    /// ReerKit: Returns [String: String] for self.
    /// Returns nil if an error occurs.
    public var stringDictionary: [String : String]? { get }

    /// ReerKit: Check if key exists in dictionary.
    ///
    ///        let dict: [String: Any] = ["testKey": "testValue", "testArrayKey": [1, 2, 3, 4, 5]]
    ///        dict.re.has(key: "testKey") -> true
    ///        dict.re.has(key: "anotherKey") -> false
    ///
    /// - Parameter key: key to search for.
    /// - Returns: true if key exists in dictionary.
    public func has(key: T1) -> Bool

    /// ReerKit: JSON Data from dictionary.
    ///
    /// - Parameter prettify: set true to prettify data (default is false).
    /// - Returns: optional JSON Data (if applicable).
    public func jsonData(prettify: Bool = false) -> Data?

    /// ReerKit: JSON String from dictionary.
    ///
    ///        dict.re.jsonString() -> "{"testKey":"testValue","testArrayKey":[1,2,3,4,5]}"
    ///
    ///        dict.re.jsonString(prettify: true)
    ///        /*
    ///        returns the following string:
    ///
    ///        "{
    ///        "testKey" : "testValue",
    ///        "testArrayKey" : [
    ///            1,
    ///            2,
    ///            3,
    ///            4,
    ///            5
    ///        ]
    ///        }"
    ///
    ///        */
    ///
    /// - Parameter prettify: set true to prettify string (default is false).
    /// - Returns: optional JSON String (if applicable).
    public func jsonString(prettify: Bool = false) -> String?

    /// ReerKit: Returns a dictionary containing the results of mapping the given closure over the sequence’s elements.
    /// - Parameter transform: A mapping closure. `transform` accepts an element of this sequence as its parameter and returns a transformed value of the same or   of a different type.
    /// - Returns: A dictionary containing the transformed elements of this sequence.
    public func mapKeysAndValues<K, V>(_ transform: ((key: T1, value: T2)) throws -> (K, V)) rethrows -> [K : V] where K : Hashable

    /// ReerKit: Returns a dictionary containing the non-`nil` results of calling the given transformation with each element of this sequence.
    /// - Parameter transform: A closure that accepts an element of this sequence as its argument and returns an optional value.
    /// - Returns: A dictionary of the non-`nil` results of calling `transform` with each element of the sequence.
    /// - Complexity: *O(m + n)*, where _m_ is the length of this sequence and _n_ is the length of the result.
    public func compactMapKeysAndValues<K, V>(_ transform: ((key: T1, value: T2)) throws -> (K, V)?) rethrows -> [K : V] where K : Hashable

    /// ReerKit: Creates a new dictionary using specified keys.
    ///
    ///        var dict =  ["key1": 1, "key2": 2, "key3": 3, "key4": 4]
    ///        dict.re.pick(keys: ["key1", "key3", "key4"]) -> ["key1": 1, "key3": 3, "key4": 4]
    ///        dict.re.pick(keys: ["key2"]) -> ["key2": 2]
    ///
    /// - Complexity: O(K), where _K_ is the length of the keys array.
    ///
    /// - Parameter keys: An array of keys that will be the entries in the resulting dictionary.
    ///
    /// - Returns: A new dictionary that contains the specified keys only. If none of the keys exist, an empty dictionary will be returned.
    public func pick(keys: [T1]) -> [T1 : T2]
}

public extension ReerGeneric2 where Base == Dictionary<T1, T2>, T2: Equatable {

    /// ReerKit: Returns an array of all keys that have the given value in dictionary.
    ///
    ///        let dict = ["key1": "value1", "key2": "value1", "key3": "value2"]
    ///        dict.re.keys(forValue: "value1") -> ["key1", "key2"]
    ///        dict.re.keys(forValue: "value2") -> ["key3"]
    ///        dict.re.keys(forValue: "value3") -> []
    ///
    /// - Parameter value: Value for which keys are to be fetched.
    /// - Returns: An array containing keys that have the given value.
    public func keys(forValue value: T2) -> [T1]
}

extension Dictionary : ReerReferenceGeneric2Compatible {

    public typealias U1 = Key

    public typealias U2 = Value
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2> {

    /// ReerKit: Remove all keys contained in the keys parameter from the dictionary.
    ///
    ///        var dict : [String: String] = ["key1" : "value1", "key2" : "value2", "key3" : "value3"]
    ///        dict.re.removeAll(keys: ["key1", "key2"])
    ///        dict.re.keys.contains("key3") -> true
    ///        dict.re.keys.contains("key1") -> false
    ///        dict.re.keys.contains("key2") -> false
    ///
    /// - Parameter keys: keys to be removed.
    public mutating func removeAll<S>(keys: S) where S : Sequence, S.Element == <<error type>>

    /// ReerKit: Remove a value for a random key from the dictionary.
    @discardableResult
    public mutating func removeValueForRandomKey() -> U2?
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2>, U1: StringProtocol {

    /// ReerKit: Lowercase all keys in dictionary.
    ///
    ///        var dict = ["tEstKeY": "value"]
    ///        dict.re.lowercaseAllKeys()
    ///        print(dict) // prints "["testkey": "value"]"
    ///
    public mutating func lowercaseAllKeys()
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2> {

    /// ReerKit: Deep fetch or set a value from nested dictionaries.
    ///
    ///        var dict =  ["key": ["key1": ["key2": "value"]]]
    ///        dict.re[path: ["key", "key1", "key2"]] = "newValue"
    ///        dict.re[path: ["key", "key1", "key2"]] -> "newValue"
    ///
    /// - Note: Value fetching is iterative, while setting is recursive.
    ///
    /// - Complexity: O(N), _N_ being the length of the path passed in.
    ///
    /// - Parameter path: An array of keys to the desired value.
    ///
    /// - Returns: The value for the key-path passed in. `nil` if no value is found.
    public subscript(path path: [U1]) -> Any? { get set }
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2>, U1 == String {

    /// ReerKit: Deep fetch or set a value from nested dictionaries.
    ///
    ///        var dict =  ["key": ["key1": ["key2": "value"]]]
    ///        dict.re[path: "key.key1.key2"] = "newValue"
    ///        dict.re[path: "key.key1.key2"] -> "newValue"
    ///
    /// - Note: Value fetching is iterative, while setting is recursive.
    ///
    /// - Complexity: O(N), _N_ being the length of the path passed in.
    ///
    /// - Parameter path: An array of keys to the desired value.
    ///
    /// - Returns: The value for the key-path passed in. `nil` if no value is found.
    public subscript(path path: U1) -> Any? { get set }
}

public extension Dictionary {

    /// ReerKit: Merge the keys/values of two dictionaries.
    ///
    ///        let dict: [String: String] = ["key1": "value1"]
    ///        let dict2: [String: String] = ["key2": "value2"]
    ///        let result = dict + dict2
    ///        result["key1"] -> "value1"
    ///        result["key2"] -> "value2"
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - rhs: dictionary.
    /// - Returns: An dictionary with keys and values from both.
    public static func + (lhs: [Key : Value], rhs: [Key : Value]) -> [Key : Value]

    /// ReerKit: Append the keys and values from the second dictionary into the first one.
    ///
    ///        var dict: [String: String] = ["key1": "value1"]
    ///        let dict2: [String: String] = ["key2": "value2"]
    ///        dict += dict2
    ///        dict["key1"] -> "value1"
    ///        dict["key2"] -> "value2"
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - rhs: dictionary.
    public static func += (lhs: inout [Key : Value], rhs: [Key : Value])

    /// ReerKit: Remove keys contained in the sequence from the dictionary.
    ///
    ///        let dict: [String: String] = ["key1": "value1", "key2": "value2", "key3": "value3"]
    ///        let result = dict - ["key1", "key2"]
    ///        result.keys.contains("key3") -> true
    ///        result.keys.contains("key1") -> false
    ///        result.keys.contains("key2") -> false
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - keys: array with the keys to be removed.
    /// - Returns: a new dictionary with keys removed.
    public static func - <S>(lhs: [Key : Value], keys: S) -> [Key : Value] where Key == S.Element, S : Sequence

    /// ReerKit: Remove keys contained in the sequence from the dictionary.
    ///
    ///        var dict: [String: String] = ["key1": "value1", "key2": "value2", "key3": "value3"]
    ///        dict -= ["key1", "key2"]
    ///        dict.keys.contains("key3") -> true
    ///        dict.keys.contains("key1") -> false
    ///        dict.keys.contains("key2") -> false
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - keys: array with the keys to be removed.
    public static func -= <S>(lhs: inout [Key : Value], keys: S) where Key == S.Element, S : Sequence
}

public extension Dictionary {

    /// ReerKit: Creates a Dictionary from a given sequence grouped by a given key path.
    ///
    /// - Parameters:
    ///   - sequence: Sequence being grouped.
    ///   - keyPath: The key path to group by.
    public static func re<S>(_ sequence: S, groupBy keyPath: KeyPath<S.Element, Key>) -> [Key : Value] where Value == [S.Element], S : Sequence
}
```

### Double

```
import CoreGraphics
import Darwin

public extension Reer where Base == Double {

    /// ReerKit: Int.
    public var int: Int { get }

    /// ReerKit: Float.
    public var float: Float { get }

    /// ReerKit: CGFloat.
    public var cgFloat: CGFloat { get }
}

public extension Reer where Base == Double {

    /// ReerKit: Normalizes a Double value from an input range to an output range.
    ///
    /// - Parameters:
    ///   - inputRange: The range of the input value. This is the original range of the value.
    ///   - outputRange: The desired range for the output value. Defaults to 0...1 if not specified.
    /// - Returns: The normalized value within the output range.
    public func normalized(from inputRange: ClosedRange<Double>, to outputRange: ClosedRange<Double> = 0...1) -> Double
}
precedencegroup PowerPrecedence {
    higherThan: MultiplicationPrecedence
}
infix operator ** : PowerPrecedence

extension Double {

    /// ReerKit: Value of exponentiation.
    ///
    /// - Parameters:
    ///   - lhs: base double.
    ///   - rhs: exponent double.
    /// - Returns: exponentiation result (example: 4.4 ** 0.5 = 2.0976176963).
    public static func ** (lhs: Double, rhs: Double) -> Double
}
```

### Float

```
import CoreGraphics
import Darwin

public extension Reer where Base == Float {

    /// ReerKit: Int.
    public var int: Int { get }

    /// ReerKit: Double.
    public var double: Double { get }

    /// ReerKit: CGFloat.
    public var cgFloat: CGFloat { get }
}
precedencegroup PowerPrecedence {
    higherThan: MultiplicationPrecedence
}
infix operator ** : PowerPrecedence

extension Float {

    /// ReerKit: Value of exponentiation.
    ///
    /// - Parameters:
    ///   - lhs: base float.
    ///   - rhs: exponent float.
    /// - Returns: exponentiation result (4.4 ** 0.5 = 2.0976176963).
    public static func ** (lhs: Float, rhs: Float) -> Float
}
```

### FloatingPoint

```
import Foundation

public extension Reer where Base: FloatingPoint {

    /// ReerKit: Absolute value of number.
    public var abs: Base { get }

    /// ReerKit: Check if number is positive.
    public var isPositive: Bool { get }

    /// ReerKit: Check if number is negative.
    public var isNegative: Bool { get }

    /// ReerKit: Ceil of number.
    public var ceil: Base { get }

    /// ReerKit: Radian value of degree input.
    public var degreesToRadians: Base { get }

    /// ReerKit: Floor of number.
    public var floor: Base { get }

    /// ReerKit: Degree value of radian input.
    public var radiansToDegrees: Base { get }
}
infix operator ± : DefaultPrecedence

extension FloatingPoint {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    /// - Parameters:
    ///   - lhs: number.
    ///   - rhs: number.
    /// - Returns: tuple of plus-minus operation ( 2.5 ± 1.5 -> (4, 1)).
    public static func ± (lhs: Self, rhs: Self) -> (Self, Self)
}
prefix operator ±

extension FloatingPoint {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    /// - Parameter number: number.
    /// - Returns: tuple of plus-minus operation (± 2.5 -> (2.5, -2.5)).
    public prefix static func ± (number: Self) -> (Self, Self)
}
prefix operator √

extension FloatingPoint {

    /// ReerKit: Square root of float.
    ///
    /// - Parameter float: float value to find square root for.
    /// - Returns: square root of given float.
    public prefix static func √ (float: Self) -> Self
}
```

### Int

```
import CoreGraphics
import Darwin

public extension Reer where Base == Int {

    /// ReerKit: Bool
    public var bool: Bool { get }

    /// ReerKit: Radian value of degree input.
    public var degreesToRadians: Double { get }

    /// ReerKit: Degree value of radian input
    public var radiansToDegrees: Double { get }

    /// ReerKit: UInt.
    public var uInt: UInt { get }

    /// ReerKit: Double.
    public var double: Double { get }

    /// ReerKit: Float.
    public var float: Float { get }

    /// ReerKit: CGFloat.
    public var cgFloat: CGFloat { get }

    /// ReerKit: String formatted for values over ±1000 (example: 1k, -2k, 100k, 1m, -5m..)
    public var metricFormatted: String { get }

    /// ReerKit: Array of digits of integer value.
    public var digits: [Int] { get }

    /// ReerKit: Number of digits of integer value.
    public var digitsCount: Int { get }
}

public extension Reer where Base == Int {

    /// ReerKit: check if given integer prime or not.
    /// Warning: Using big numbers can be computationally expensive!
    /// - Returns: true or false depending on prime-ness
    public func isPrime() -> Bool

    /// ReerKit: Roman numeral string from integer (if applicable).
    ///
    ///     10.romanNumeral() -> "X"
    ///
    /// - Returns: The roman numeral string.
    public func romanNumeral() -> String?
}
precedencegroup PowerPrecedence {
    higherThan: MultiplicationPrecedence
}
infix operator ** : PowerPrecedence

extension Int {

    /// ReerKit: Value of exponentiation.
    ///
    /// - Parameters:
    ///   - lhs: base integer.
    ///   - rhs: exponent integer.
    /// - Returns: exponentiation result (example: 2 ** 3 = 8).
    public static func ** (lhs: Int, rhs: Int) -> Double
}
prefix operator √

extension Int {

    /// ReerKit: Square root of integer.
    ///
    /// - Parameter int: integer value to find square root for
    /// - Returns: square root of given integer.
    public prefix static func √ (int: Int) -> Double
}
infix operator ± : DefaultPrecedence

extension Int {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    ///     2 ± 3 -> (5, -1)
    /// - Parameters:
    ///   - lhs: integer number.
    ///   - rhs: integer number.
    /// - Returns: Tuple of plus-minus operation
    public static func ± (lhs: Int, rhs: Int) -> (Int, Int)
}
prefix operator ±

extension Int {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    /// - Parameter int: integer number
    /// - Returns: Tuple of plus-minus operation (example: ± 2 -> (2, -2)).
    ///            The first value must be positive, the second is negative, or both is zero.
    public prefix static func ± (int: Int) -> (Int, Int)
}
```

### MutableCollection

```
public extension ReerForMutableCollection where Base: MutableCollection & RandomAccessCollection {

    /// ReerKit: Sort the collection based on a keypath and a compare function.
    ///
    /// - Parameter keyPath: Key path to sort by. The key path type must be Comparable.
    /// - Parameter compare: Comparation function that will determine the ordering.
    public mutating func sort<T>(by keyPath: KeyPath<Base.Element, T>, with compare: (T, T) -> Bool)

    /// ReerKit: Sort the collection based on a keypath.
    ///
    /// - Parameter keyPath: Key path to sort by. The key path type must be Comparable.
    public mutating func sort<T>(by keyPath: KeyPath<Base.Element, T>) where T : Comparable

    /// ReerKit: Sort the collection based on two key paths. The second one will be used in case the values of the first one match.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    public mutating func sort<T, U>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>) where T : Comparable, U : Comparable

    /// ReerKit: Sort the collection based on three key paths. Whenever the values of one key path match, the next one will be used.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    ///     - keyPath3: Key path to sort by in case the values of `keyPath1` and `keyPath2` match. Must be Comparable.
    public mutating func sort<T, U, V>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>, and keyPath3: KeyPath<Base.Element, V>) where T : Comparable, U : Comparable, V : Comparable
}

public extension ReerForMutableCollection where Base: MutableCollection {

    /// ReerKit: Assign a given value to a field `keyPath` of all elements in the collection.
    ///
    /// - Parameters:
    ///   - value: The new value of the field.
    ///   - keyPath: The actual field of the element.
    public mutating func assignToAll<Value>(value: Value, by keyPath: WritableKeyPath<Base.Element, Value>)
}
```

### Optional

```
import CoreGraphics

extension Optional : ReerGenericCompatible {

    public typealias T = Wrapped
}

public extension ReerGeneric where Base == Optional<T> {

    /// ReerKit: Contains a nil value.
    public var isNil: Bool { get }

    /// ReerKit: Contains a valid value.
    public var isNotNil: Bool { get }

    /// ReerKit: Contains a nil value.
    public var isNone: Bool { get }

    /// ReerKit: Contains a valid value.
    public var isSome: Bool { get }
}

public extension ReerGeneric where Base == Optional<T> {

    /// ReerKit: Get the optional wrapped value or the passed default value if it is nil.
    ///
    ///        let foo: String? = nil
    ///        print(foo.re.value(default: "bar")) -> "bar"
    ///
    ///        let bar: String? = "bar"
    ///        print(bar.re.value(default: "foo")) -> "bar"
    ///
    /// - Parameter defaultValue: default value to return if self is nil.
    /// - Returns: self if not nil or default value if nil.
    public func value(or defaultValue: @autoclosure () -> T) -> T

    /// ReerKit: Gets the wrapped value of an optional. If the optional is `nil`, throw a custom error.
    ///
    ///        let foo: String? = nil
    ///        try print(foo.re.value(throw: MyError.notFound)) -> error: MyError.notFound
    ///
    ///        let bar: String? = "bar"
    ///        try print(bar.re.value(throw: MyError.notFound)) -> "bar"
    ///
    /// - Parameter error: The error to throw if the optional is `nil`.
    /// - Throws: The error passed in.
    /// - Returns: The value wrapped by the optional.
    public func value(throw error: Error) throws -> T

    /// ReerKit: Runs a closure to Wrapped if not nil.
    ///
    ///        let foo: String? = nil
    ///        foo.re.run { unwrappedFoo in
    ///            // block will never run since foo is nil
    ///            print(unwrappedFoo)
    ///        }
    ///
    ///        let bar: String? = "bar"
    ///        bar.re.run { unwrappedBar in
    ///            // block will run since bar is not nil
    ///            print(unwrappedBar) -> "bar"
    ///        }
    ///
    /// - Parameter action: a block to run if self is not nil.
    public func run<U>(_ action: (T) throws -> U?) rethrows -> U?
}

public extension ReerGeneric where Base == Optional<T> {

    /// ReerKit: Transform the optional wrapped value to `Bool` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.bool -> Optional(true)
    public var bool: Bool? { get }

    /// ReerKit: Transform the optional wrapped value to `Bool` if possible.
    /// Return `false` if failed.
    public var boolValue: Bool { get }

    /// ReerKit: Transform the optional wrapped value to `Bool` if possible.
    /// Return the passed default value if it is nil.
    public func boolValue(or defaultValue: @autoclosure () -> Bool) -> Bool

    /// ReerKit: Transform the optional wrapped value to `Int` if possible.
    ///
    ///     let a: Any? = "23"
    ///     a.re.int -> Optional(23)
    public var int: Int? { get }

    /// ReerKit: Transform the optional wrapped value to `Int` if possible.
    /// Return `0` if failed.
    public var intValue: Int { get }

    /// ReerKit: Transform the optional wrapped value to `Int` if possible.
    /// Return the passed default value if it is nil.
    public func intValue(or defaultValue: @autoclosure () -> Int) -> Int

    /// ReerKit: Transform the optional wrapped value to `String` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.string -> Optional("23")
    public var string: String? { get }

    /// ReerKit: Transform the optional wrapped value to `String` if possible.
    /// Return `""` if failed.
    public var stringValue: String { get }

    /// ReerKit: Transform the optional wrapped value to `String` if possible.
    /// Return the passed default value if it is nil.
    public func stringValue(or defaultValue: @autoclosure () -> String) -> String

    /// ReerKit: Transform the optional wrapped value to `Double` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.double -> Optional(23.0)
    public var double: Double? { get }

    /// ReerKit: Transform the optional wrapped value to `Double` if possible.
    /// Return `0` if failed.
    public var doubleValue: Double { get }

    /// ReerKit: Transform the optional wrapped value to `Double` if possible.
    /// Return the passed default value if it is nil.
    public func doubleValue(or defaultValue: @autoclosure () -> Double) -> Double

    /// ReerKit: Transform the optional wrapped value to `Float` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.float -> Optional(23.0)
    public var float: Float? { get }

    /// ReerKit: Transform the optional wrapped value to `Float` if possible.
    /// Return `0` if failed.
    public var floatValue: Float { get }

    /// ReerKit: Transform the optional wrapped value to `Float` if possible.
    /// Return the passed default value if it is nil.
    public func floatValue(or defaultValue: @autoclosure () -> Float) -> Float

    /// ReerKit: Transform the optional wrapped value to `CGFloat` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.cgFloat -> Optional(23.0)
    public var cgFloat: CGFloat? { get }

    /// ReerKit: Transform the optional wrapped value to `CGFloat` if possible.
    /// Return `0` if failed.
    public var cgFloatValue: CGFloat { get }

    /// ReerKit: Transform the optional wrapped value to `CGFloat` if possible.
    /// Return the passed default value if it is nil.
    public func cgFloatValue(or defaultValue: @autoclosure () -> CGFloat) -> CGFloat

    /// ReerKit: Transform the optional wrapped value to `Dictionay<AnyHashable, Any>` if possible.
    ///
    ///     let a: Any? = ["s": 123]
    ///     a.re.anyDict -> Optional(["s": 123])
    public var anyDict: [AnyHashable : Any]? { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<AnyHashable, Any>` if possible.
    /// Return `[:]` if failed.
    public var anyDictValue: [AnyHashable : Any] { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<String, Any>` if possible.
    ///
    ///     let a: Any? = ["s": 123]
    ///     a.re.anyDict -> Optional(["s": 123])
    public var stringAnyDict: [String : Any]? { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<String, Any>` if possible.
    /// Return `[:]` if failed.
    public var stringAnyDictValue: [String : Any] { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<AnyHashable, Any>` if possible.
    /// Return the passed default value if it is nil.
    public func dictValue<Key, Value>(or defaultValue: @autoclosure () -> [Key : Value]) -> [Key : Value] where Key : Hashable

    /// ReerKit: Transform the optional wrapped value to `Array<Any>` if possible.
    ///
    ///     let a: Any? = [123]
    ///     a.re.anyArray -> Optional([123])
    public var anyArray: [Any]? { get }

    /// ReerKit: Transform the optional wrapped value to `Array<Any>` if possible.
    /// Return `[]` if failed.
    public var anyArrayValue: [Any] { get }

    /// ReerKit: Transform the optional wrapped value to `Array<Any>` if possible.
    /// Return the passed default value if it is nil.
    public func arrayValue<E>(or defaultValue: @autoclosure () -> [E]) -> [E]
}

public extension ReerGeneric where Base == Optional<T>, T: Collection {

    /// ReerKit: Check if optional is nil or empty collection.
    ///
    ///     let foo: String? = ""
    ///     print(foo.re.isEmpty) -> true
    public var isEmpty: Bool { get }
}

/// Make any type to an optional value.
postfix operator ~!
public postfix func ~! <T>(value: T) -> T?
prefix operator !

/// Make `Bool?` to a oppsite value if it is not nil.
public extension Optional where Wrapped == Bool {

    prefix public static func ! (value: Bool?) -> Bool?
}
infix operator ?! : NilCoalescingPrecedence

public extension Optional where Wrapped : Collection {

    /// ReerKit: Return the default value when the optional is nil, or it's not nil, but the collection is empty.
    ///
    ///     let value: String? = ""
    ///     let result = value ?! "abc"
    ///     // result is "abc"
    ///     
    /// - Returns: A non empty value.
    public static func ?! (optionalValue: Optional<Wrapped>, defaultValue: @autoclosure () -> Wrapped) -> Wrapped
}
```

### OptionSet

```
public extension ReerForOptionSet where Base: OptionSet, Base.RawValue: FixedWidthInteger {

    /// ReerKit: Return a sequence of OptionSet
    ///
    /// - Returns: a sequence of OptionSet
    public func elements() -> AnySequence<Base>
}
```

### Range

```
import Foundation

extension Range : ReerGenericCompatible {

    public typealias T = Bound
}

public extension ReerGeneric where Base == Range<T>, T: FixedWidthInteger {

    /// ReerKit: Get NSRange from Range<FixedWidthInteger>
    public var nsRange: NSRange { get }
}
```

### RangeReplaceableCollection

```
public extension ReerForRangeReplaceableCollection where Base: RangeReplaceableCollection {

    /// ReerKit: Removes the first element of the collection which satisfies the given predicate.
    ///
    ///        [1, 2, 2, 3, 4, 2, 5].re.removeFirst { $0 % 2 == 0 } -> [1, 2, 3, 4, 2, 5]
    ///        ["h", "e", "l", "l", "o"].re.removeFirst { $0 == "e" } -> ["h", "l", "l", "o"]
    ///
    /// - Parameter predicate: A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.
    /// - Returns: The first element for which predicate returns true, after removing it. If no elements in the collection satisfy the given predicate, returns `nil`.
    @discardableResult
    public mutating func removeFirst(where predicate: (Base.Element) throws -> Bool) rethrows -> Base.Element?

    /// ReerKit: Remove a random value from the collection.
    @discardableResult
    public mutating func removeRandomElement() -> Base.Element?

    /// ReerKit: Keep elements of Array while condition is true.
    ///
    ///        [0, 2, 4, 7].re.keep(while: { $0 % 2 == 0 }) -> [0, 2, 4]
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: self after applying provided condition.
    /// - Throws: provided condition exception.
    @discardableResult
    public mutating func keep(while condition: (Base.Element) throws -> Bool) rethrows -> <<error type>>

    /// ReerKit: Remove all duplicate elements using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Equatable.
    public mutating func removeDuplicates<E>(keyPath path: KeyPath<Base.Element, E>) where E : Equatable

    /// ReerKit: Remove all duplicate elements using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Hashable.
    public mutating func removeDuplicates<E>(keyPath path: KeyPath<Base.Element, E>) where E : Hashable

    /// ReerKit: Safely accesses the element at the specified position.
    /// The collection should be a `var`, NOT work for `let`
    /// 
    ///     var string = "012345"
    ///     string.re[0] -> Optional(Character("0"))
    ///     string.re[5] -> Optional(Character("5"))
    ///     string.re[6] -> nil
    ///     string.re[-1] -> nil
    ///
    ///     string = "012345"
    ///     string.re[0] = "a"
    ///     // string == "a12345"
    ///
    ///     string = "012345"
    ///     string.re[0] = nil
    ///     // string == "12345"
    ///
    ///     string = "012345"
    ///     string.re[7] = "a"
    ///     // string == "012345"
    ///
    ///  ----------------------------------------------
    ///
    ///     var array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0] -> Optional(0)
    ///     array.re[5] -> Optional(5)
    ///     array.re[6] -> nil
    ///     array.re[-1] -> nil
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0] = 9
    ///     // array == [9, 1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0] = nil
    ///     array == [1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[7] = 9
    ///     // array == [0, 1, 2, 3, 4, 5]
    ///
    ///
    /// - Parameter offset: The offset position of the element to access.
    public subscript(offset: Int) -> Base.Element? { get set }

    /// ReerKit: Safely accesses a contiguous subrange of the collection’s elements.
    /// The collection should be a `var`, NOT work for `let`
    ///
    ///     var string = "012345"
    ///     string.re[1..<3] -> Optional("12")
    ///     string.re[..<3] -> Optional("012")
    ///     string.re[-2..<3] -> Optional("012")
    ///     string.re[3..<10] -> Optional("345")
    ///     string.re[3...] -> Optional("345")
    ///     string.re[7...] -> nil
    ///     string.re[-10..<(-1)] -> nil
    ///
    ///     string = "012345"
    ///     string.re[0..<1] = "a"
    ///     // string == "a12345"
    ///
    ///     string = "012345"
    ///     string.re[0..<1] = nil
    ///     // string == "12345"
    ///
    ///     string = "012345"
    ///     string.re[0..<1] = ""
    ///     // string == "12345"
    ///
    ///     string = "012345"
    ///     string.re[7...] = "a"
    ///     // string == "012345"
    ///
    ///     string = "012345"
    ///     string.re[0...5] = "a"
    ///     // string == "a"
    ///
    ///     string = "012345"
    ///     string.re[-1...6] = nil
    ///     // string == ""
    ///
    ///  -------------------------------------
    ///
    ///     var array = [0, 1, 2, 3, 4, 5]
    ///     array.re[1..<3] -> Optional([1, 2])
    ///     array.re[..<3] -> Optional([0, 1, 2])
    ///     array.re[-2..<3] -> Optional([0, 1, 2])
    ///     array.re[3..<10] -> Optional([3, 4, 5])
    ///     array.re[3...] -> Optional([3, 4, 5])
    ///     array.re[7...] -> nil
    ///     array.re[-10..<(-1)] -> nil
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0..<1] = [9]
    ///     // array == [9, 1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0..<1] = nil
    ///     // array == [1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0..<1] = []
    ///     // array == [1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[7...] = [9]
    ///     // array == [0, 1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0...5] = [9]
    ///     // array == [9]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0...5] = []
    ///     // array == []
    ///
    /// - Parameter range: A range of the collection’s indices offsets.
    public subscript<R>(range: R) -> Base? where R : RangeExpression, R.Bound == Int { get set }

    /// ReerKit: Adds a new element at the end of the array, mutates the array in place
    ///
    /// - Parameter newElement: The optional element to append to the array
    public mutating func appendIfNonNil(_ newElement: Base.Element?)

    /// ReerKit: Adds the elements of a sequence to the end of the array, mutates the array in place
    ///
    /// - Parameter newElements: The optional sequence to append to the array
    public mutating func appendIfNonNil<S>(contentsOf newElements: S?) where S : Sequence, S.Element == <<error type>>
}

public extension RangeReplaceableCollection {

    /// ReerKit: Creates a new collection of a given size where for each position of the collection the value will be the result of a call of the given expression.
    ///
    ///     let values = Array.re(expression: "Value", count: 3)
    ///     print(values)
    ///     // Prints "["Value", "Value", "Value"]"
    ///
    /// - Parameters:
    ///   - expression: The expression to execute for each position of the collection.
    ///   - count: The count of the collection.
    public static func re(expression: @autoclosure () throws -> Self.Element, count: Int) rethrows -> Self
}
```

### Sequence

```
public extension Reer where Base: Sequence {

    /// ReerKit: Check if all elements in collection match a condition.
    ///
    ///     [2, 2, 4].re.all(matching: { $0 % 2 == 0 }) -> true
    ///     [1,2, 2, 4].re.all(matching: { $0 % 2 == 0 }) -> false
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: true when all elements in the array match the specified condition.
    public func all(matching condition: (Base.Element) throws -> Bool) rethrows -> Bool

    /// ReerKit: Check if no elements in collection match a condition.
    ///
    ///     [2, 2, 4].re.none(matching: { $0 % 2 == 0 }) -> false
    ///     [1, 3, 5, 7].re.none(matching: { $0 % 2 == 0 }) -> true
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: true when no elements in the array match the specified condition.
    public func none(matching condition: (Base.Element) throws -> Bool) rethrows -> Bool

    /// ReerKit: Check if any element in collection match a condition.
    ///
    ///     [1, 2, 5].re.any(matching: { $0 % 2 == 0 }) -> true
    ///     [1, 3, 5, 7].re.any(matching: { $0 % 2 == 0 }) -> false
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: true when no elements in the array match the specified condition.
    public func any(matching condition: (Base.Element) throws -> Bool) rethrows -> Bool

    /// ReerKit: Filter elements based on a rejection condition.
    ///
    ///     [2, 2, 4, 7].re.reject(where: { $0 % 2 == 0 }) -> [7]
    ///
    /// - Parameter condition: to evaluate the exclusion of an element from the array.
    /// - Returns: the array with rejected values filtered from it.
    public func reject(where condition: (Base.Element) throws -> Bool) rethrows -> [Base.Element]

    /// ReerKit: Get element count based on condition.
    ///
    ///     [2, 2, 4, 7].re.count(where: { $0 % 2 == 0 }) -> 3
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: number of times the condition evaluated to true.
    public func count(where condition: (Base.Element) throws -> Bool) rethrows -> Int

    /// ReerKit: Iterate over a collection in reverse order. (right to left)
    ///
    ///     [0, 2, 4, 7].re.reversedForEach({ print($0) }) -> // Order of print: 7,4,2,0
    ///
    /// - Parameter body: a closure that takes an element of the array as a parameter.
    public func reversedForEach(_ body: (Base.Element) throws -> Void) rethrows

    /// ReerKit: Calls the given closure with each element where condition is true.
    ///
    ///     [0, 2, 4, 7].re.forEach({ print($0) }, where: { $0 % 2 == 0 }) -> // print: 0, 2, 4
    ///
    /// - Parameters:
    ///   - body: a closure that takes an element of the array as a parameter.
    ///   - condition: condition to evaluate each element against.
    public func forEach(_ body: (Base.Element) throws -> Void, where condition: (Base.Element) throws -> Bool) rethrows

    /// ReerKit: Filtered and map in a single operation.
    ///
    ///     [1, 2, 3, 4, 5].re.map({ $0.re.string }, where: { $0 % 2 == 0 }) -> ["2", "4"]
    ///
    /// - Parameters:
    ///   - transform: transform element function to evaluate every element.
    ///   - condition: filter condition
    /// - Returns: Return an filtered and mapped array.
    public func map<T>(_ transform: (Base.Element) throws -> T, where condition: (Base.Element) throws -> Bool) rethrows -> [T]

    /// ReerKit: Separates all items into 2 lists based on a given predicate. The first list contains all items for which the specified condition evaluates to true.
    /// The second list contains those that don't.
    ///
    ///     let (even, odd) = [0, 1, 2, 3, 4, 5].re.divided { $0 % 2 == 0 }
    ///     let (minors, adults) = people.re.divided { $0.age < 18 }
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: A tuple of matched and non-matched items
    public func divided(by condition: (Base.Element) throws -> Bool) rethrows -> (matching: [Base.Element], nonMatching: [Base.Element])

    /// ReerKit: Return a sorted array based on a key path and a compare function.
    ///
    ///     ["James", "Wade", "Bryant"].re.sorted(by: \String.count, with: <) -> ["Wade", "James", "Bryant"]
    ///
    /// - Parameter keyPath: Key path to sort by.
    /// - Parameter compare: Comparation function that will determine the ordering.
    /// - Returns: The sorted array.
    public func sorted<T>(by keyPath: KeyPath<Base.Element, T>, with compare: (T, T) -> Bool) -> [Base.Element]

    /// ReerKit: Return a sorted array based on a key path.
    ///
    /// - Parameter keyPath: Key path to sort by. The key path type must be Comparable.
    /// - Returns: The sorted array.
    public func sorted<T>(by keyPath: KeyPath<Base.Element, T>) -> [Base.Element] where T : Comparable

    /// ReerKit: Returns a sorted sequence based on two key paths. The second one will be used in case the values of the first one match.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    public func sorted<T, U>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>) -> [Base.Element] where T : Comparable, U : Comparable

    /// ReerKit: Returns a sorted sequence based on three key paths. Whenever the values of one key path match, the next one will be used.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    ///     - keyPath3: Key path to sort by in case the values of `keyPath1` and `keyPath2` match. Must be Comparable.
    public func sorted<T, U, V>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>, and keyPath3: KeyPath<Base.Element, V>) -> [Base.Element] where T : Comparable, U : Comparable, V : Comparable

    /// ReerKit: Sum of a `AdditiveArithmetic` property of each `Element` in a `Sequence`.
    ///
    ///     ["James", "Wade", "Bryant"].re.sum(for: \.count) -> 15
    ///
    /// - Parameter keyPath: Key path of the `AdditiveArithmetic` property.
    /// - Returns: The sum of the `AdditiveArithmetic` properties at `keyPath`.
    public func sum<T>(for keyPath: KeyPath<Base.Element, T>) -> T where T : AdditiveArithmetic

    /// ReerKit: Get last element that satisfies a conditon.
    ///
    ///     [2, 2, 4, 7].re.last(where: { $0 % 2 == 0 }) -> 4
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: the last element in the array matching the specified condition. (optional)
    public func last(where condition: (Base.Element) throws -> Bool) rethrows -> Base.Element?
}

public extension Reer where Base: Sequence, Base.Element: Hashable {

    /// ReerKit: Check if array contains an array of elements.
    ///
    ///     [1, 2, 3, 4, 5].re.contains([1, 2]) -> true
    ///     [1.2, 2.3, 4.5, 3.4, 4.5].re.contains([2, 6]) -> false
    ///     ["h", "e", "l", "l", "o"].re.contains(["l", "o"]) -> true
    ///
    /// - Parameter elements: array of elements to check.
    /// - Returns: true if array contains all given items.
    /// - Complexity: _O(m + n)_, where _m_ is the length of `elements` and _n_ is the length of this sequence.
    public func contains(_ elements: [Base.Element]) -> Bool

    /// ReerKit: Check whether a sequence contains duplicates.
    ///
    /// - Returns: true if the receiver contains duplicates.
    public func containsDuplicates() -> Bool

    /// ReerKit: Getting the duplicated elements in a sequence.
    ///
    ///     [1, 1, 2, 2, 3, 3, 3, 4, 5].re.duplicates().sorted() -> [1, 2, 3])
    ///     ["h", "e", "l", "l", "o"].re.duplicates().sorted() -> ["l"])
    ///
    /// - Returns: An array of duplicated elements.
    ///
    public func duplicates() -> [Base.Element]

    /// ReerKit: Remove duplicate elements.
    ///
    ///     [1, 2, 1, 3, 2].re.withoutDuplicates() -> [1, 2, 3]
    ///
    /// - Returns: Sequence without repeating elements
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func withoutDuplicates() -> [Base.Element]
}

public extension Reer where Base: Sequence, Base.Element: Equatable {

    /// ReerKit: Check if array contains an array of elements.
    ///
    ///     [1, 2, 3, 4, 5].re.contains([1, 2]) -> true
    ///     [1.2, 2.3, 4.5, 3.4, 4.5].re.contains([2, 6]) -> false
    ///     ["h", "e", "l", "l", "o"].re.contains(["l", "o"]) -> true
    ///
    /// - Parameter elements: array of elements to check.
    /// - Returns: true if array contains all given items.
    /// - Complexity: _O(m·n)_, where _m_ is the length of `elements` and _n_ is the length of this sequence.
    public func contains(_ elements: [Base.Element]) -> Bool
}

public extension Reer where Base: Sequence, Base.Element: AdditiveArithmetic {

    /// ReerKit: Sum of all elements in array.
    ///
    ///        [1, 2, 3, 4, 5].re.sum() -> 15
    ///
    /// - Returns: sum of the array's elements.
    public func sum() -> Base.Element
}
```

### Set

```
extension Set : ReerReferenceGenericCompatible {

    public typealias T = Element
}

public extension ReerReferenceGeneric where Base == Set<T> {

    /// ReerKit: Toggle the presence of an element in the set
    ///
    /// - Parameter element: The element to toggle
    /// - Returns: True if the element was inserted, false if it was removed
    @discardableResult
    public mutating func toggle(_ element: T) -> Bool
}
```

### SignedInteger

```
import Foundation

public extension Reer where Base: SignedInteger {

    /// ReerKit: Absolute value of integer number.
    public var abs: Base { get }

    /// ReerKit: Check if integer is positive.
    public var isPositive: Bool { get }

    /// ReerKit: Check if integer is negative.
    public var isNegative: Bool { get }

    /// ReerKit: Check if integer is even.
    public var isEven: Bool { get }

    /// ReerKit: Check if integer is odd.
    public var isOdd: Bool { get }

    /// ReerKit: String of format (XXh XXm) from seconds Int.
    public var timeString: String { get }
}

public extension Reer where Base: SignedInteger {

    /// ReerKit: Greatest common divisor of integer value and n.
    ///
    /// - Parameter n: integer value to find gcd with.
    /// - Returns: greatest common divisor of self and n.
    public func gcd(with n: Base) -> Base

    /// ReerKit: Least common multiple of integer and n.
    ///
    /// - Parameter n: integer value to find lcm with.
    /// - Returns: least common multiple of self and n.
    public func lcm(with n: Base) -> Base

    /// ReerKit: Ordinal representation of an integer.
    ///
    ///        print((12).ordinalString()) // prints "12th"
    ///
    /// - Parameter locale: locale, default is .current.
    /// - Returns: string ordinal representation of number in specified locale language. E.g. input 92, output in "en": "92nd".
    public func ordinalString(locale: Locale = .current) -> String?
}
```

### SignedNumeric

```
import Foundation

public extension Reer where Base: SignedNumeric {

    /// ReerKit: String.
    public var string: String { get }
}

public extension Reer where Base: SignedNumeric {

    /// ReerKit: String with number and current locale currency.
    public func localeCurrency(_ locale: Locale = .current) -> String?

    /// ReerKit: Spelled out representation of a number.
    ///
    ///        print((12.32).spelledOutString()) // prints "twelve point three two"
    ///
    /// - Parameter locale: Locale, default is .current.
    /// - Returns: String representation of number spelled in specified locale language. E.g. input 92, output in "en": "ninety-two".
    public func spelledOutString(locale: Locale = .current) -> String?
}
```

### String

```
import Foundation
import UIKit
import CoreGraphics
import CommonCrypto

public extension Reer where Base == String {

    /// ReerKit: Returns an Data using UTF-8 encoding.
    public var utf8Data: Data? { get }

    /// ReerKit: String decoded from base64 (if applicable).
    ///
    ///        "SGVsbG8gV29ybGQh".re.base64Decoded = Optional("Hello World!")
    ///
    public var base64Decoded: String? { get }

    /// ReerKit: `Data` decoded from base64 (if applicable).
    public var base64DecodedData: Data? { get }

    /// ReerKit: String encoded in base64 (if applicable).
    ///
    ///        "Hello World!".re.base64Encoded -> Optional("SGVsbG8gV29ybGQh")
    ///
    public var base64Encoded: String? { get }

    /// ReerKit: Returns new string in punycode encoding (RFC 3492)
    ///
    /// - Returns: Punycode encoded string or nil if the string can't be encoded
    public var punycodeEncoded: String? { get }

    /// ReerKit: Returns new string decoded from punycode representation (RFC 3492)
    ///
    /// - Returns: Original string or nil if the string doesn't contain correct encoding
    public var punycodeDecoded: String? { get }

    /// ReerKit: Returns new string containing IDNA-encoded hostname
    ///
    /// - Returns: IDNA encoded hostname or nil if the string can't be encoded
    public var idnaEncoded: String? { get }

    /// ReerKit: Returns new string containing hostname decoded from IDNA representation
    ///
    /// - Returns: Original hostname or nil if the string doesn't contain correct encoding
    public var idnaDecoded: String? { get }

    /// ReerKit: Array of characters of a string.
    public var characters: [Character] { get }

    /// ReerKit: CamelCase of string.
    ///
    ///        "sOme vAriable naMe".re.camelCased -> "someVariableName"
    ///
    public var camelCased: String { get }

    /// ReerKit: Check if string contains one or more emojis.
    ///
    ///        "Hello 😀".re.containEmoji -> true
    ///
    public var containEmoji: Bool { get }

    /// ReerKit: Check if string contains one or more letters.
    ///
    ///        "123abc".re.hasLetters -> true
    ///        "123".re.hasLetters -> false
    ///
    public var hasLetters: Bool { get }

    /// ReerKit: Check if string contains one or more digits.
    ///
    ///        "abcd".re.hasDigits -> false
    ///        "123abc".re.hasDigits -> true
    ///
    public var hasDigits: Bool { get }

    /// ReerKit: Check if string only contains letters.
    ///
    ///     "abc".re.hasLettersOnly -> true
    ///     "123abc".re.hasLettersOnly -> false
    ///
    public var hasLettersOnly: Bool { get }

    /// ReerKit: Check if string only contains digits.
    ///
    ///     "123".re.hasDigitsOnly -> true
    ///     "1.3".re.hasDigitsOnly -> false
    ///     "abc".re.hasDigitsOnly -> false
    ///
    public var hasDigitsOnly: Bool { get }

    /// ReerKit: Check if string is palindrome.
    ///
    ///     "abcdcba".re.isPalindrome -> true
    ///     "Mom".re.isPalindrome -> true
    ///     "A man a plan a canal, Panama!".re.isPalindrome -> true
    ///     "Mama".re.isPalindrome -> false
    ///
    public var isPalindrome: Bool { get }

    /// ReerKit: Check if string is valid email format.
    ///
    /// - Note: Note that this property does not validate the email address against an email server. It merely attempts to determine whether its format is suitable     for an email address.
    ///
    ///        "john@doe.com".re.isValidEmail -> true
    ///
    public var isValidEmail: Bool { get }

    /// ReerKit: Check if string is a valid URL.
    ///
    ///        "https://google.com".re.isValidUrl -> true
    ///
    public var isValidUrl: Bool { get }

    /// ReerKit: Check if string is a valid schemed URL.
    ///
    ///        "https://google.com".re.isValidSchemedUrl -> true
    ///        "google.com".re.isValidSchemedUrl -> false
    ///
    public var isValidSchemedUrl: Bool { get }

    /// ReerKit: Check if string is a valid https URL.
    ///
    ///        "https://google.com".re.isValidHttpsUrl -> true
    ///
    public var isValidHttpsUrl: Bool { get }

    /// ReerKit: Check if string is a valid http URL.
    ///
    ///        "http://google.com".re.isValidHttpUrl -> true
    ///
    public var isValidHttpUrl: Bool { get }

    /// ReerKit: Check if string is a valid file URL.
    ///
    ///        "file://Documents/file.txt".re.isValidFileUrl -> true
    ///
    public var isValidFileUrl: Bool { get }

    /// ReerKit: Latinized string.
    ///
    ///        "Hèllö Wórld!".re.latinized -> "Hello World!"
    ///
    public var latinized: String { get }

    /// ReerKit: First character of string (if applicable).
    ///
    ///        "Hello".re.firstCharacterAsString -> Optional("H")
    ///        "".re.firstCharacterAsString -> nil
    ///
    public var firstCharacterAsString: String? { get }

    /// ReerKit: Last character of string (if applicable).
    ///
    ///        "Hello".re.lastCharacterAsString -> Optional("o")
    ///        "".re.lastCharacterAsString -> nil
    ///
    public var lastCharacterAsString: String? { get }

    /// ReerKit: Bool value from string (if applicable).
    ///
    ///        "1".re.bool -> true
    ///        "False".re.bool -> false
    ///        "Hello".re.bool = nil
    ///
    public var bool: Bool? { get }

    /// ReerKit: Integer value from string (if applicable).
    ///
    ///        "101".re.int -> 101
    ///
    public var int: Int? { get }

    /// ReerKit: Float value from string (if applicable).
    ///
    /// - Parameter locale: Locale (default is Locale.current)
    /// - Returns: Optional Float value from given string.
    public func float(locale: Locale = .current) -> Float?

    /// ReerKit: Double value from string (if applicable).
    ///
    /// - Parameter locale: Locale (default is Locale.current)
    /// - Returns: Optional Double value from given string.
    public func double(locale: Locale = .current) -> Double?

    /// ReerKit: CGFloat value from string (if applicable).
    ///
    /// - Parameter locale: Locale (default is Locale.current)
    /// - Returns: Optional CGFloat value from given string.
    public func cgFloat(locale: Locale = .current) -> CGFloat?

    /// ReerKit: Calculate height for a `String` with a constrained width.
    /// - Parameter width: A constrained of container view width.
    /// - Parameter font: The font for text.
    /// - Returns: Total height of the attributed string after rendering.
    public func height(forWidth width: CGFloat, font: UIFont) -> CGFloat

    /// ReerKit: Calculate width for a `String` with an unlimited height in one line.
    /// - Returns: Width of the string with the font after rendering.
    public func singleLineWidth(font: UIFont) -> CGFloat

    /// ReerKit: Date object from "yyyy-MM-dd" formatted string.
    ///
    ///        "2007-06-29".re.date -> Optional(Date)
    ///
    public var date: Date? { get }

    /// ReerKit: Date object from "yyyy-MM-dd HH:mm:ss" formatted string.
    ///
    ///        "2007-06-29 14:23:09".re.dateTime -> Optional(Date)
    ///
    public var dateTime: Date? { get }

    /// ReerKit: URL from string (if applicable).
    ///
    ///        "https://google.com".re.url -> URL(string: "https://google.com")
    ///        "not url".re.url -> nil
    ///
    public var url: URL? { get }

    /// ReerKit: String with no spaces or new lines in beginning and end.
    ///
    ///        "   hello  \n".re.trimmed -> "hello"
    ///
    public var trimmed: String { get }

    /// ReerKit: Readable string from a URL string.
    ///
    ///        "it's%20easy%20to%20decode%20strings".re.urlDecoded -> "it's easy to decode strings"
    ///
    public var urlDecoded: String { get }

    /// ReerKit: URL escaped string.
    ///
    ///        "it's easy to encode strings".re.urlEncoded -> "it's%20easy%20to%20encode%20strings"
    ///
    public var urlEncoded: String { get }

    /// ReerKit: Escaped string for inclusion in a regular expression pattern.
    ///
    /// "hello ^$ there" -> "hello \\^\\$ there"
    ///
    public var regexEscaped: String { get }

    /// ReerKit: String without spaces and new lines.
    ///
    ///        "   \n Swifter   \n  Swift  ".re.withoutSpacesAndNewLines -> "SwifterSwift"
    ///
    public var withoutSpacesAndNewLines: String { get }

    /// ReerKit: Check if the given string contains only white spaces.
    public var isWhitespace: Bool { get }

    /// ReerKit: Check if the given string spelled correctly.
    public var isSpelledCorrectly: Bool { get }

    /// ReerKit: Array of strings separated by new lines.
    ///
    ///        "Hello\ntest".re.lines() -> ["Hello", "test"]
    ///
    /// - Returns: Strings separated by new lines.
    public func lines() -> [String]

    /// ReerKit: Returns a localized string, with an optional comment for translators.
    ///
    ///        "Hello world".re.localized -> Hallo Welt
    ///
    public func localized(comment: String = "") -> String

    /// ReerKit: Array with unicodes for all characters in a string.
    ///
    ///        "SwifterSwift".re.unicodeArray() -> [83, 119, 105, 102, 116, 101, 114, 83, 119, 105, 102, 116]
    ///
    /// - Returns: The unicodes for all characters in a string.
    public func unicodeArray() -> [Int]

    /// ReerKit: an array of all words in a string.
    ///
    ///        "Swift is amazing".re.words() -> ["Swift", "is", "amazing"]
    ///
    /// - Returns: The words contained in a string.
    public func words() -> [String]

    /// ReerKit: Count of words in a string.
    ///
    ///        "Swift is amazing".re.wordsCount() -> 3
    ///
    /// - Returns: The count of words contained in a string.
    public func wordCount() -> Int

    /// ReerKit: Transforms the string into a slug string.
    ///
    ///        "Swift is amazing".re.toSlug() -> "swift-is-amazing"
    ///
    /// - Returns: The string in slug format.
    public func toSlug() -> String

    /// ReerKit: Safely subscript string with index.
    ///
    ///        "Hello World!".re[3] -> "l"
    ///        "Hello World!".re[20] -> nil
    ///
    /// - Parameter index: index.
    public subscript(index: Int) -> Character? { get }

    /// ReerKit: Safely subscript string within a given range.
    ///
    ///        "Hello World!".re[safe: 6..<11] -> "World"
    ///        "Hello World!".re[safe: 21..<110] -> nil
    ///
    ///        "Hello World!".re[safe: 6...11] -> "World!"
    ///        "Hello World!".re[safe: 21...110] -> nil
    ///
    /// - Parameter range: Range expression.
    public subscript<R>(range: R) -> String? where R : RangeExpression, R.Bound == Int { get }

    /// ReerKit: Copy string to global pasteboard.
    ///
    ///        "SomeText".re.copyToPasteboard() // copies "SomeText" to pasteboard
    ///
    public func copyToPasteboard()

    /// ReerKit: Check if string contains only unique characters.
    ///
    public func hasUniqueCharacters() -> Bool

    /// ReerKit: Check if string contains one or more instance of substring.
    ///
    ///        "Hello World!".re.contain("O") -> false
    ///        "Hello World!".re.contain("o", caseSensitive: false) -> true
    ///
    /// - Parameters:
    ///   - string: substring to search for.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: true if string contains one or more instance of substring.
    public func contains(_ string: String, caseSensitive: Bool = true) -> Bool

    /// ReerKit: Count of substring in string.
    ///
    ///        "Hello World!".re.count(of: "o") -> 2
    ///        "Hello World!".re.count(of: "L", caseSensitive: false) -> 3
    ///
    /// - Parameters:
    ///   - string: substring to search for.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: count of appearance of substring in string.
    public func count(of string: String, caseSensitive: Bool = true) -> Int

    /// ReerKit: Check if string starts with substring.
    ///
    ///        "hello World".re.starts(with: "h") -> true
    ///        "hello World".re.starts(with: "H", caseSensitive: false) -> true
    ///
    /// - Parameters:
    ///   - prefix: substring to search if string starts with.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: true if string starts with substring.
    public func starts(with prefix: String, caseSensitive: Bool = true) -> Bool

    /// ReerKit: Check if string ends with substring.
    ///
    ///        "Hello World!".re.ends(with: "!") -> true
    ///        "Hello World!".re.ends(with: "WoRld!", caseSensitive: false) -> true
    ///
    /// - Parameters:
    ///   - suffix: substring to search if string ends with.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: true if string ends with substring.
    public func ends(with suffix: String, caseSensitive: Bool = true) -> Bool

    /// ReerKit: Random string of given length.
    ///
    ///        String.re.random(ofLength: 18) -> "u7MMZYvGo9obcOcPj8"
    ///
    /// - Parameter length: number of characters in string.
    /// - Returns: random string of given length.
    public static func random(ofLength length: Int) -> String

    /// ReerKit: Sliced string from a start index with length.
    ///
    ///        "Hello World".re.slicing(from: 6, length: 5) -> "World"
    ///
    /// - Parameters:
    ///   - index: string index the slicing should start from.
    ///   - length: amount of characters to be sliced after given index.
    /// - Returns: sliced substring of length number of characters (if applicable) (example: "Hello World".slicing(from: 6, length: 5) -> "World").
    public func slicing(from index: Int, length: Int) -> String?

    /// ReerKit: Date object from string of date format.
    ///
    ///        "2017-01-15".re.date(withFormat: "yyyy-MM-dd") -> Date set to Jan 15, 2017
    ///        "not date string".re.date(withFormat: "yyyy-MM-dd") -> nil
    ///
    /// - Parameter format: date format.
    /// - Returns: Date object from string (if applicable).
    public func date(withFormat format: String) -> Date?

    /// ReerKit: Truncated string (limited to a given number of characters).
    ///
    ///        "This is a very long sentence".re.truncated(toLength: 14) -> "This is a very..."
    ///        "Short sentence".re.truncated(toLength: 14) -> "Short sentence"
    ///
    /// - Parameters:
    ///   - length: maximum number of characters before cutting.
    ///   - trailing: string to add at the end of truncated string.
    /// - Returns: truncated string (this is an extr...).
    public func truncated(toLength length: Int, trailing: String? = "...") -> String

    /// ReerKit: Verify if string matches the regex pattern.
    ///
    /// - Parameter pattern: Pattern to verify.
    /// - Returns: `true` if string matches the pattern.
    public func matches(pattern: String) -> Bool

    /// ReerKit: Verify if string matches the regex.
    ///
    /// - Parameters:
    ///   - regex: Regex to verify.
    ///   - options: The matching options to use.
    /// - Returns: `true` if string matches the regex.
    public func matches(regex: NSRegularExpression, options: NSRegularExpression.MatchingOptions = []) -> Bool

    /// ReerKit: Returns a new string in which all occurrences of a regex in a specified range of the receiver are replaced by the template.
    /// - Parameters:
    ///   - regex: Regex to replace.
    ///   - template: The template to replace the regex.
    ///   - options: The matching options to use
    ///   - searchRange: The range in the receiver in which to search.
    /// - Returns: A new string in which all occurrences of regex in searchRange of the receiver are replaced by template.
    public func replacingOccurrences(of regex: NSRegularExpression, with template: String, options: NSRegularExpression.MatchingOptions = [], range searchRange: Range<String.Index>? = nil) -> String

    /// ReerKit: Returns a string by padding to fit the length parameter size with another string in the start.
    ///
    ///     "hue".re.paddingStart(10) -> "       hue"
    ///     "hue".re.paddingStart(10, with: "br") -> "brbrbrbhue"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    /// - Returns: The string with the padding on the start.
    public func paddingStart(_ length: Int, with string: String = " ") -> String

    /// ReerKit: Returns a string by padding to fit the length parameter size with another string in the end.
    ///
    ///     "hue".re.paddingEnd(10) -> "hue       "
    ///     "hue".re.paddingEnd(10, with: "br") -> "huebrbrbrb"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    /// - Returns: The string with the padding on the end.
    public func paddingEnd(_ length: Int, with string: String = " ") -> String

    /// ReerKit: Removes given prefix from the string.
    ///
    ///     "Hello, World!".re.removingPrefix("Hello, ") -> "World!"
    ///
    /// - Parameter prefix: Prefix to remove from the string.
    /// - Returns: The string after prefix removing.
    public func removingPrefix(_ prefix: String) -> String

    /// ReerKit: Removes given suffix from the string.
    ///
    ///     "Hello, World!".re.removingSuffix(", World!") -> "Hello"
    ///
    /// - Parameter suffix: Suffix to remove from the string.
    /// - Returns: The string after suffix removing.
    public func removingSuffix(_ suffix: String) -> String

    /// ReerKit: Adds prefix to the string.
    ///
    ///     "www.apple.com".re.withPrefix("https://") -> "https://www.apple.com"
    ///
    /// - Parameter prefix: Prefix to add to the string.
    /// - Returns: The string with the prefix prepended.
    public func withPrefix(_ prefix: String) -> String
}

extension String: ReerReferenceCompatible {}
public extension ReerReference where Base == String {

    /// ReerKit: Converts string format to CamelCase.
    ///
    ///        var str = "sOme vaRiabLe Name"
    ///        str.re.camelize()
    ///        print(str) // prints "someVariableName"
    ///
    @discardableResult
    public mutating func camelize() -> String

    /// ReerKit: First character of string uppercased(if applicable) while keeping the original string.
    ///
    ///        "hello world".re.firstCharacterUppercased() -> "Hello world"
    ///        "".re.firstCharacterUppercased() -> ""
    ///
    public mutating func firstCharacterUppercased()

    /// ReerKit: Latinize string.
    ///
    ///        var str = "Hèllö Wórld!"
    ///        str.re.latinize()
    ///        print(str) // prints "Hello World!"
    ///
    @discardableResult
    public mutating func latinize() -> String

    /// ReerKit: Reverse string.
    @discardableResult
    public mutating func reverse() -> String

    /// ReerKit: Slice given string from a start index with length (if applicable).
    ///
    ///        var str = "Hello World"
    ///        str.re.slice(from: 6, length: 5)
    ///        print(str) // prints "World"
    ///
    /// - Parameters:
    ///   - index: string index the slicing should start from.
    ///   - length: amount of characters to be sliced after given index.
    @discardableResult
    public mutating func slice(from index: Int, length: Int) -> String

    /// ReerKit: Slice given string from a start index to an end index (if applicable).
    ///
    ///        var str = "Hello World"
    ///        str.re.slice(from: 6, to: 11)
    ///        print(str) // prints "World"
    ///
    /// - Parameters:
    ///   - start: string index the slicing should start from.
    ///   - end: string index the slicing should end at.
    @discardableResult
    public mutating func slice(from start: Int, to end: Int) -> String

    /// ReerKit: Slice given string from a start index (if applicable).
    ///
    ///        var str = "Hello World"
    ///        str.re.slice(at: 6)
    ///        print(str) // prints "World"
    ///
    /// - Parameter index: string index the slicing should start from.
    @discardableResult
    public mutating func slice(at index: Int) -> String

    /// ReerKit: Removes spaces and new lines in beginning and end of string.
    ///
    ///        var str = "  \n Hello World \n\n\n"
    ///        str.re.trim()
    ///        print(str) // prints "Hello World"
    ///
    @discardableResult
    public mutating func trim() -> String

    /// ReerKit: Truncate string (cut it to a given number of characters).
    ///
    ///        var str = "This is a very long sentence"
    ///        str.re.truncate(toLength: 14)
    ///        print(str) // prints "This is a very..."
    ///
    /// - Parameters:
    ///   - length: maximum number of characters before cutting.
    ///   - trailing: string to add at the end of truncated string (default is "...").
    @discardableResult
    public mutating func truncate(toLength length: Int, trailing: String? = "...") -> String

    /// ReerKit: Convert URL string to readable string.
    ///
    ///        var str = "it's%20easy%20to%20decode%20strings"
    ///        str.re.urlDecode()
    ///        print(str) // prints "it's easy to decode strings"
    ///
    @discardableResult
    public mutating func urlDecode() -> String

    /// ReerKit: Escape string.
    ///
    ///        var str = "it's easy to encode strings"
    ///        str.re.urlEncode()
    ///        print(str) // prints "it's%20easy%20to%20encode%20strings"
    ///
    @discardableResult
    public mutating func urlEncode() -> String

    /// ReerKit: Pad string to fit the length parameter size with another string in the start.
    ///
    ///     "hue".re.padStart(10) -> "       hue"
    ///     "hue".re.padStart(10, with: "br") -> "brbrbrbhue"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    @discardableResult
    public mutating func padStart(_ length: Int, with string: String = " ") -> String

    /// ReerKit: Pad string to fit the length parameter size with another string in the start.
    ///
    ///   "hue".padEnd(10) -> "hue       "
    ///   "hue".padEnd(10, with: "br") -> "huebrbrbrb"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    @discardableResult
    public mutating func padEnd(_ length: Int, with string: String = " ") -> String
}

public extension String {

    /// ReerKit: Overload Swift's 'contains' operator for matching regex pattern.
    ///
    /// - Parameters:
    ///   - lhs: String to check on regex pattern.
    ///   - rhs: Regex pattern to match against.
    /// - Returns: true if string matches the pattern.
    public static func ~= (lhs: String, rhs: String) -> Bool

    /// ReerKit: Overload Swift's 'contains' operator for matching regex.
    ///
    /// - Parameters:
    ///   - lhs: String to check on regex.
    ///   - rhs: Regex to match against.
    /// - Returns: `true` if there is at least one match for the regex in the string.
    public static func ~= (lhs: String, rhs: NSRegularExpression) -> Bool

    /// ReerKit: Repeat string multiple times.
    ///
    ///        'bar' * 3 -> "barbarbar"
    ///
    /// - Parameters:
    ///   - lhs: string to repeat.
    ///   - rhs: number of times to repeat character.
    /// - Returns: new string with given string repeated n times.
    public static func * (lhs: String, rhs: Int) -> String

    /// ReerKit: Repeat string multiple times.
    ///
    ///        3 * 'bar' -> "barbarbar"
    ///
    /// - Parameters:
    ///   - lhs: number of times to repeat character.
    ///   - rhs: string to repeat.
    /// - Returns: new string with given string repeated n times.
    public static func * (lhs: Int, rhs: String) -> String
}

public extension Reer where Base == String {

    /// ReerKit: NSString from a string.
    public var nsString: NSString { get }

    /// ReerKit: The full `NSRange` of the string.
    public var fullNSRange: NSRange { get }

    /// ReerKit: NSString lastPathComponent.
    public var lastPathComponent: String { get }

    /// ReerKit: NSString pathExtension.
    public var pathExtension: String { get }

    /// ReerKit: NSString deletingLastPathComponent.
    public var deletingLastPathComponent: String { get }

    /// ReerKit: NSString deletingPathExtension.
    public var deletingPathExtension: String { get }

    /// ReerKit: NSString pathComponents.
    public var pathComponents: [String] { get }

    /// ReerKit: Convert an `NSRange` into `Range<String.Index>`.
    /// - Parameter nsRange: The `NSRange` within the receiver.
    /// - Returns: The equivalent `Range<String.Index>` of `nsRange` found within the receiving string.
    public func range(from nsRange: NSRange) -> Range<Base.Index>

    /// ReerKit: Convert a `Range<String.Index>` into `NSRange`.
    /// - Parameter range: The `Range<String.Index>` within the receiver.
    /// - Returns: The equivalent `NSRange` of `range` found within the receiving string.
    public func nsRange(from range: Range<Base.Index>) -> NSRange

    /// ReerKit: NSString appendingPathComponent(str: String).
    ///
    /// - Note: This method only works with file paths (not, for example, string representations of URLs.
    ///   See NSString [appendingPathComponent(_:)](https://developer.apple.com/documentation/foundation/nsstring/1417069-appendingpathcomponent)
    /// - Parameter str: the path component to append to the receiver.
    /// - Returns: a new string made by appending aString to the receiver, preceded if necessary by a path separator.
    public func appendingPathComponent(_ str: String) -> String

    /// ReerKit: NSString appendingPathExtension(str: String).
    ///
    /// - Parameter str: The extension to append to the receiver.
    /// - Returns: a new string made by appending to the receiver an extension separator followed by ext (if applicable).
    public func appendingPathExtension(_ str: String) -> String?

    /// ReerKit: Accesses a contiguous subrange of the collection’s elements.
    /// - Parameter bounds: A range of the collection’s indices. The bounds of the range must be valid indices of the collection.
    /// - Returns: A slice of the receiving string.
    public subscript(bounds: NSRange) -> Substring { get }
}

public extension Reer where Base == String {

    /// ReerKit: Add attributes to string.
    /// - Parameter attributes: The attributes for the new attributed string. For a list of attributes that you can include in this dictionary, see NSAttributedString.Key.
    /// - Returns: A attributed string.
    public func with(attributes: [NSAttributedString.Key : Any]?) -> NSMutableAttributedString
}

public extension Reer where Base == String {

    /// ReerKit: Returns a lowercase String for md2 hash.
    public var md2String: String? { get }

    /// ReerKit: Returns a lowercase String for md4 hash.
    public var md4String: String? { get }

    /// ReerKit: Returns a lowercase String for md5 hash.
    public var md5String: String? { get }

    /// ReerKit: Returns a lowercase String for sha1 hash.
    public var sha1String: String? { get }

    /// ReerKit: Returns a lowercase String for sha224 hash.
    public var sha224String: String? { get }

    /// ReerKit: Returns a lowercase String for sha256 hash.
    public var sha256String: String? { get }

    /// ReerKit: Returns a lowercase String for sha384 hash.
    public var sha384String: String? { get }

    /// ReerKit: Returns a lowercase String for sha512 hash.
    public var sha512String: String? { get }

    /// ReerKit: Returns a base64 encoded string of the encrypted Data using AES.
    ///
    /// - Parameters:
    ///   - key: A key with a length of 16(AES128), 24(AES192) or 32(AES256) after conversion to data
    ///   - iv: An initialization vector with a length of 16(CBC) after conversion to data, or use the default data that length of 0(EBC)
    /// - Returns: A base64 encoded string of the encrypted Data encrypted, or nil if an error occurs.
    public func aesEncrypt(withKey key: String, iv: String = "") -> String?

    /// ReerKit: Returns an decrypted `String` using AES.
    ///
    /// - Parameters:
    ///   - key: A key with a length of 16(AES128), 24(AES192) or 32(AES256) after conversion to data
    ///   - iv: An initialization vector with a length of 16(CBC) after conversion to data, or use the default data that length of 0(EBC)
    /// - Returns: A decrypted string, or nil if an error occurs.
    public func aesDecrypt(withKey key: String, iv: String = "") -> String?

    /// ReerKit: Returns an RSA encrypted data string.
    /// - Parameter publicKey: RSA public key.
    /// - Returns: A base64 string represent the ecrypted data, or nil if an error occurs.
    public func rsaEncrypt(with publicKey: String) -> String?

    /// ReerKit: Returns an RSA decrypted data string.
    /// - Parameter privateKey: RSA private key.
    /// - Returns: A `String` decrypted, or nil if an error occurs.
    public func rsaDecrypt(with privateKey: String) -> String?

    /// ReerKit: Returns an RSA signed data string.
    /// - Parameter privateKey: RSA private key.
    /// - Returns: A base64 string represent the signature data, or nil if an error occurs.
    public func rsaSigned(with privateKey: String) -> String?

    /// ReerKit: Returns an RSA verified data string.
    /// - Parameter publicKey: RSA public key.
    /// - Returns: A verified `String`, or nil if an error occurs.
    public func rsaVerified(with publicKey: String) -> String?
}
```

### StringProtocol

```
import Foundation

public extension ReerForStringProtocol where Base: StringProtocol {

    /// ReerKit: The longest common suffix.
    ///
    ///        "Hello world!".re.commonSuffix(with: "It's cold!") = "ld!"
    ///
    /// - Parameters:
    ///     - Parameter aString: The string with which to compare the receiver.
    ///     - Parameter options: Options for the comparison.
    /// - Returns: The longest common suffix of the receiver and the given String.
    public func commonSuffix<T>(with aString: T, options: String.CompareOptions = []) -> String where T : StringProtocol
}
```