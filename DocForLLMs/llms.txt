<SYSTEM>Document for ReerKit</SYSTEM>

# Overview

ReerKit is a collection of native Swift extensions that provide convenient methods, syntactic sugar, and performance improvements for various native data types, UIKit, and Cocoa classes for iOS, macOS, tvOS, watchOS, and Linux platforms. All system type extensions in the framework have the re infix added to avoid ambiguity issues when calling the same name extension, such as

```
SGVsbG\n8gV29ybGQh".re.base64Decoded

"123".re.md5String

view.re.addSwiftUIView(Color.red)
```

# ReerInfix
Using the bridge below allows all system extension properties and methods to have an infix, such as `"aString".re.md5`

```
/// Wrapper for ReerKit compatible types. This type provides an extension point for
/// convenience methods in ReerKit.
public struct Reer<Base> {

    public let base: Base

    public init(_ base: Base)
}

/// Represents an object type that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerCompatible : AnyObject {
}

/// Represents a value type that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerCompatibleValue {
}

extension ReerCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<Self>.Type { get set }
}

extension ReerCompatibleValue {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<Self>.Type { get set }
}

/// Wrapper for ReerKit compatible types with a generic parameter. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerGeneric<Base, T> {

    public internal(set) var base: Base { get }

    public init(_ base: Base)
}

/// Represents a type with a generic parameter that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerGenericCompatible {

    associatedtype T
}

public extension ReerGenericCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerGeneric<Self, T> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerGeneric<Self, T>.Type { get set }
}

/// Wrapper for ReerKit compatible types with 2 generic parameters. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerGeneric2<Base, T1, T2> {

    public internal(set) var base: Base { get }

    public init(_ base: Base)
}

/// Represents a type with 2 generic parameters that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerGeneric2Compatible {

    associatedtype T1

    associatedtype T2
}

public extension ReerGeneric2Compatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerGeneric2<Self, T1, T2> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerGeneric2<Self, T1, T2>.Type { get set }
}

/// Wrapper for ReerKit compatible types in a reference way. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerReference<Base> {

    public internal(set) var base: UnsafeMutablePointer<Base> { get }

    public init(_ base: inout Base)
}

/// Represents a type that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerReferenceCompatible {
}

public extension ReerReferenceCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerReference<Self> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerReference<Self>.Type { get set }
}

/// Wrapper for ReerKit compatible types with a generic parameter in a reference way. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerReferenceGeneric<Base, T> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

/// Represents a type with a generic parameter that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerReferenceGenericCompatible {

    associatedtype T
}

public extension ReerReferenceGenericCompatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerReferenceGeneric<Self, T> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerReferenceGeneric<Self, T>.Type { get set }
}

/// Wrapper for ReerKit compatible types with a generic parameter in a reference way. This type provides an extension point for
/// convenience methods in ReerKit.
public struct ReerReferenceGeneric2<Base, U1, U2> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

/// Represents a type with a generic parameter that is compatible with ReerKit. You can use `re` property to get a
/// value in the namespace of ReerKit.
public protocol ReerReferenceGeneric2Compatible {

    associatedtype U1

    associatedtype U2
}

public extension ReerReferenceGeneric2Compatible {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerReferenceGeneric2<Self, U1, U2> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerReferenceGeneric2<Self, U1, U2>.Type { get set }
}

public extension Numeric {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<`Self`> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<`Self`>.Type { get set }
}

public extension Sequence {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: Reer<`Self`> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: Reer<`Self`>.Type { get set }
}

public struct ReerForEquatable<Base> {

    public internal(set) var base: Base { get }

    public init(_ base: Base)
}

public extension Equatable {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForEquatable<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForEquatable<Self>.Type { get set }
}

public struct ReerForMutableCollection<Base> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

public extension MutableCollection {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForMutableCollection<Self> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForMutableCollection<Self>.Type { get set }
}

public struct ReerForStringProtocol<Base> {

    public let base: Base

    public init(_ base: Base)
}

public extension StringProtocol {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForStringProtocol<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForStringProtocol<Self>.Type { get set }
}

public struct ReerForRangeReplaceableCollection<Base> {

    public let base: UnsafeMutablePointer<Base>

    public init(_ base: inout Base)
}

public extension RangeReplaceableCollection {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForRangeReplaceableCollection<Self> { mutating get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForRangeReplaceableCollection<Self>.Type { get set }
}

public struct ReerForOptionSet<Base> {

    public let base: Base

    public init(_ base: Base)
}

public extension OptionSet {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForOptionSet<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForOptionSet<Self>.Type { get set }
}

public struct ReerForContiguousBytes<Base> {

    public let base: Base

    public init(_ base: Base)
}

public extension ContiguousBytes {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForContiguousBytes<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForContiguousBytes<Self>.Type { get set }
}
```

# API List

## GlobalFunctions

```
import Dispatch
/// ReerKit: Get current queue label.
/// - Returns: Queue label string.
public func currentQueueLabel() -> String

/// ReerKit: Execute a closure on main queue asynchronously.
public func asyncOnMainQueue(_ action: @escaping () -> Void)

/// ReerKit: Execute a closure on main queue synchronously.
public func syncOnMainQueue(_ action: @escaping () -> Void)

/// ReerKit: Execute a closure on global queue asynchronously.
public func asyncOnGlobalQueue(qos: DispatchQoS.QoSClass = .default, action: @escaping () -> Void)

/// ReerKit: Execute a closure on global queue synchronously.
public func syncOnGlobalQueue(qos: DispatchQoS.QoSClass = .default, action: @escaping () -> Void)

/// ReerKit: Delay to execute a closure on the queue.
public func delay(_ interval: Double, onQueue queue: DispatchQueue = .main, action: @escaping () -> Void)

import Darwin
/// ReerKit: Get info by name via `sysctl`
/// e.g.
/// hw.model
/// kern.osversion
/// kern.hostname
public func sysctl(by name: String) -> String

/// ReerKit: Return a `Bool` value, the probability of it being `true` is the input value.
public func trueWithProbability(_ percent: Double) -> Bool

/// ReerKit: Return a `Bool` value, the probability of it being `false` is the input value.
public func falseWithProbability(_ percent: Double) -> Bool
```

```
/// ReerKit: An once token type that wrapped an internal string.
public struct OnceToken : Hashable {

    /// Create a token with an internal pointer.
    public init()

    public init(_ value: String)
}

/// ReerKit: Invoke the passed closure only once during the life time of the process.
/// It will create an once token by combining #fileID, #function, #line.
///
///     once {
///         print("do something")
///     }
///
/// - Parameters:
///   - fileID: No need to pass it, just use the default.
///   - function: No need to pass it, just use the default.
///   - line: No need to pass it, just use the default.
///   - execute: The closure need to be executed.
public func once(fileID: String = #fileID, function: String = #function, line: Int = #line, execute: () -> Void)

/// ReerKit: Invoke the passed closure only once during the life time of the process.
/// It need an once token parameter, seealso `OnceToken`.
///
///     let token = OnceToken()
///     once(token) {
///         print("do something")
///     }
///
/// - Parameters:
///   - token: An unique once token.
///   - execute: The closure need to be executed.
public func once(_ token: OnceToken, execute: () -> Void)

/// ReerKit: Cancel the once token mark, that means you can execute the action again with the same token.
/// - Parameter token: The token that need to cancel marking.
public func deonce(_ token: OnceToken)
```

```
import ObjectiveC
/// ReerKit: Use just like objective-c `@synchronized`.
///
///     let obj = NSObject()
///     synchronized(obj) {
///         // do something
///     }
/// - Parameters:
///   - token: A reference type object.
///   - execute: An action need to be executed synchronizely.
public func synchronized<Result>(_ token: AnyObject, execute: () throws -> Result) rethrows -> Result
```

```
import ObjectiveC

/// ReerKit: Global function to observe deinit for the object.
public func observeDeinit<Object>(for object: Object?, onDeinit: @escaping () -> Void) where Object : AnyObject
```

```
/// Get module name from a swift file ID.
/// - Parameter fileId: No need to pass it, just use the default.
/// - Returns: Module name, return `""` if failed.
public func moduleName(fileId: String = #fileID) -> String
```

## DataStructure

### Tree

```
/// Define a generic N-ary tree data structure as a class with parent pointers
public class Tree<E> {

    /// The value stored in the node
    public var value: E

    /// The children of the node
    public var children: [Tree<E>] { get set }

    /// The parent node; weak to prevent retain cycles
    public weak var parent: Tree<E>?

    /// Computed property to count the total number of nodes in the tree
    public var count: Int { get }

    /// Initialize a node with a value
    public init(value: E)

    /// Add a child node with a value
    @discardableResult
    public func addChild(value: E) -> Tree<E>

    /// Add an existing tree as a child
    @discardableResult
    public func addChild(_ child: Tree<E>) -> Tree<E>
}

/// Extension to add traversal methods to the N-ary tree
extension Tree {

    /// Pre-order traversal (Root, Children)
    public func traversePreorder(process: (E) -> Void)

    /// Post-order traversal (Children, Root)
    public func traversePostorder(process: (E) -> Void)

    /// Level-order traversal with level information
    public func traverseLevelOrder(process: (E, Int) -> Void)
}

/// Extension to add inversion methods to the N-ary tree
extension Tree {

    /// Function to invert (mirror) the N-ary tree in place
    public func invert()

    /// Function to get a new inverted (mirrored) N-ary tree
    public func inverted() -> Tree<E>
}

extension Tree : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Tree {

    /// Prints the tree structure as a string.
    public func printTreeString()

    /// Generates a string representation of the tree structure.
    ///
    /// ```swift
    /// Root
    /// ├── Child2
    /// ├── Child1
    /// │   └── Grandchild2
    /// │       └── GreatGrandchild0
    /// └── Child0
    ///     ├── Grandchild1
    ///     └── Grandchild0
    /// ```
    ///
    /// - Returns: A string representing the tree structure.
    public func treeString() -> String
}
```

### BinaryTree

```
/// Define a generic binary tree data structure as a class with parent pointers
public class BinaryTree<E> {

    /// The value stored in the node
    public var value: E

    /// The left child of the node
    public var left: BinaryTree<E>? { get set }

    /// The right child of the node
    public var right: BinaryTree<E>? { get set }

    /// The parent node; weak to prevent retain cycles
    public weak var parent: BinaryTree<E>?

    /// Computed property to count the total number of nodes in the tree
    public var count: Int { get }

    /// Initialize a node with a value
    public init(value: E)

    /// Set a left child with a value
    @discardableResult
    public func setLeft(value: E) -> BinaryTree<E>

    /// Set a right child with a value
    @discardableResult
    public func setRight(value: E) -> BinaryTree<E>
}

/// Extension to add traversal methods to the binary tree
extension BinaryTree {

    /// In-order traversal (Left, Root, Right)
    public func traverseInorder(process: (E) -> Void)

    /// Pre-order traversal (Root, Left, Right)
    public func traversePreorder(process: (E) -> Void)

    /// Post-order traversal (Left, Right, Root)
    public func traversePostorder(process: (E) -> Void)

    /// Level-order traversal with level information
    public func traverseLevelOrder(process: (E, Int) -> Void)
}

/// Extension to add inversion methods to the binary tree
extension BinaryTree {

    /// Function to invert (mirror) the binary tree in place
    public func invert()

    /// Function to get a new inverted (mirrored) binary tree
    public func inverted() -> BinaryTree<E>
}

extension BinaryTree : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension BinaryTree {

    public func printTreeString(showLabel: Bool = false, showEmptyNode: Bool = true)

    /// Generates a string representation of the tree structure.
    ///
    /// ```swift
    /// 1
    /// ├── R: 3
    /// │   ├── R: 6
    /// │   │   ├── R: •
    /// │   │   └── L: 7
    /// │   └── L: •
    /// └── L: 2
    ///     ├── R: 5
    ///     └── L: 4
    ///
    /// 1
    /// ├── R: 3
    /// │   └── R: 6
    /// │       └── L: 7
    /// └── L: 2
    ///     ├── R: 5
    ///     └── L: 4
    ///
    /// 1
    /// ├── 3
    /// │   ├── 6
    /// │   │   ├── •
    /// │   │   └── 7
    /// │   └── •
    /// └── 2
    ///     ├── 5
    ///     └── 4
    /// ```
    ///
    /// - Parameters:
    ///   - showLabel: If `true`, includes "L:" and "R:" labels to indicate left and right children.
    ///   - showEmptyNode: If `true`, includes placeholder `•` for empty child nodes.
    /// - Returns: A string representing the tree structure.
    public func treeString(showLabel: Bool = true, showEmptyNode: Bool = true) -> String
}
```

### Queue

```
public struct Queue<E> {

    public init()

    public var count: Int { get }

    public var isEmpty: Bool { get }

    public mutating func enqueue(_ element: E)

    @discardableResult
    public mutating func dequeue() -> E?

    public var front: E? { get }
}

extension Queue : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}
```

### BoundedQueue

```
/// ReerKit: A first-in-first-out queue with a fixed capacity.
public struct BoundedQueue<E> {

    public enum OverflowBehavior {

        case rejectNew

        case dequeueOldest
    }

    public init(maxSize: Int, overflowBehavior: OverflowBehavior)

    public var count: Int { get }

    public var isEmpty: Bool { get }

    @discardableResult
    public mutating func enqueue(_ element: E) -> Bool

    @discardableResult
    public mutating func dequeue() -> E?

    public var front: E? { get }
}

extension BoundedQueue : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}
```

### OrderedDictionary

```
/// ReerKit: A dictionary with guaranteed keys ordering.
///
///     var dict = OrderedDictionary<String, Int>()
///     dict.append(1, forKey: "foo")
///     dict.append(2, forKey: "bar")
///
///     dict["foo"] // 1
///     dict["bar"] // 2
///     dict["qux"] // nil
///     dict.map { $0.key } // ["foo", "bar"], in this order.
public struct OrderedDictionary<Key, Value> where Key : Hashable {

    public private(set) var keys: [Key] { get }

    public private(set) var dictionary: [Key : Value] { get }

    public var values: [Value] { get }

    /// Creates an empty ordered dictionary.
    public init()

    /// Creates an empty ordered dictionary.
    public init(minimumCapacity: Int)

    /// Returns the value associated with key, or nil.
    public subscript(key: Key) -> Value? { get set }

    /// Returns the value associated with key, or the default value.
    public subscript(key: Key, default defaultValue: Value) -> Value { get set }

    /// Appends the given value for the given key.
    ///
    /// - precondition: There is no value associated with key yet.
    public mutating func appendValue(_ value: Value, forKey key: Key)

    /// Updates the value stored in the dictionary for the given key, or
    /// appends a new key-value pair if the key does not exist.
    ///
    /// Use this method instead of key-based subscripting when you need to know
    /// whether the new value supplants the value of an existing key. If the
    /// value of an existing key is updated, updateValue(_:forKey:) returns the
    /// original value. If the given key is not present in the dictionary, this
    /// method appends the key-value pair and returns nil.
    @discardableResult
    public mutating func updateValue(_ value: Value, forKey key: Key) -> Value?

    /// Removes the value associated with key.
    @discardableResult
    public mutating func removeValue(forKey key: Key) -> Value?

    /// Returns a new ordered dictionary containing the keys of this dictionary
    /// with the values transformed by the given closure.
    public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> OrderedDictionary<Key, T>

    /// Returns a new ordered dictionary containing only the key-value pairs
    /// that have non-nil values as the result of transformation by the
    /// given closure.
    public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> OrderedDictionary<Key, T>

    public func filter(_ isIncluded: ((key: Key, value: Value)) throws -> Bool) rethrows -> OrderedDictionary<Key, Value>

    public mutating func merge<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Sequence, S.Element == (Key, Value)

    public mutating func merge<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Sequence, S.Element == (key: Key, value: Value)

    public func merging<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> OrderedDictionary<Key, Value> where S : Sequence, S.Element == (Key, Value)

    public func merging<S>(_ other: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> OrderedDictionary<Key, Value> where S : Sequence, S.Element == (key: Key, value: Value)
}

extension OrderedDictionary : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> (key: Key, value: Value) { get }
}

extension OrderedDictionary : ExpressibleByDictionaryLiteral {

    /// Creates an instance initialized with the given key-value pairs.
    public init(dictionaryLiteral elements: (Key, Value)...)
}

extension OrderedDictionary : Equatable where Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: OrderedDictionary, rhs: OrderedDictionary) -> Bool
}

extension OrderedDictionary : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Dictionary {

    public init(_ orderedDictionary: OrderedDictionary<Key, Value>)
}
```

### OrderedSet

```
/// ReerKit: An ordered set is an ordered collection of instances of `Element` in which
/// uniqueness of the objects is guaranteed.
///
///     var set = OrderedSet<String>()
///     set.append("a")
///     set.insert("b", at: 1)
///     set.append("c")
///     set.map { Int($0)! } // [1, 2, 3], in this order.
public struct OrderedSet<Element> where Element : Hashable {

    /// Creates an empty ordered set.
    public init()

    /// Creates an empty ordered set.
    public init(_ array: [Element])

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("My horse has no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!"
    ///
    /// - Complexity: O(1)
    public var isEmpty: Bool { get }

    /// Array value of the ordered set.
    public var elements: [Element] { get }

    public func contains(_ member: Element) -> Bool

    /// Append a new member to the end of the set, if the set doesn't
    /// already contain it.
    ///
    /// - Parameter newElement: The element to add to the set.
    ///
    /// - Returns: A pair `(inserted, index)`, where `inserted` is a Boolean value
    ///    indicating whether the operation added a new element, and `index` is
    ///    the index of `item` in the resulting set.
    ///
    /// - Complexity: The operation is expected to perform O(1) copy, hash, and
    ///    compare operations on the `Element` type, if it implements high-quality
    ///    hashing.
    @discardableResult
    public mutating func append(_ newElement: Element) -> (inserted: Bool, index: Int)

    /// Insert a new member to this set at the specified index, if the set doesn't
    /// already contain it.
    ///
    /// - Parameter newElement: The element to insert.
    /// - Parameter index: The index will insert at.
    /// - Returns: A pair `(inserted, index)`, where `inserted` is a Boolean value
    ///    indicating whether the operation added a new element, and `index` is
    ///    the index of `item` in the resulting set. If `inserted` is false, then
    ///    the returned `index` may be different from the index requested.
    ///
    /// - Complexity: The operation is expected to perform amortized
    ///    O(`self.count`) copy, hash, and compare operations on the `Element`
    ///    type, if it implements high-quality hashing. (Insertions need to make
    ///    room in the storage array to add the inserted element.)
    @discardableResult
    public mutating func insert(_ newElement: Element, at index: Int) -> (inserted: Bool, index: Int)

    /// Remove and return the element at the beginning of the ordered set.
    @discardableResult
    public mutating func removeFirst() -> Element

    /// Remove and return the element at the end of the ordered set.
    @discardableResult
    public mutating func removeLast() -> Element

    @discardableResult
    public mutating func remove(_ member: Element) -> Element?

    /// Remove all elements.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)
}

extension OrderedSet : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> Element { get }
}

extension OrderedSet : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral elements: Element...)
}

extension OrderedSet : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension OrderedSet : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: OrderedSet, rhs: OrderedSet) -> Bool
}
```

### Stack

```
public struct Stack<E> {

    public init()

    public var count: Int { get }

    public var isEmpty: Bool { get }

    public mutating func push(_ element: E)

    @discardableResult
    public mutating func pop() -> E?

    public var top: E? { get }

    public mutating func removeAll()
}

extension Stack : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}
```

### LinkedList

```
/// A doubly linked list implementation.
public final class LinkedList<E> {

    public private(set) var count: Int { get }

    public var isEmpty: Bool { get }

    public init()

    public func insert(_ element: E, at index: Int)

    public func append(_ element: E)

    @discardableResult
    public func remove(at index: Int) -> E

    public func removeFirst()

    public func removeLast()

    public func removeAll()

    public func set(_ element: E, at index: Int)

    public subscript(index: Int) -> E { get }
}

extension LinkedList where E : Equatable {

    public func firstIndex(of element: E) -> Int?

    public func lastIndex(of element: E) -> Int?

    public func contains(element: E) -> Bool

    public func removeAll(_ element: E)

    public func removeAll(_ elements: [E])

    public func removeAll(where shouldBeRemoved: (E) throws -> Bool) rethrows
}

extension LinkedList : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public convenience init(arrayLiteral elements: E...)
}

extension LinkedList {

    public var array: [E] { get }

    public func reverse()
}

extension LinkedList : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension LinkedList {

    public func map<T>(transform: (E) -> T) -> LinkedList<T>

    public func filter(predicate: (E) -> Bool) -> LinkedList<E>
}

extension LinkedList : Sequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> LinkedListIterator<E>
}

public struct LinkedListIterator<E> : IteratorProtocol {
    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> E?
}
```

## Lock

### MutexLock

```
import Darwin

/// ReerKit: A wrapper class for pthread mutex, providing a simple interface for thread synchronization.
public final class MutexLock {

    public init()

    /// Acquires the lock, blocking the current thread until the lock can be obtained.
    public func lock()

    /// ReerKit: Attempts to acquire the lock without blocking.
    /// Returns true if the lock was successfully locked and false if the lock was already locked.
    @discardableResult
    public func tryLock() -> Bool

    /// Releases the lock.
    public func unlock()

    /// ReerKit: Executes a closure returning a value while acquiring the lock.
    ///
    /// - Parameter execute: The closure to run while holding the lock.
    ///
    /// - Returns: The value the closure generated.
    ///
    /// - Throws: Rethrows any error that the closure might throw.
    public func around<Result>(_ execute: () throws -> Result) rethrows -> Result
}
```

### ReadWriteLock

```
import Darwin

/// ReerKit: Represents a reader-writer lock. Note that this implementation is not recursive.
public final class ReadWriteLock {

    public init()

    public func readLock()

    /// ReerKit: Returns true if the lock was succesfully locked and false if the lock was already locked.
    @discardableResult
    public func tryReadLock() -> Bool

    public func readUnlock()

    public func writeLock()

    /// ReerKit: Returns true if the lock was succesfully locked and false if the lock was already locked.
    @discardableResult
    public func tryWriteLock() -> Bool

    public func writeUnlock()

    public func readAround<Result>(_ execute: () throws -> Result) rethrows -> Result

    public func writeAround<Result>(_ execute: () throws -> Result) rethrows -> Result
}
```

### UnfairLock

```
import os.lock

/// ReerKit: A wrapper of `os_unfair_lock`
public final class UnfairLock {

    public init()

    public func lock()

    /// ReerKit: Returns true if the lock was succesfully locked and false if the lock was already locked.
    @discardableResult
    public func tryLock() -> Bool

    public func unlock()

    /// ReerKit: Executes a closure returning a value while acquiring the lock.
    ///
    /// - Parameter execute: The closure to run.
    ///
    /// - Returns: The value the closure generated.
    public func around<Result>(_ execute: () throws -> Result) rethrows -> Result
}
```

## Math

### LinearFunction

```
import CoreGraphics

/// ReerKit: Represents a linear function of the form y = mx + b
public struct LinearFunction : CustomStringConvertible {

    /// The slope (m) of the linear function
    public let slope: Double

    /// The y-intercept (b) of the linear function
    public let intercept: Double

    /// Initializes a LinearFunction with a given slope and y-intercept
    /// - Parameters:
    ///   - slope: The slope of the line
    ///   - intercept: The y-intercept of the line
    public init(slope: Double, intercept: Double)

    /// Initializes a LinearFunction from two points on the line
    /// - Parameters:
    ///   - point1: The first point on the line
    ///   - point2: The second point on the line
    public init(point1: CGPoint, point2: CGPoint)

    /// Calculates the y value for a given x value
    ///
    ///     let linear = LinearFunction(slope: 2, intercept: 5)
    ///     let y = linear(x: 3)
    ///
    /// - Parameter x: The x value
    /// - Returns: The corresponding y value
    public func callAsFunction(x: Double) -> Double

    /// Calculates the x value for a given y value
    ///
    ///     let linear = LinearFunction(slope: 2, intercept: 5)
    ///     let x = linear(y: 11)
    ///
    /// - Parameter y: The y value
    /// - Returns: The corresponding x value
    public func callAsFunction(y: Double) -> Double

    /// A string representation of the linear function
    public var description: String { get }
}
```

## PropertyWrapper

### Clamped

```
@propertyWrapper 
public struct Clamped<Value> where Value : Comparable {

    public init(wrappedValue: Value, _ range: ClosedRange<Value>)

    public var wrappedValue: Value { get set }
}
```

### Locked

```
import os.lock

/// ReerKit: A lock protects the property with an `os_unfair_lock`
@propertyWrapper 
public final class Locked<T> {

    public init(wrappedValue: T)

    public var wrappedValue: T { get set }

    public var projectedValue: Locked<T> { get }

    public func read<U>(_ execute: (T) throws -> U) rethrows -> U

    @discardableResult
    public func write<U>(_ execute: (inout T) throws -> U) rethrows -> U
}
```

### Rounded

```
@propertyWrapper 
public struct Rounded<Value> where Value : FloatingPoint {

    public let rule: FloatingPointRoundingRule

    public init(wrappedValue: Value, rule: FloatingPointRoundingRule = .toNearestOrAwayFromZero)

    public var wrappedValue: Value { get set }
}
```

### RWLocked

```
import Darwin

/// ReerKit: A read write lock wrapper grants multiple readers and single-writer guarantees on a value.
@propertyWrapper 
public final class RWLocked<T> {

    public init(wrappedValue: T)

    public var wrappedValue: T { get set }

    public var projectedValue: RWLocked<T> { get }

    public func read<U>(_ execute: (T) throws -> U) rethrows -> U

    @discardableResult
    public func write<U>(_ execute: (inout T) throws -> U) rethrows -> U
}
```

### Trimmed

```
@propertyWrapper
public struct Trimmed {

    public init(wrappedValue: String)

    public var wrappedValue: String { get set }
}
```

## Weak

### weak

```
/// Weak wrapper for AnyObject.
public final class Weak<T> where T : AnyObject {

    public private(set) weak var object: T? { get }

    public init(_ object: T)
}

extension Weak : Equatable, Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Weak<T>, rhs: Weak<T>) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}
```

### WeakProxy

```
import Foundation

/// A proxy used to hold a weak object.
/// It can be used to avoid retain cycles, such as the target in Timer or CADisplayLink.
public class WeakProxy : NSObject {

    /// The proxy target.
    public weak var target: NSObject?

    /// Creates a new weak proxy for target.
    public init(target: NSObject)

    public override func forwardingTarget(for aSelector: Selector!) -> Any?

    public override func responds(to aSelector: Selector!) -> Bool

    public override func isEqual(_ object: Any?) -> Bool

    public override var hash: Int { get }

    public override var superclass: AnyClass? { get }

    public override func isProxy() -> Bool

    public override func isKind(of aClass: AnyClass) -> Bool

    public override func isMember(of aClass: AnyClass) -> Bool

    public override func conforms(to aProtocol: Protocol) -> Bool

    public override var description: String { get }

    public override var debugDescription: String { get }
}
```

### WeakMap

```
public protocol WeakOption {}

/// Use phantom types to express weak option.
public enum WeakKey : WeakOption {}
public enum WeakValue : WeakOption {}
public enum WeakKeyValue : WeakOption {}

/// A map class that weak refering every AnyObject element.
/// If the object element's key or value released, its weak wrapper `Weak<T>` will remove from the internal map automatically.
/// This class is not thread-safe and should not be accessed concurrently from multiple threads.
/// 
///     var aa: NSObject? = NSObject()
///     let bb: NSObject? = NSObject()
///     let map: WeakMap<WeakValue, String, NSObject> = .init(["aa": aa!, "bb": bb!])
///
public class WeakMap<Option, Key, Value> where Option : WeakMap.WeakOption, Key : Hashable {

    public var count: Int { get }

    public var keys: [Key] { get }

    public var values: [Value] { get }
}

extension WeakMap where Option == WeakMap.WeakKey, Key : AnyObject {

    public convenience init(_ weakKeyMap: [Key : Value] = [:])

    public subscript(key: Key) -> Value? { get set }

    @discardableResult
    public func removeValue(forKey key: Key) -> Value?

    @discardableResult
    public func updateValue(_ value: Value, forKey key: Key) -> Value?

    public func forEach(_ body: ((key: Key, value: Value)) throws -> Void) rethrows
}

extension WeakMap where Option == WeakMap.WeakValue, Value : AnyObject {

    public convenience init(_ weakValueMap: [Key : Value] = [:])

    public subscript(key: Key) -> Value? { get set }

    @discardableResult
    public func removeValue(forKey key: Key) -> Value?

    @discardableResult
    public func updateValue(_ value: Value, forKey key: Key) -> Value?

    public func forEach(_ body: ((key: Key, value: Value)) throws -> Void) rethrows
}

extension WeakMap where Option == WeakMap.WeakKeyValue, Key : AnyObject, Value : AnyObject {

    public convenience init(_ weakKeyValueMap: [Key : Value] = [:])

    public subscript(key: Key) -> Value? { get set }

    @discardableResult
    public func removeValue(forKey key: Key) -> Value?

    @discardableResult
    public func updateValue(_ value: Value, forKey key: Key) -> Value?

    public func forEach(_ body: ((key: Key, value: Value)) throws -> Void) rethrows
}
```

### WeakSet

```
/// A set class that weak refering every AnyObject element.
/// If the object element released, its weak wrapper `Weak<T>` will remove from the internal set automatically.
/// This class is not thread-safe and should not be accessed concurrently from multiple threads.
///
///     var aa: NSObject? = NSObject()
///     let bb: NSObject? = NSObject()
///     let set = WeakSet([aa!, bb!])
///
public class WeakSet<T> : ExpressibleByArrayLiteral where T : AnyObject {

    public init()

    public init(_ objects: [T])

    /// Creates an instance initialized with the given elements.
    public required convenience init(arrayLiteral elements: T...)

    public var allObjects: [T] { get }

    public var count: Int { get }

    public func contains(_ object: T) -> Bool

    public func add(_ object: T)

    public func addObjects(_ objects: [T])

    public func remove(_ object: T)

    public func removeObjects(_ objects: [T])

    public func removeAll()

    public func copy() -> WeakSet<T>
}

extension WeakSet : Sequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> WeakSetIterator<T>
}

public struct WeakSetIterator<T> : IteratorProtocol where T : AnyObject {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> T?
}
```

## Utility

### RETimer

```
import Dispatch
import os.lock
import Foundation

/// ReerKit: A timer based on `DispatchSource`.
///
///                           fireDate
///     schedule()   callbackImmediatelyWhenFired  default first callback
///         |                     |                      |
///         |--------delay--------|-------interval-------|-------interval-------|
public final class RETimer {

    public enum State {

        case initial

        case running

        case suspended

        case invalidated
    }

    /// A number of seconds.
    public typealias TimeInterval = Double

    public private(set) var repeats: Bool { get }

    public private(set) var timeInterval: TimeInterval { get }

    public private(set) var state: State { get }

    public typealias RETimerAction = (_ timer: RETimer) -> Void

    /// Total elapsed time since the timer started, excluding paused durations.
    public var totalElapsedTime: TimeInterval { get }

    /// ReerKit: Initializes a timer object with the specified time interval and block.
    /// You must call `schedule()` yourself after creating the timer.
    ///
    /// - Parameters:
    ///   - delay: The delay interval after `schedule` method is invoked.
    ///   - timeInterval: The number of seconds between firings of the timer. If timeInterval is less than or equal to 0.0, this method chooses the nonnegative value of 0.0001 seconds instead.
    ///   - repeats: If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - callbackImmediatelyWhenFired: When should callback when time is fired, default is `false`, and its behavior is the same as `Foundation.Timer`
    ///   - action: A closure to be executed when the timer fires. The closure takes a single Timer parameter and has no return value.
    public init(delay: TimeInterval = 0, timeInterval: TimeInterval, repeats: Bool = true, queue: DispatchQueue = .main, callbackImmediatelyWhenFired: Bool = false, action: @escaping RETimerAction)

    /// ReerKit: Creates a timer and schedules it with a delay interval.
    /// - Parameters:
    ///   - delay: The delay interval after `schedule` method is invoked.
    ///   - timeInterval: The number of seconds between firings of the timer. If timeInterval is less than or equal to 0.0, this method chooses the nonnegative value of 0.0001 seconds instead.
    ///   - repeats: If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - callbackImmediatelyWhenFired: When should callback when time is fired, default is `false`, and its behavior is the same as `Foundation.Timer`
    ///   - action: A closure to be executed when the timer fires. The closure takes a single Timer parameter and has no return value.
    /// - Returns: A timer instance.
    public class func scheduledTimer(delay: TimeInterval = 0, timeInterval: TimeInterval, repeats: Bool = true, queue: DispatchQueue = .main, callbackImmediatelyWhenFired: Bool = false, action: @escaping RETimerAction) -> RETimer

    /// ReerKit: Creates a timer and schedules it on a fire date.
    /// - Parameters:
    ///   - fireDate: The fire date of the timer.
    ///   - timeInterval: The number of seconds between firings of the timer. If timeInterval is less than or equal to 0.0, this method chooses the nonnegative value of 0.0001 seconds instead.
    ///   - repeats: If true, the timer will repeatedly reschedule itself until invalidated. If false, the timer will be invalidated after it fires.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - callbackImmediatelyWhenFired: When should callback when time is fired, default is `false`, and its behavior is the same as `Foundation.Timer`
    ///   - action: A closure to be executed when the timer fires. The closure takes a single Timer parameter and has no return value.
    /// - Returns: A timer instance.
    public static func scheduledTimer(fireDate: Date, timeInterval: TimeInterval, repeats: Bool = true, queue: DispatchQueue = .main, callbackImmediatelyWhenFired: Bool = false, action: @escaping RETimerAction) -> RETimer

    /// ReerKit: Schedules a timer.
    @discardableResult
    public func schedule() -> Bool

    /// ReerKit: Resumes the timer when timer is suspended.
    ///
    /// - Important: Do NOT use `resume` to start the timer, it will not work.
    public func resume()

    /// ReerKit: Suspends the timer.
    public func suspend()

    /// ReerKit: Stops the timer from ever firing again.
    public func invalidate()
}

public extension RETimer {

    /// ReerKit: Execute the closure after the delay interval.
    /// - Parameters:
    ///   - delay: The delay interval.
    ///   - queue: The dispatch queue to which to execute the installed handlers.
    ///   - action: A closure to be executed after the delay.
    public static func after(_ delay: TimeInterval, queue: DispatchQueue = .main, action: @escaping () -> Void)

    /// ReerKit: Creates a timer that fires every second, providing the timer instance, display seconds, and passed duration.
    ///
    /// This method creates a timer that fires every second, calling the `action` closure with the timer, the number of seconds that have passed, and the total elapsed time excluding any paused durations. Internally, it uses a more frequent interval for increased accuracy, especially when resuming from a suspended state.
    ///
    /// **Usage example:**
    /// ```swift
    /// let timer = RETimer.scheduledTimerEverySecond { timer, displaySeconds, passedDuration in
    ///     print("Timer fired! Display Seconds: \(displaySeconds), Passed Duration: \(passedDuration)")
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - queue: The dispatch queue on which to execute the timer. Defaults to the main queue.
    ///   - action: A closure to be executed every second. The closure takes three parameters:
    ///     - `timer`: The `RETimer` instance.
    ///     - `displaySeconds`: An `Int` representing the number of seconds that have passed since the timer started.
    ///     - `passedDuration`: A `TimeInterval` representing the total elapsed time excluding any paused durations.
    /// - Returns: An instance of `RETimer` configured to fire every second.
    public static func scheduledTimerEverySecond(queue: DispatchQueue = .main, action: @escaping (_ timer: RETimer, _ displaySeconds: Int, _ passedDuration: TimeInterval) -> Void) -> RETimer
}
```

### CountdownTimer

```
import Foundation
import Dispatch

/// A class that represents a countdown timer with customizable intervals and durations.
public final class CountdownTimer {

    /// The time interval between each tick of the timer.
    public let interval: TimeInterval

    /// The total number of times the timer should tick.
    public let times: Int

    /// The total duration of the countdown.
    public let totalDuration: TimeInterval

    /// The action to be performed on each tick of the timer.
    public let action: (CountdownTimer) -> Void

    /// The number of ticks remaining.
    public private(set) var leftTimes: Int { get }

    /// The remaining duration of the countdown.
    public var leftDuration: TimeInterval { get }

    /// Indicates whether the countdown has finished.
    public var finished: Bool { get }

    /// Initializes a new countdown timer with a specified interval and number of ticks.
    ///
    /// - Parameters:
    ///   - interval: The time interval between each tick.
    ///   - times: The total number of ticks.
    ///   - action: The action to be performed on each tick.
    public init(interval: TimeInterval, times: Int, action: @escaping (CountdownTimer) -> Void)

    /// Initializes a new countdown timer with a specified number of ticks and total duration.
    ///
    /// - Parameters:
    ///   - times: The total number of ticks.
    ///   - totalDuration: The total duration of the countdown.
    ///   - action: The action to be performed on each tick.
    public init(times: Int, totalDuration: TimeInterval, action: @escaping (CountdownTimer) -> Void)

    /// Creates and returns a new countdown timer with the specified interval and number of ticks.
    ///
    /// - Parameters:
    ///   - interval: The time interval between each tick.
    ///   - times: The total number of ticks.
    ///   - action: The action to be performed on each tick.
    /// - Returns: A new countdown timer that has already started.
    public static func scheduledTimer(withInterval interval: TimeInterval, times: Int, action: @escaping (CountdownTimer) -> Void) -> CountdownTimer

    /// Creates and returns a new countdown timer with the specified number of ticks and total duration.
    ///
    /// - Parameters:
    ///   - times: The total number of ticks.
    ///   - totalDuration: The total duration of the countdown.
    ///   - action: The action to be performed on each tick.
    /// - Returns: A new countdown timer that has already started.
    public static func scheduledTimer(withTimes times: Int, totalDuration: TimeInterval, action: @escaping (CountdownTimer) -> Void) -> CountdownTimer

    /// ReerKit: Countdown timer with a total seconds be set, and call back every second.
    ///
    /// ```
    /// var countdownTimer = CountdownTimer.scheduledTimer(withTotalSeconds: 60) {
    ///     [weak self] displaySeconds, leftDuration, passedDuration in
    ///
    ///     let minutes = Int(Double(displaySeconds) / 60.0)
    ///     let seconds = Int(Double(displaySeconds) - minutes.re.double * 60.0)
    ///     self?.timeLabel.text = String(format: "%02d:%02d", minutes, seconds)
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - totalSeconds: Total seconds with `Int`
    ///   - action: Called back every second, carrying the displayed number of seconds, remaining time, and elapsed time.
    /// - Returns: A countdown timer.
    public static func scheduledTimer(withTotalSeconds totalSeconds: Int, action: @escaping (_ displaySeconds: Int, _ leftDuration: TimeInterval, _ passedDuration: TimeInterval) -> Void) -> CountdownTimer

    /// Starts the countdown timer.
    public func fire()

    /// Resumes the countdown timer if it was suspended.
    public func resume()

    /// Suspends the countdown timer.
    public func suspend()

    /// Invalidates the countdown timer, preventing it from ever firing again.
    public func invalidate()

    /// Resets the countdown timer to its initial state.
    public func reset()
}
```

### Throttler

```
import Foundation

public final class Throttler {

    public enum PerformMode {

        case first

        case last
    }

    public init(queue: DispatchQueue = .main, performMode: PerformMode = .first)

    public func execute(interval: TimeInterval, action: @escaping () -> Void)

    public func execute(deadline: DispatchTime, action: @escaping () -> Void)

    public func execute(wallDeadline: DispatchWallTime, action: @escaping () -> Void)
}
```

### Debouncer

```
import Foundation

/// A class that provides debouncing functionality for executing actions after a specified delay.
public final class Debouncer {

    /// The current work item representing the debounced action.
    public private(set) var workItem: DispatchWorkItem { get }

    /// Initializes a new Debouncer instance.
    ///
    /// - Parameter queue: The dispatch queue to use for executing the debounced action. Defaults to the main queue.
    public init(queue: DispatchQueue = .main)

    /// Executes the given action after the specified time interval, cancelling any previously scheduled action.
    ///
    /// - Parameters:
    ///   - interval: The time interval to wait before executing the action.
    ///   - action: The action to be executed.
    public func execute(interval: TimeInterval, action: @escaping () -> Void)

    /// Executes the given action at the specified dispatch time, cancelling any previously scheduled action.
    ///
    /// - Parameters:
    ///   - deadline: The dispatch time at which to execute the action.
    ///   - action: The action to be executed.
    public func execute(deadline: DispatchTime, action: @escaping () -> Void)

    /// Executes the given action at the specified wall clock time, cancelling any previously scheduled action.
    ///
    /// - Parameters:
    ///   - wallDeadline: The wall clock time at which to execute the action.
    ///   - action: The action to be executed.
    public func execute(wallDeadline: DispatchWallTime, action: @escaping () -> Void)
}
```

### Invocation

```
import ObjectiveC
import Foundation

/// A wrapper for Objective-C `NSInvocation`
public class Invocation {

    /// Get instance method for a Objc class.
    /// - Parameters:
    ///   - selector: Method selector
    ///   - instance: A Class or instance.
    /// - Returns: A signature, actually a `NSMethodSignature` instance.
    public static func instanceMethodSignatureForSelector(_ selector: Selector, of instance: any NSObjectProtocol) -> Any?

    /// Get class method for a Objc class.
    /// - Parameters:
    ///   - selector: Method selector
    ///   - cls: Class type.
    /// - Returns: A signature, actually a `NSMethodSignature` instance.
    public static func classMethodSignatureForSelector(_ selector: Selector, of cls: AnyClass) -> Any?

    /// Initializer
    /// - Parameter signature: Method signature returned from invoking ``Invocation/classMethodSignatureForSelector(_:of:)`` or ``Invocation/instanceMethodSignatureForSelector(_:of:)``
    public init(signature: Any)

    /// Set selector will be invoking.
    public func setSelector(_ selector: Selector)

    /// Set argument for the method.
    /// - Parameters:
    ///   - arg: argument using a inout var as `NSObject`
    ///   - index: usually from 2, 0 is `self`, 1 is `_cmd`
    public func setArgument(_ arg: inout any NSObjectProtocol, atIndex index: Int)

    public func retainArguments()

    public func invoke(withTarget target: Any)

    /// Get return value after invoking.
    /// - Parameter ret: return value using a inout var as `NSObject`
    public func getReturnValue(_ ret: inout Any)
}
```

### Keychain

```
import Security
import Foundation

/// A helper class to interact with the Keychain for storing, retrieving, and deleting key-value pairs securely.
public final class Keychain {

    /// Indicates whether the keychain item should be synchronized to other devices through iCloud.
    public var synchronizable: Bool

    /// Initializes a new instance of Keychain with the specified service and access group.
    /// - Parameters:
    ///   - service: The keychain service identifier. Defaults to the app's bundle identifier.
    ///   - accessGroup: The access group for shared keychain items.
    ///   - synchronizable: synchronize to iCloud or not.
    public init(service: String = Bundle.main.bundleIdentifier ?? "com.reers.keychain", accessGroup: String? = nil, synchronizable: Bool = false)

    /// Stores the provided data in the keychain under the specified key.
    /// - Parameters:
    ///   - value: The data to store in the keychain.
    ///   - key: The key under which to store the data.
    ///   - access: The accessibility level of the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func setData(_ value: Data, forKey key: String, withAccess access: Keychain.Accessibility = .whenUnlocked) -> Keychain.Status

    /// Stores the provided string in the keychain under the specified key.
    /// - Parameters:
    ///   - value: The string to store in the keychain.
    ///   - key: The key under which to store the string.
    ///   - access: The accessibility level of the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func setString(_ value: String, forKey key: String, withAccess access: Keychain.Accessibility = .whenUnlocked) -> Keychain.Status

    /// Retrieves the data stored in the keychain for the specified key.
    /// - Parameter key: The key for which to retrieve the data.
    /// - Returns: A tuple containing the data if found and a status indicating the result of the keychain operation.
    public func getData(_ key: String) -> (data: Data?, status: Keychain.Status)

    /// Retrieves the string stored in the keychain for the specified key.
    /// - Parameter key: The key for which to retrieve the string.
    /// - Returns: A tuple containing the string if found and a status indicating the result of the keychain operation.
    public func getString(_ key: String) -> (string: String?, status: Keychain.Status)

    /// Deletes the keychain item for the specified key.
    /// - Parameter key: The key for which to delete the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func remove(forKey key: String) -> Keychain.Status

    /// Updates the keychain item with the provided data for the specified key.
    /// - Parameters:
    ///   - value: The new data to store in the keychain.
    ///   - key: The key for which to update the keychain item.
    ///   - access: The accessibility level of the keychain item.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func update(_ value: Data, forKey key: String, withAccess access: Keychain.Accessibility = .whenUnlocked) -> Keychain.Status

    /// Retrieves all keys stored in the keychain for the current service.
    /// - Returns: A tuple containing an array of keys and a status indicating the result of the keychain operation.
    public func allKeys() -> (keys: [String], status: Keychain.Status)

    /// Deletes all keychain items for the current service.
    /// - Returns: A status indicating the result of the keychain operation.
    @discardableResult
    public func removeAll() -> Keychain.Status
}

extension Keychain {

    /// Enum representing the accessibility levels for keychain items.
    public enum Accessibility : RawRepresentable {

        /// Item data can only be accessed while the device is unlocked.
        /// This is recommended for items that only need to be accessible while the application is in the foreground.
        /// Items with this attribute will migrate to a new device when using encrypted backups.
        case whenUnlocked

        /// Item data can only be accessed once the device has been unlocked after a restart.
        /// This is recommended for items that need to be accessible by background applications.
        /// Items with this attribute will migrate to a new device when using encrypted backups.
        case afterFirstUnlock

        /// Item data can only be accessed while the device is unlocked.
        /// This class is only available if a passcode is set on the device.
        /// This is recommended for items that only need to be accessible while the application is in the foreground.
        /// Items with this attribute will never migrate to a new device, so after a backup is restored to a new device, these items will be missing.
        /// No items can be stored in this class on devices without a passcode.
        /// Disabling the device passcode will cause all items in this class to be deleted.
        case whenPasscodeSetThisDeviceOnly

        /// Item data can only be accessed while the device is unlocked.
        /// This is recommended for items that only need to be accessible while the application is in the foreground.
        /// Items with this attribute will never migrate to a new device, so after a backup is restored to a new device, these items will be missing.
        case whenUnlockedThisDeviceOnly

        /// Item data can only be accessed once the device has been unlocked after a restart.
        /// This is recommended for items that need to be accessible by background applications.
        /// Items with this attribute will never migrate to a new device, so after a backup is restored to a new device these items will be missing.
        case afterFirstUnlockThisDeviceOnly

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }
}

extension Keychain {

    /// A collection of constants representing keychain attribute keys.
    public struct Attribute {

        /// The service associated with the keychain item.
        public static var service: String { get }

        /// The access group for the keychain item.
        public static var accessGroup: String { get }

        /// The accessibility of the keychain item.
        public static var accessible: String { get }

        /// The account associated with the keychain item.
        public static var account: String { get }

        /// Indicates whether the keychain item is synchronized to other devices through iCloud.
        public static var synchronizable: String { get }

        /// The class of the keychain item.
        public static var `class`: String { get }

        /// A value that indicates the maximum number of results returned.
        public static var matchLimit: String { get }

        /// A Boolean value that indicates whether to return the data from a keychain item.
        public static var returnData: String { get }

        /// The data value of the keychain item.
        public static var valueData: String { get }

        /// A persistent reference to a keychain item.
        public static var returnReference: String { get }

        /// A Boolean value that indicates whether to return a dictionary of attributes for the keychain item.
        public static var returnAttributes: String { get }

        /// A value that specifies that all matching items should be returned.
        public static var matchLimitAll: String { get }
    }
}

extension Keychain {

    /// Enum representing possible status codes returned by keychain APIs.
    public enum Status : OSStatus {

        case success

        case unimplemented

        case diskFull

        case io

        case opWr

        case param

        case wrPerm

        case allocate

        case userCanceled

        case badReq

        case internalComponent

        case notAvailable

        case readOnly

        case authFailed

        case noSuchKeychain

        case invalidKeychain

        case duplicateKeychain

        case duplicateCallback

        case invalidCallback

        case duplicateItem

        case itemNotFound

        case bufferTooSmall

        case dataTooLarge

        case noSuchAttr

        case invalidItemRef

        case invalidSearchRef

        case noSuchClass

        case noDefaultKeychain

        case interactionNotAllowed

        case readOnlyAttr

        case wrongSecVersion

        case keySizeNotAllowed

        case noStorageModule

        case noCertificateModule

        case noPolicyModule

        case interactionRequired

        case dataNotAvailable

        case dataNotModifiable

        case createChainFailed

        case invalidPrefsDomain

        case inDarkWake

        case aclNotSimple

        case policyNotFound

        case invalidTrustSetting

        case noAccessForItem

        case invalidOwnerEdit

        case trustNotAvailable

        case unsupportedFormat

        case unknownFormat

        case keyIsSensitive

        case multiplePrivKeys

        case passphraseRequired

        case invalidPasswordRef

        case invalidTrustSettings

        case noTrustSettings

        case pkcs12VerifyFailure

        case invalidCertificate

        case notSigner

        case policyDenied

        case invalidKey

        case decode

        case `internal`

        case unsupportedAlgorithm

        case unsupportedOperation

        case unsupportedPadding

        case itemInvalidKey

        case itemInvalidKeyType

        case itemInvalidValue

        case itemClassMissing

        case itemMatchUnsupported

        case useItemListUnsupported

        case useKeychainUnsupported

        case useKeychainListUnsupported

        case returnDataUnsupported

        case returnAttributesUnsupported

        case returnRefUnsupported

        case returnPersitentRefUnsupported

        case valueRefUnsupported

        case valuePersistentRefUnsupported

        case returnMissingPointer

        case matchLimitUnsupported

        case itemIllegalQuery

        case waitForCallback

        case missingEntitlement

        case upgradePending

        case mpSignatureInvalid

        case otrTooOld

        case otrIDTooNew

        case serviceNotAvailable

        case insufficientClientID

        case deviceReset

        case deviceFailed

        case appleAddAppACLSubject

        case applePublicKeyIncomplete

        case appleSignatureMismatch

        case appleInvalidKeyStartDate

        case appleInvalidKeyEndDate

        case conversionError

        case appleSSLv2Rollback

        case quotaExceeded

        case fileTooBig

        case invalidDatabaseBlob

        case invalidKeyBlob

        case incompatibleDatabaseBlob

        case incompatibleKeyBlob

        case hostNameMismatch

        case unknownCriticalExtensionFlag

        case noBasicConstraints

        case noBasicConstraintsCA

        case invalidAuthorityKeyID

        case invalidSubjectKeyID

        case invalidKeyUsageForPolicy

        case invalidExtendedKeyUsage

        case invalidIDLinkage

        case pathLengthConstraintExceeded

        case invalidRoot

        case crlExpired

        case crlNotValidYet

        case crlNotFound

        case crlServerDown

        case crlBadURI

        case unknownCertExtension

        case unknownCRLExtension

        case crlNotTrusted

        case crlPolicyFailed

        case idpFailure

        case smimeEmailAddressesNotFound

        case smimeBadExtendedKeyUsage

        case smimeBadKeyUsage

        case smimeKeyUsageNotCritical

        case smimeNoEmailAddress

        case smimeSubjAltNameNotCritical

        case sslBadExtendedKeyUsage

        case ocspBadResponse

        case ocspBadRequest

        case ocspUnavailable

        case ocspStatusUnrecognized

        case endOfData

        case incompleteCertRevocationCheck

        case networkFailure

        case ocspNotTrustedToAnchor

        case recordModified

        case ocspSignatureError

        case ocspNoSigner

        case ocspResponderMalformedReq

        case ocspResponderInternalError

        case ocspResponderTryLater

        case ocspResponderSignatureRequired

        case ocspResponderUnauthorized

        case ocspResponseNonceMismatch

        case codeSigningBadCertChainLength

        case codeSigningNoBasicConstraints

        case codeSigningBadPathLengthConstraint

        case codeSigningNoExtendedKeyUsage

        case codeSigningDevelopment

        case resourceSignBadCertChainLength

        case resourceSignBadExtKeyUsage

        case trustSettingDeny

        case invalidSubjectName

        case unknownQualifiedCertStatement

        case mobileMeRequestQueued

        case mobileMeRequestRedirected

        case mobileMeServerError

        case mobileMeServerNotAvailable

        case mobileMeServerAlreadyExists

        case mobileMeServerServiceErr

        case mobileMeRequestAlreadyPending

        case mobileMeNoRequestPending

        case mobileMeCSRVerifyFailure

        case mobileMeFailedConsistencyCheck

        case notInitialized

        case invalidHandleUsage

        case pvcReferentNotFound

        case functionIntegrityFail

        case internalError

        case memoryError

        case invalidData

        case mdsError

        case invalidPointer

        case selfCheckFailed

        case functionFailed

        case moduleManifestVerifyFailed

        case invalidGUID

        case invalidHandle

        case invalidDBList

        case invalidPassthroughID

        case invalidNetworkAddress

        case crlAlreadySigned

        case invalidNumberOfFields

        case verificationFailure

        case unknownTag

        case invalidSignature

        case invalidName

        case invalidCertificateRef

        case invalidCertificateGroup

        case tagNotFound

        case invalidQuery

        case invalidValue

        case callbackFailed

        case aclDeleteFailed

        case aclReplaceFailed

        case aclAddFailed

        case aclChangeFailed

        case invalidAccessCredentials

        case invalidRecord

        case invalidACL

        case invalidSampleValue

        case incompatibleVersion

        case privilegeNotGranted

        case invalidScope

        case pvcAlreadyConfigured

        case invalidPVC

        case emmLoadFailed

        case emmUnloadFailed

        case addinLoadFailed

        case invalidKeyRef

        case invalidKeyHierarchy

        case addinUnloadFailed

        case libraryReferenceNotFound

        case invalidAddinFunctionTable

        case invalidServiceMask

        case moduleNotLoaded

        case invalidSubServiceID

        case attributeNotInContext

        case moduleManagerInitializeFailed

        case moduleManagerNotFound

        case eventNotificationCallbackNotFound

        case inputLengthError

        case outputLengthError

        case privilegeNotSupported

        case deviceError

        case attachHandleBusy

        case notLoggedIn

        case algorithmMismatch

        case keyUsageIncorrect

        case keyBlobTypeIncorrect

        case keyHeaderInconsistent

        case unsupportedKeyFormat

        case unsupportedKeySize

        case invalidKeyUsageMask

        case unsupportedKeyUsageMask

        case invalidKeyAttributeMask

        case unsupportedKeyAttributeMask

        case invalidKeyLabel

        case unsupportedKeyLabel

        case invalidKeyFormat

        case unsupportedVectorOfBuffers

        case invalidInputVector

        case invalidOutputVector

        case invalidContext

        case invalidAlgorithm

        case invalidAttributeKey

        case missingAttributeKey

        case invalidAttributeInitVector

        case missingAttributeInitVector

        case invalidAttributeSalt

        case missingAttributeSalt

        case invalidAttributePadding

        case missingAttributePadding

        case invalidAttributeRandom

        case missingAttributeRandom

        case invalidAttributeSeed

        case missingAttributeSeed

        case invalidAttributePassphrase

        case missingAttributePassphrase

        case invalidAttributeKeyLength

        case missingAttributeKeyLength

        case invalidAttributeBlockSize

        case missingAttributeBlockSize

        case invalidAttributeOutputSize

        case missingAttributeOutputSize

        case invalidAttributeRounds

        case missingAttributeRounds

        case invalidAlgorithmParms

        case missingAlgorithmParms

        case invalidAttributeLabel

        case missingAttributeLabel

        case invalidAttributeKeyType

        case missingAttributeKeyType

        case invalidAttributeMode

        case missingAttributeMode

        case invalidAttributeEffectiveBits

        case missingAttributeEffectiveBits

        case invalidAttributeStartDate

        case missingAttributeStartDate

        case invalidAttributeEndDate

        case missingAttributeEndDate

        case invalidAttributeVersion

        case missingAttributeVersion

        case invalidAttributePrime

        case missingAttributePrime

        case invalidAttributeBase

        case missingAttributeBase

        case invalidAttributeSubprime

        case missingAttributeSubprime

        case invalidAttributeIterationCount

        case missingAttributeIterationCount

        case invalidAttributeDLDBHandle

        case missingAttributeDLDBHandle

        case invalidAttributeAccessCredentials

        case missingAttributeAccessCredentials

        case invalidAttributePublicKeyFormat

        case missingAttributePublicKeyFormat

        case invalidAttributePrivateKeyFormat

        case missingAttributePrivateKeyFormat

        case invalidAttributeSymmetricKeyFormat

        case missingAttributeSymmetricKeyFormat

        case invalidAttributeWrappedKeyFormat

        case missingAttributeWrappedKeyFormat

        case stagedOperationInProgress

        case stagedOperationNotStarted

        case verifyFailed

        case querySizeUnknown

        case blockSizeMismatch

        case publicKeyInconsistent

        case deviceVerifyFailed

        case invalidLoginName

        case alreadyLoggedIn

        case invalidDigestAlgorithm

        case invalidCRLGroup

        case certificateCannotOperate

        case certificateExpired

        case certificateNotValidYet

        case certificateRevoked

        case certificateSuspended

        case insufficientCredentials

        case invalidAction

        case invalidAuthority

        case verifyActionFailed

        case invalidCertAuthority

        case invalidCRLAuthority

        case invalidCRLEncoding

        case invalidCRLType

        case invalidCRL

        case invalidFormType

        case invalidID

        case invalidIdentifier

        case invalidIndex

        case invalidPolicyIdentifiers

        case invalidTimeString

        case invalidReason

        case invalidRequestInputs

        case invalidResponseVector

        case invalidStopOnPolicy

        case invalidTuple

        case multipleValuesUnsupported

        case notTrusted

        case noDefaultAuthority

        case rejectedForm

        case requestLost

        case requestRejected

        case unsupportedAddressType

        case unsupportedService

        case invalidTupleGroup

        case invalidBaseACLs

        case invalidTupleCredendtials

        case invalidEncoding

        case invalidValidityPeriod

        case invalidRequestor

        case requestDescriptor

        case invalidBundleInfo

        case invalidCRLIndex

        case noFieldValues

        case unsupportedFieldFormat

        case unsupportedIndexInfo

        case unsupportedLocality

        case unsupportedNumAttributes

        case unsupportedNumIndexes

        case unsupportedNumRecordTypes

        case fieldSpecifiedMultiple

        case incompatibleFieldFormat

        case invalidParsingModule

        case databaseLocked

        case datastoreIsOpen

        case missingValue

        case unsupportedQueryLimits

        case unsupportedNumSelectionPreds

        case unsupportedOperator

        case invalidDBLocation

        case invalidAccessRequest

        case invalidIndexInfo

        case invalidNewOwner

        case invalidModifyMode

        case missingRequiredExtension

        case extendedKeyUsageNotCritical

        case timestampMissing

        case timestampInvalid

        case timestampNotTrusted

        case timestampServiceNotAvailable

        case timestampBadAlg

        case timestampBadRequest

        case timestampBadDataFormat

        case timestampTimeNotAvailable

        case timestampUnacceptedPolicy

        case timestampUnacceptedExtension

        case timestampAddInfoNotAvailable

        case timestampSystemFailure

        case signingTimeMissing

        case timestampRejection

        case timestampWaiting

        case timestampRevocationWarning

        case timestampRevocationNotification

        case unexpectedError
    }
}

extension Keychain.Status : RawRepresentable {

    /// Initializes a Keychain.Status from an OSStatus code.
    /// - Parameter status: The OSStatus code.
    public init(status: OSStatus)
}
```

### Reachability

```
import Foundation
import SystemConfiguration
import Dispatch

/// The ``Reachability`` class listens for reachability changes of hosts and addresses for both cellular and
/// WiFi network interfaces.
///
/// Reachability can be used to determine background information about why a network operation failed, or to retry
/// network requests when a connection is established. It should not be used to prevent a user from initiating a network
/// request, as it's possible that an initial request may be required to establish reachability.
open class Reachability {

    /// Defines the various states of network reachability.
    public enum Status {

        /// It is unknown whether the network is reachable.
        case unknown

        /// The network is not reachable.
        case none

        /// The network is reachable on the associated `ConnectionType`.
        case reachable(ConnectionType)

        internal init(_ flags: SCNetworkReachabilityFlags)
    }

    /// Defines the various connection types detected by reachability flags.
    public enum ConnectionType {

        /// The connection type is either over Ethernet or WiFi.
        case ethernetOrWiFi

        /// The connection type is a cellular connection.
        case cellular
    }

    /// A closure executed when the network reachability status changes. The closure takes a single argument: the
    /// network reachability status.
    public typealias OnChangedCallback = (Status) -> Void

    /// Default ``Reachability`` for the zero address and a `callbackQueue` of `.main`.
    public static let `default`: Reachability.Reachability?

    /// Whether the network is currently reachable.
    open var isReachable: Bool { get }

    /// Whether the network is currently reachable over the cellular interface.
    ///
    /// - Note: Using this property to decide whether to make a high or low bandwidth request is not recommended.
    ///         Instead, set the `allowsCellularAccess` on any `URLRequest`s being issued.
    ///
    open var isReachableOnCellular: Bool { get }

    /// Whether the network is currently reachable over Ethernet or WiFi interface.
    open var isReachableOnEthernetOrWiFi: Bool { get }

    /// `DispatchQueue` on which reachability will update.
    public let reachabilityQueue: DispatchQueue

    /// Flags of the current reachability type, if any.
    open var flags: SCNetworkReachabilityFlags? { get }

    /// The current network reachability status.
    open var status: Status { get }

    /// Creates an instance with the specified host.
    ///
    /// - Note: The `host` value must *not* contain a scheme, just the hostname.
    ///
    /// - Parameters:
    ///   - host:          Host used to evaluate network reachability. Must *not* include the scheme (e.g. `https`).
    public convenience init?(host: String)

    /// Creates an instance that monitors the address 0.0.0.0.
    ///
    /// Reachability treats the 0.0.0.0 address as a special token that causes it to monitor the general routing
    /// status of the device, both IPv4 and IPv6.
    public convenience init?()

    /// Starts listening for changes in network reachability status.
    ///
    /// - Note: Stops and removes any existing listener.
    ///
    /// - Parameters:
    ///   - queue:    `DispatchQueue` on which to call the `callback` closure. `.main` by default.
    ///   - callback: `OnChangedCallback` closure called when reachability changes.
    ///
    /// - Returns: `true` if listening was started successfully, `false` otherwise.
    @discardableResult
    open func startListening(onQueue queue: DispatchQueue = .main, onChanged callback: @escaping OnChangedCallback) -> Bool

    /// Stops listening for changes in network reachability status.
    open func stopListening()

    /// Calls the `callback` closure of the `callbackQueue` if the computed status hasn't changed.
    ///
    /// - Note: Should only be called from the `reachabilityQueue`.
    ///
    /// - Parameter flags: `SCNetworkReachabilityFlags` to use to calculate the status.
    internal func notifyWhenChanged(_ flags: SCNetworkReachabilityFlags)
}

extension Reachability.Status : Equatable {
}
```

### TypeNameDescribable

```
import Foundation

/// Return type name of an instance or a type, using by conforming this protocol.
public protocol TypeNameDescribable {

    var typeName: String { get }

    static var typeName: String { get }

    var fullTypeName: String { get }

    static var fullTypeName: String { get }
}

extension TypeNameDescribable {

    /// Return type name of an instance without module name prefix.
    ///
    ///     ModuleA.Foo().typeName -> "Foo"
    public var typeName: String { get }

    /// Return type name of a type without module name prefix.
    ///
    ///     ModuleA.Foo.typeName -> "Foo"
    public static var typeName: String { get }

    /// Return full type name of a type with module name prefix.
    /// But if the instance is an objective-c class object, it still return a name without module name prefix.
    ///
    ///     ModuleA.Foo().typeName -> "ModuleA.Foo"
    public var fullTypeName: String { get }

    /// Return full type name of a type with module name prefix.
    /// But if the type is an objective-c class, it still return a name without module name prefix.
    ///
    ///     ModuleA.Foo().typeName -> "ModuleA.Foo"
    public static var fullTypeName: String { get }
}
/// Get module name from a swift file ID.
/// - Parameter fileId: No need to pass it, just use the default.
/// - Returns: Module name, return `""` if failed.
public func moduleName(fileId: String = #fileID) -> String
```

### Vibrator

```
import UIKit

public struct Vibrator {

    public enum FeedbackStyle : Int {

        case light

        case medium

        case heavy

        case soft

        case rigid

        case selectionChanged

        case success

        case warning

        case error
    }

    public static func occur(_ style: FeedbackStyle, intensity: CGFloat = 1.0)
}
```

### Memory

```
import Darwin

public enum MemoryAlign : Int {

    case one, two, four, eight
}

public enum StringMemoryType : UInt8 {

    case text

    case taggedPointer

    case heap

    case unknow
}



/// ReerKit: Utilities for checking memory structure.
public struct Memory<T> {

    /// ReerKit: Get memory data for the variable in byte array format
    public static func bytes(ofVal v: inout T) -> [UInt8]

    /// ReerKit: Get the memory data pointed to by the reference in byte array format.
    public static func bytes(ofRef v: T) -> [UInt8]

    /// ReerKit: Get memory data for the variable in string format
    /// 
    /// - Parameter alignment: Represent how many bytes are grouped together
    /// - Parameter v: The value type value.
    /// - Returns: Get memory data.
    public static func string(ofVal v: inout T, alignment: MemoryAlign? = nil) -> String

    /// ReerKit: Get the memory data pointed to by the reference in string format
    ///
    /// - Parameter alignment: Represent how many bytes are grouped together
    /// - Parameter v: The reference type value
    /// - Returns: Get memory data.
    public static func string(ofRef v: T, alignment: MemoryAlign? = nil) -> String

    /// ReerKit: Get the memory address of the variable
    public static func pointer(ofVal v: inout T) -> UnsafeRawPointer

    /// ReerKit: Get the address of the memory pointed to by the reference
    public static func pointer(ofRef v: T) -> UnsafeRawPointer

    /// ReerKit: Get the memory size occupied by the variable
    public static func size(ofVal v: inout T) -> Int

    /// ReerKit: Get the size of the memory pointed to by the reference
    public static func size(ofRef v: T) -> Int
}

public extension ReerReference where Base == String {

    public mutating func memoryType() -> StringMemoryType
}
```

### MulticastDelegate

```
public protocol MulticastDelegateProtocol {

    associatedtype Delegate

    func add(delegate: Delegate)

    func remove(delegate: Delegate)

    func removeAllDelegates()
}

/// `MulticastDelegate` lets you easily create a "multicast delegate" for a given protocol or class.
/// The delegate will be a weak reference in `MulticastDelegate`, and will be removed automatically
/// from `delegates` after it released.
public final class MulticastDelegate<T> {

    /// ReerKit: Initialize a new `MulticastDelegate`, and delete references will be weak.
    public init()

    /// ReerKit: Use the property to check if no delegates are contained there.
    public var isEmpty: Bool { get }

    /// ReerKit: Add a delegate.
    public func add(_ delegate: T)

    /// ReerKit: Remove a previously-added delegate.
    public func remove(_ delegate: T)

    public func removeAllDelegates()

    @available(*, deprecated, renamed: "notify(_:)", message: "Use notify(_:) instead.")
    public func invoke(_ invocation: (T) -> Void)

    /// ReerKit: Notify a closure on each delegate.
    public func notify(_ function: (T) -> Void)

    /// ReerKit: Checks if the multicast delegate contains the given delegate.
    public func contains(_ delegate: T) -> Bool
}
```

### NanoID

```
import Security

public struct NanoID {

    /// Generate a new identifier
    ///
    /// - Parameters:
    ///   - alphabet: alphabet to use, exclude to use instance default
    ///   - size: size to use, exclude to use instance default
    ///   - randomizer: randomizer to use, exclude to use instance default
    public static func generate(alphabet: Alphabet = .default, size: UInt = 21, randomizer: Randomizer = defaultRandomizer) -> String

    public static var defaultRandomizer: Randomizer
}

extension NanoID {

    public struct Alphabet {

        public var size: Int { get }

        /// ReerKit: Initializes an alphabet given one or more strings
        /// - Parameter alphabet: Strings to build the alphabet from
        public init(_ alphabet: String...)

        /// Returns a single character from the alphabet
        ///
        /// - Parameter index: The position of the character to return
        public func character(at index: Int) -> Character

        /// Returns a single character from the alphabet given a byte
        ///
        /// - Parameter byte: The byte used to determine the character's position
        public func character(from byte: UInt8) -> Character

        public static let numbers: NanoID.NanoID.Alphabet

        public static let lowercaseLetters: NanoID.NanoID.Alphabet

        public static let uppercaseLetters: NanoID.NanoID.Alphabet

        public static let letters: NanoID.NanoID.Alphabet

        public static let `default`: NanoID.NanoID.Alphabet
    }
}

public protocol Randomizer {

    func getCharacters(count: UInt, from alphabet: NanoID.Alphabet) -> [Character]
}

public struct SecureRandomizer : Randomizer {

    public func getCharacters(count: UInt, from alphabet: NanoID.Alphabet) -> [Character]
}

public struct IntRandomizer : Randomizer {

    public func getCharacters(count: UInt, from alphabet: NanoID.Alphabet) -> [Character]
}
```

### KeyboardManager

```
import UIKit
import ObjectiveC
import CoreFoundation

/// The protocol defines the method you can use
/// to receive system keyboard change information.
public protocol KeyboardObserver : AnyObject {

    func keyboardChanged(with transition: KeyboardTransition)
}

/// System keyboard transition information.
/// Use `convert(rect:toView:)` to convert frame to specified view.
public struct KeyboardTransition {

    public var toHidden: Bool

    public var toVisible: Bool

    public var fromFrame: CGRect

    public var toFrame: CGRect

    public var animationDuration: TimeInterval

    public var animationCurve: UIView.AnimationCurve

    public var animationOption: UIView.AnimationOptions
}

/// A KeyboardManager object lets you get the system keyboard information,
/// and track the keyboard visible/frame/transition.
///
/// You should access this class in main thread and add observer before keyboard will show.
public final class KeyboardManager : NSObject {

    public static let shared: KeyboardManager.KeyboardManager

    /// Get the keyboard window. nil if there's no keyboard window.
    public var keyboardWindow: UIWindow? { get }

    /// Get the keyboard view. nil if there's no keyboard view.
    public var keyboardView: UIView? { get }

    /// Whether the keyboard is visible.
    public var isKeyboardVisible: Bool { get }

    /// Get the keyboard frame. CGRect.null if there's no keyboard view.
    /// Use convert(rect:toView:) to convert frame to specified view.
    public var keyboardFrame: CGRect { get }

    /// Add an observer to manager to get keyboard change information.
    /// This method makes a weak reference to the observer.
    public func addObserver(_ observer: KeyboardObserver)

    /// Remove an observer from manager.
    /// No need to remove observer in `deinit` method, ``KeyboardManager`` will remove observer automatically.
    public func removeObserver(_ observer: KeyboardObserver)

    public func convertRect(_ rect: CGRect, toView view: UIView?) -> CGRect
}
```

## StandardLibrary+REExtensions

### AnyObjectExtensionable

#### Associatable

```
import ObjectiveC

/// The ability to use the convenient association functions.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol Associatable {
}

/// ReerKit: Policies related to associative references.
public enum AssociationPolicy {

    /// Specifies a weak reference to the associated object.
    case assign

    /// Specifies a strong reference to the associated object.
    /// The association is not made atomically.
    case retain

    /// Specifies that the associated object is copied.
    /// The association is not made atomically.
    case copy

    /// Specifies a strong reference to the associated object.
    /// The association is made atomically.
    case retainAtomic

    /// Specifies that the associated object is copied.
    /// The association is made atomically.
    case copyAtomic
}


public struct AssociationKey {

    /// ReerKit: Create an ObjC association key.
    ///
    /// - warning: The key must be uniqued.
    public init()

    /// ReerKit: Create an ObjC association key from a `StaticString`.
    ///
    ///     let key1 = AssociationKey("SomeString" as StaticString)
    ///     let key2 = AssociationKey(#function as StaticString)
    ///
    /// - precondition: `key` has a pointer representation.
    public init(_ key: StaticString)

    /// ReerKit: Create an ObjC association key from a `Selector`.
    ///
    ///     @objc var foo: String {
    ///         get {
    ///             re.associatedValue(forKey: AssociationKey(#selector(getter: self.foo)), default: "23")
    ///         }
    ///     }
    ///
    /// - Parameter key: An @objc function or computed property selector.
    public init(_ key: Selector)
}

public extension Reer where Base: AnyObject {

    /// ReerKit: Sets an associated value for self using a given key and association policy.
    ///
    ///     let obj = NSObject()
    ///     let key = AssociationKey("bar" as StaticString)
    ///     obj.re.setAssociatedValue(123, forKey: key)
    ///
    /// - Parameters:
    ///   - value: The source value for the association.
    ///   - key: The key for the association.
    ///   - policy: The policy for the association. For possible values, see `AssociationPolicy`
    public func setAssociatedValue(_ value: Any?, forKey key: AssociationKey, withPolicy policy: AssociationPolicy = .retain)

    /// ReerKit: Returns the value associated on self for a given key.
    ///
    ///     let value: Int? = obj.re.associatedValue(forKey: key)
    ///
    /// - Parameter key: The key for the association.
    /// - Returns: The value associated with the key.
    public func associatedValue<Value>(forKey key: AssociationKey) -> Value?

    /// ReerKit: Returns the value associated on self for a given key.
    ///
    ///     let value = obj.re.associatedValue(forKey: key, default: 123)
    ///
    /// - Parameters:
    ///   - key: The key for the association.
    ///   - default: Default value for the result.
    /// - Returns: The value associated with the key.
    public func associatedValue<Value>(forKey key: AssociationKey, default: Value) -> Value

    /// ReerKit: Sets an associated weak object for self using a given key.
    ///
    ///     let obj = NSObject()
    ///     let key = AssociationKey("bar" as StaticString)
    ///     obj.re.setAssociatedWeakObject(NSObject(), forKey: key)
    ///     let value: Int? = obj.re.associatedValue(forKey: key)
    ///
    /// - Parameters:
    ///   - object: The source object for the association.
    ///   - key: The key for the association.
    public func setAssociatedWeakObject<Object>(_ object: Object, forKey key: AssociationKey) where Object : AnyObject

    /// ReerKit: Returns the weak object associated on self for a given key.
    ///
    ///     let obj = obj.re.associatedWeakObject(forKey: key) as NSObject?
    ///
    /// - Parameters:
    ///   - key: The key for the association.
    /// - Returns: The object associated with the key.
    public func associatedWeakObject<Object>(forKey key: AssociationKey) -> Object? where Object : AnyObject
}
```

#### DeinitObservable

```
/// The ability to observe AnyObject deinit.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol DeinitObservable: ReerCompatible {}
public extension Reer where Base: AnyObject {
    func onDeinit(perform action: @escaping () -> Void)
}
```

#### OnceExecutable

```
/// The ability to execute a closure once.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol OnceExecutable: ReerCompatible {}

public typealias OnceKey = AssociationKey

public extension Reer where Base: AnyObject {

    /// ReerKit: Execute the passed closure once by a key during the object life time.
    ///
    ///     let obj = NSObject()
    ///     func test() {
    ///         obj.re.executeOnce(byKey: key) { print("once") }
    ///     }
    ///     test()
    ///     test()
    ///     obj.re.executeOnce(byKey: key) { print("once") }
    ///     // output: once
    @discardableResult
    public func executeOnce<Result>(byKey key: OnceKey, _ execute: @escaping () throws -> Result) rethrows -> Result

    /// ReerKit: Execute the passed closure once by a auto generated key during the object life time.
    ///
    ///     let obj = NSObject()
    ///     func test() {
    ///         obj.re.executeOnce { print("once") }
    ///     }
    ///     test()
    ///     test()
    ///     // output: once
    @discardableResult
    public func executeOnce<Result>(fileID: String = #fileID, function: String = #function, line: Int = #line, _ execute: @escaping () throws -> Result) rethrows -> Result
}
```

#### Swizzlable

```
import ObjectiveC

/// The ability to swizzle method conveniently.
/// You must conform this protocol by yourself if your class is NOT inheriting from `NSObject`.
public protocol Swizzlable: ReerCompatible {}

public extension Reer where Base: AnyObject {

    /// ReerKit: Swizzle instance method of the class.
    /// Also you can use ability from Swift, see `@_dynamicReplacement(for: )`
    ///
    /// - Parameters:
    ///   - originalSelector: The selector must be a `@objc dynamic` method.
    ///   - swizzledSelector: The selector must be a `@objc` method.
    /// - Returns: Successful or not.
    @discardableResult
    public static func swizzleInstanceMethod(_ originalSelector: Selector, with swizzledSelector: Selector) -> Bool

    /// ReerKit: Swizzle class method of the class.
    /// Also you can use ability from Swift, see `@_dynamicReplacement(for: )`
    ///
    /// - Parameters:
    ///   - originalSelector: The selector must be a `@objc dynamic` method.
    ///   - swizzledSelector: The selector must be a `@objc` method.
    /// - Returns: Successful or not.
    @discardableResult
    public static func swizzleClassMethod(_ originalSelector: Selector, with swizzledSelector: Selector) -> Bool
}
```

### Array+REExtensions

```
import Foundation

extension Array: ReerReferenceGenericCompatible {
    public typealias T = Element
}

public extension ReerReferenceGeneric where Base == Array<T> {

    /// ReerKit: Insert an element at the beginning of array.
    ///
    ///     var array = [2, 3, 4, 5]
    ///     array.re.prepend(1) -> [1, 2, 3, 4, 5]
    ///
    /// - Parameter newElement: element to insert.
    public mutating func prepend(_ newElement: T)

    /// ReerKit: Safely swap values at given index positions.
    ///
    ///     var array = [1, 2, 3, 4, 5]
    ///     array.re.swapAt(3, 0) -> [4, 2, 3, 1, 5]
    ///     array.re.swapAt(3, 10) -> [1, 2, 3, 4, 5]
    ///
    /// - Parameters:
    ///   - index: index of first element.
    ///   - otherIndex: index of other element.
    public mutating func swapAt(_ index: Base.Index, _ otherIndex: Base.Index)
}

public extension ReerReferenceGeneric where Base == Array<T>, T: Equatable {

    /// ReerKit: Appends a new element to the array only if it doesn't already exist
    /// - Parameter newElement: The element to append
    /// - Complexity: O(n), where n is the length of the array
    public mutating func appendIfNotExist(_ newElement: T)

    /// ReerKit: Appends multiple elements to the array, excluding any duplicates
    /// - Parameter newElements: An array of elements to append
    /// - Complexity: O(n*m), where n is the length of the current array
    ///   and m is the length of newElements
    public mutating func appendIfNotExist(contentsOf newElements: [T])

    /// ReerKit: Remove all instances of an item from array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removeAll(2) -> [1, 3, 4, 5]
    ///        ["h", "e", "l", "l", "o"].re.removeAll("l") -> ["h", "e", "o"]
    ///
    /// - Parameter item: item to remove.
    /// - Returns: self after removing all instances of item.
    @discardableResult
    public mutating func removeAll(_ item: T) -> [T]

    /// ReerKit: Remove all instances contained in items parameter from array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removeAll([2,5]) -> [1, 3, 4]
    ///        ["h", "e", "l", "l", "o"].re.removeAll(["l", "h"]) -> ["e", "o"]
    ///
    /// - Parameter items: items to remove.
    /// - Returns: self after removing all instances of all items in given array.
    @discardableResult
    public mutating func removeAll(_ items: [T]) -> [T]

    /// ReerKit: Remove all duplicate elements from Array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removeDuplicates() -> [1, 2, 3, 4, 5]
    ///        ["h", "e", "l", "l", "o"].re.removeDuplicates() -> ["h", "e", "l", "o"]
    ///
    /// - Returns: Return array with all duplicate elements removed.
    @discardableResult
    public mutating func removeDuplicates() -> [T]
}

extension Array: ReerGenericCompatible {}

public extension ReerGeneric where Base == Array<T>, T: Equatable {

    /// ReerKit: Removing all duplicate elements from Array.
    ///
    ///        [1, 2, 2, 3, 4, 5].re.removingDuplicates() -> [1, 2, 3, 4, 5]
    ///        ["h", "e", "l", "l", "o"].re.removingDuplicates() -> ["h", "e", "l", "o"]
    ///
    /// - Returns: Return array with all duplicate elements removed.
    public func removingDuplicates() -> [T]

    /// ReerKit: Returns an array with all duplicate elements removed using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Equatable.
    /// - Returns: an array of unique elements.
    public func removingDuplicates<U>(byKeyPath path: KeyPath<T, U>) -> [T] where U : Equatable

    /// ReerKit: Returns an array with all duplicate elements removed using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Hashable.
    /// - Returns: an array of unique elements.
    public func removingDuplicates<U>(byKeyPath path: KeyPath<T, U>) -> [T] where U : Hashable
}

public extension ReerGeneric where Base == Array<T> {

    /// ReerKit: JSON Data from array.
    ///
    /// - Parameter prettify: set true to prettify data (default is false).
    /// - Returns: optional JSON Data (if applicable).
    public func jsonData(prettify: Bool = false) -> Data?

    /// ReerKit: JSON String from array.
    ///
    ///        array.re.jsonString() -> "[{\"abc\":123}]"
    ///
    /// - Parameter prettify: set true to prettify string (default is false).
    /// - Returns: optional JSON String (if applicable).
    public func jsonString(prettify: Bool = false) -> String?
}
```

### BinaryFloatingPoint

```
import Foundation

public extension Reer where Base: BinaryFloatingPoint {

    /// ReerKit: Returns a rounded value with the specified number of decimal places and rounding rule. If `numberOfDecimalPlaces` is negative, `0` will be used.
    ///
    ///     let num = 3.1415927
    ///     num.re.rounded(3, rule: .up) -> 3.142
    ///     num.re.rounded(3, rule: .down) -> 3.141
    ///     num.re.rounded(2, rule: .awayFromZero) -> 3.15
    ///     num.re.rounded(4, rule: .towardZero) -> 3.1415
    ///     num.re.rounded(-1, rule: .toNearestOrEven) -> 3
    ///
    /// - Parameters:
    ///   - numberOfDecimalPlaces: The expected number of decimal places.
    ///   - rule: The rounding rule to use.
    /// - Returns: The rounded value.
    public func rounded(_ numberOfDecimalPlaces: Int, rule: FloatingPointRoundingRule = .toNearestOrAwayFromZero) -> Base
}
```

### BinaryInteger

```
public extension Reer where Base: BinaryInteger {

    /// ReetKit: The raw bytes of the integer.
    ///
    ///     var number = Int16(-128)
    ///     print(number.re.bytes)
    ///     // prints "[255, 128]"
    ///
    public var bytes: [UInt8] { get }
}

public extension BinaryInteger {

    /// ReetKit: Creates a `BinaryInteger` from a raw byte representaion.
    ///
    ///     var number = Int16.re(bytes: [0xFF, 0b1111_1101])
    ///     print(number!)
    ///     // prints "-3"
    ///
    /// - Parameter bytes: An array of bytes representing the value of the integer.
    ///
    public static func re(bytes: [UInt8]) -> Self?
}
```

### Bool

```
extension Bool: ReerCompatibleValue {}
public extension Reer where Base == Bool {

    /// ReerKit: Return 1 if true, or 0 if false.
    ///
    ///     false.re.int -> 0
    ///     true.re.int -> 1
    ///
    public var int: Int { get }

    /// ReerKit: Return "true" if true, or "false" if false.
    ///
    ///     false.re.string -> "false"
    ///     true.re.string -> "true"
    ///
    public var string: String { get }
}
```

### Character

```
extension Character: ReerCompatibleValue {}
public extension Reer where Base == Character {

    /// ReerKit: Check if character is emoji.
    ///
    ///     Character("😀").re.isEmoji -> true
    ///
    public var isEmoji: Bool { get }

    /// ReerKit: Integer from character (if applicable).
    ///
    ///     Character("1").re.int -> 1
    ///     Character("A").re.int -> nil
    ///
    public var int: Int? { get }

    /// ReerKit: String from character.
    ///
    ///     Character("a").re.string -> "a"
    ///
    public var string: String { get }

    /// ReerKit: Return the character lowercased.
    ///
    ///     Character("A").re.lowercased -> Character("a")
    ///
    public var lowercased: Character { get }

    /// ReerKit: Return the character uppercased.
    ///
    ///     Character("a").re.uppercased -> Character("A")
    ///
    public var uppercased: Character { get }
}

public extension Reer where Base == Character {

    /// ReerKit: Random character.
    ///
    ///    Character.re.random() -> k
    ///
    /// - Returns: A random character.
    public static func randomAlphanumeric() -> Character
}
```

### Collection

```
import Dispatch

public extension Reer where Base: Collection {

    /// ReerKit: The full range of the collection.
    public var fullRange: Range<Base.Index> { get }
}

public extension Reer where Base: Collection {

    /// ReerKit: Performs `each` closure for each element of collection in parallel.
    ///
    ///        array.re.forEachInParallel { item in
    ///            print(item)
    ///        }
    ///
    /// - Parameter each: closure to run for each element.
    public func forEachInParallel(_ each: (Base.Element) -> Void)

    /// ReerKit: Safe protects the array from out of bounds by use of optional.
    ///
    ///        let arr = [1, 2, 3, 4, 5]
    ///        arr.re[1] -> 2
    ///        arr.re[10] -> nil
    ///
    /// - Parameter index: index of element to access element.
    public subscript(index: Base.Index) -> Base.Element? { get }

    /// ReerKit: Returns an array of slices of length "size" from the array. If array can't be split evenly, the final slice will be the remaining elements.
    ///
    ///     [0, 2, 4, 7].re.group(by: 2) -> [[0, 2], [4, 7]]
    ///     [0, 2, 4, 7, 6].re.group(by: 2) -> [[0, 2], [4, 7], [6]]
    ///
    /// - Parameter size: The size of the slices to be returned.
    /// - Returns: grouped self.
    public func group(by size: Int) -> [[Base.Element]]?

    /// ReerKit: Get all indices where condition is met.
    ///
    ///     [1, 7, 1, 2, 4, 1, 8].re.indices(where: { $0 == 1 }) -> [0, 2, 5]
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: all indices where the specified condition evaluates to true (optional).
    public func indices(where condition: (Base.Element) throws -> Bool) rethrows -> [Base.Index]?

    /// ReerKit: Calls the given closure with an array of size of the parameter slice.
    ///
    ///     [0, 2, 4, 7].re.forEach(slice: 2) { print($0) } -> // print: [0, 2], [4, 7]
    ///     [0, 2, 4, 7, 6].re.forEach(slice: 2) { print($0) } -> // print: [0, 2], [4, 7], [6]
    ///
    /// - Parameters:
    ///   - slice: size of array in each interation.
    ///   - body: a closure that takes an array of slice size as a parameter.
    public func forEach(slice: Int, body: ([Base.Element]) throws -> Void) rethrows

    public func forEach(_ body: (Base.Element, Int) throws -> Void) rethrows
}

public extension Reer where Base: Collection, Base.Element: Equatable {

    /// ReerKit: All indices of specified item.
    ///
    ///        [1, 2, 2, 3, 4, 2, 5].re.indices(of 2) -> [1, 2, 5]
    ///        [1.2, 2.3, 4.5, 3.4, 4.5].re.indices(of 2.3) -> [1]
    ///        ["h", "e", "l", "l", "o"].re.indices(of "l") -> [2, 3]
    ///
    /// - Parameter item: item to check.
    /// - Returns: an array with all indices of the given item.
    public func indices(of item: Base.Element) -> [Base.Index]
}

public extension Reer where Base: Collection, Base.Element: BinaryInteger {

    /// ReerKit: Average of all elements in array.
    ///
    /// - Returns: the average of the array's elements.
    public func average() -> Double
}

public extension Reer where Base: Collection, Base.Element: FloatingPoint {

    /// ReerKit: Average of all elements in array.
    ///
    ///        [1.2, 2.3, 4.5, 3.4, 4.5].re.average() = 3.18
    ///
    /// - Returns: average of the array's elements.
    public func average() -> Base.Element
}
```

### Comparable

```
public extension ReerForEquatable where Base: Comparable {

    /// ReetKit: Returns true if value is in the provided range.
    ///
    ///     1.re.isBetween(5...7) // false
    ///     7.re.isBetween(6...12) // true
    ///     date.re.isBetween(date1...date2)
    ///     "c".re.isBetween(a...d) // true
    ///     0.32.re.isBetween(0.31...0.33) // true
    ///
    /// - Parameter range: Closed range against which the value is checked to be included.
    /// - Returns: `true` if the value is included in the range, `false` otherwise.
    public func isBetween(_ range: ClosedRange<Base>) -> Bool

    /// ReetKit: Returns value limited within the provided range.
    ///
    ///     1.re.clamped(to: 3...8) // 3
    ///     4.re.clamped(to: 3...7) // 4
    ///     "c".re.clamped(to: "e"..."g") // "e"
    ///     0.32.re.clamped(to: 0.1...0.29) // 0.29
    ///
    /// - Parameter range: Closed range that limits the value.
    /// - Returns: A value limited to the range, i.e. between `range.lowerBound` and `range.upperBound`.
    public func clamped(to range: ClosedRange<Base>) -> Base
}
```

### Decodable

```
import Foundation

public extension Decodable {

    /// ReerKit: Parsing the model in Decodable type.
    /// - Parameters:
    ///   - data: Data.
    ///   - decoder: JSONDecoder. Initialized by default.
    public static func re(data: Data, using decoder: JSONDecoder = .init()) -> Self?
}
```

### Dictionary

```
import Foundation

public protocol DMLDictionary : Collection {

    associatedtype Key : ExpressibleByStringLiteral, Hashable

    associatedtype Value

    func value(forKey key: Key) -> Value?
}

extension Dictionary : DMLDictionary where Key : ExpressibleByStringLiteral {

    public typealias Key = Key

    public typealias Value = Value

    public func value(forKey key: Key) -> Value?
}

@dynamicMemberLookup public struct DML<Base> where Base : main.DMLDictionary {

    public init(_ base: Base)

    public subscript(dynamicMember member: Base.Key) -> Base.Value? { get }
}

public extension Dictionary where Key : ExpressibleByStringLiteral {

    public var dml: DML<`Self`> { get set }
}

extension Dictionary : ReerGeneric2Compatible {

    public typealias T1 = Key

    public typealias T2 = Value
}

public extension ReerGeneric2 where Base == Dictionary<T1, T2> {

    /// ReerKit: Query string from dictionary.
    public var queryString: String { get }

    /// ReerKit: Returns [String: String] for self.
    /// Returns nil if an error occurs.
    public var stringDictionary: [String : String]? { get }

    /// ReerKit: Check if key exists in dictionary.
    ///
    ///        let dict: [String: Any] = ["testKey": "testValue", "testArrayKey": [1, 2, 3, 4, 5]]
    ///        dict.re.has(key: "testKey") -> true
    ///        dict.re.has(key: "anotherKey") -> false
    ///
    /// - Parameter key: key to search for.
    /// - Returns: true if key exists in dictionary.
    public func has(key: T1) -> Bool

    /// ReerKit: JSON Data from dictionary.
    ///
    /// - Parameter prettify: set true to prettify data (default is false).
    /// - Returns: optional JSON Data (if applicable).
    public func jsonData(prettify: Bool = false) -> Data?

    /// ReerKit: JSON String from dictionary.
    ///
    ///        dict.re.jsonString() -> "{"testKey":"testValue","testArrayKey":[1,2,3,4,5]}"
    ///
    ///        dict.re.jsonString(prettify: true)
    ///        /*
    ///        returns the following string:
    ///
    ///        "{
    ///        "testKey" : "testValue",
    ///        "testArrayKey" : [
    ///            1,
    ///            2,
    ///            3,
    ///            4,
    ///            5
    ///        ]
    ///        }"
    ///
    ///        */
    ///
    /// - Parameter prettify: set true to prettify string (default is false).
    /// - Returns: optional JSON String (if applicable).
    public func jsonString(prettify: Bool = false) -> String?

    /// ReerKit: Returns a dictionary containing the results of mapping the given closure over the sequence’s elements.
    /// - Parameter transform: A mapping closure. `transform` accepts an element of this sequence as its parameter and returns a transformed value of the same or   of a different type.
    /// - Returns: A dictionary containing the transformed elements of this sequence.
    public func mapKeysAndValues<K, V>(_ transform: ((key: T1, value: T2)) throws -> (K, V)) rethrows -> [K : V] where K : Hashable

    /// ReerKit: Returns a dictionary containing the non-`nil` results of calling the given transformation with each element of this sequence.
    /// - Parameter transform: A closure that accepts an element of this sequence as its argument and returns an optional value.
    /// - Returns: A dictionary of the non-`nil` results of calling `transform` with each element of the sequence.
    /// - Complexity: *O(m + n)*, where _m_ is the length of this sequence and _n_ is the length of the result.
    public func compactMapKeysAndValues<K, V>(_ transform: ((key: T1, value: T2)) throws -> (K, V)?) rethrows -> [K : V] where K : Hashable

    /// ReerKit: Creates a new dictionary using specified keys.
    ///
    ///        var dict =  ["key1": 1, "key2": 2, "key3": 3, "key4": 4]
    ///        dict.re.pick(keys: ["key1", "key3", "key4"]) -> ["key1": 1, "key3": 3, "key4": 4]
    ///        dict.re.pick(keys: ["key2"]) -> ["key2": 2]
    ///
    /// - Complexity: O(K), where _K_ is the length of the keys array.
    ///
    /// - Parameter keys: An array of keys that will be the entries in the resulting dictionary.
    ///
    /// - Returns: A new dictionary that contains the specified keys only. If none of the keys exist, an empty dictionary will be returned.
    public func pick(keys: [T1]) -> [T1 : T2]
}

public extension ReerGeneric2 where Base == Dictionary<T1, T2>, T2: Equatable {

    /// ReerKit: Returns an array of all keys that have the given value in dictionary.
    ///
    ///        let dict = ["key1": "value1", "key2": "value1", "key3": "value2"]
    ///        dict.re.keys(forValue: "value1") -> ["key1", "key2"]
    ///        dict.re.keys(forValue: "value2") -> ["key3"]
    ///        dict.re.keys(forValue: "value3") -> []
    ///
    /// - Parameter value: Value for which keys are to be fetched.
    /// - Returns: An array containing keys that have the given value.
    public func keys(forValue value: T2) -> [T1]
}

extension Dictionary : ReerReferenceGeneric2Compatible {

    public typealias U1 = Key

    public typealias U2 = Value
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2> {

    /// ReerKit: Remove all keys contained in the keys parameter from the dictionary.
    ///
    ///        var dict : [String: String] = ["key1" : "value1", "key2" : "value2", "key3" : "value3"]
    ///        dict.re.removeAll(keys: ["key1", "key2"])
    ///        dict.re.keys.contains("key3") -> true
    ///        dict.re.keys.contains("key1") -> false
    ///        dict.re.keys.contains("key2") -> false
    ///
    /// - Parameter keys: keys to be removed.
    public mutating func removeAll<S>(keys: S) where S : Sequence, S.Element == U1

    /// ReerKit: Remove a value for a random key from the dictionary.
    @discardableResult
    public mutating func removeValueForRandomKey() -> U2?
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2>, U1: StringProtocol {

    /// ReerKit: Lowercase all keys in dictionary.
    ///
    ///        var dict = ["tEstKeY": "value"]
    ///        dict.re.lowercaseAllKeys()
    ///        print(dict) // prints "["testkey": "value"]"
    ///
    public mutating func lowercaseAllKeys()
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2> {

    /// ReerKit: Deep fetch or set a value from nested dictionaries.
    ///
    ///        var dict =  ["key": ["key1": ["key2": "value"]]]
    ///        dict.re[path: ["key", "key1", "key2"]] = "newValue"
    ///        dict.re[path: ["key", "key1", "key2"]] -> "newValue"
    ///
    /// - Note: Value fetching is iterative, while setting is recursive.
    ///
    /// - Complexity: O(N), _N_ being the length of the path passed in.
    ///
    /// - Parameter path: An array of keys to the desired value.
    ///
    /// - Returns: The value for the key-path passed in. `nil` if no value is found.
    public subscript(path path: [U1]) -> Any? { get set }
}

public extension ReerReferenceGeneric2 where Base == Dictionary<U1, U2>, U1 == String {

    /// ReerKit: Deep fetch or set a value from nested dictionaries.
    ///
    ///        var dict =  ["key": ["key1": ["key2": "value"]]]
    ///        dict.re[path: "key.key1.key2"] = "newValue"
    ///        dict.re[path: "key.key1.key2"] -> "newValue"
    ///
    /// - Note: Value fetching is iterative, while setting is recursive.
    ///
    /// - Complexity: O(N), _N_ being the length of the path passed in.
    ///
    /// - Parameter path: An array of keys to the desired value.
    ///
    /// - Returns: The value for the key-path passed in. `nil` if no value is found.
    public subscript(path path: U1) -> Any? { get set }
}

public extension Dictionary {

    /// ReerKit: Merge the keys/values of two dictionaries.
    ///
    ///        let dict: [String: String] = ["key1": "value1"]
    ///        let dict2: [String: String] = ["key2": "value2"]
    ///        let result = dict + dict2
    ///        result["key1"] -> "value1"
    ///        result["key2"] -> "value2"
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - rhs: dictionary.
    /// - Returns: An dictionary with keys and values from both.
    public static func + (lhs: [Key : Value], rhs: [Key : Value]) -> [Key : Value]

    /// ReerKit: Append the keys and values from the second dictionary into the first one.
    ///
    ///        var dict: [String: String] = ["key1": "value1"]
    ///        let dict2: [String: String] = ["key2": "value2"]
    ///        dict += dict2
    ///        dict["key1"] -> "value1"
    ///        dict["key2"] -> "value2"
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - rhs: dictionary.
    public static func += (lhs: inout [Key : Value], rhs: [Key : Value])

    /// ReerKit: Remove keys contained in the sequence from the dictionary.
    ///
    ///        let dict: [String: String] = ["key1": "value1", "key2": "value2", "key3": "value3"]
    ///        let result = dict - ["key1", "key2"]
    ///        result.keys.contains("key3") -> true
    ///        result.keys.contains("key1") -> false
    ///        result.keys.contains("key2") -> false
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - keys: array with the keys to be removed.
    /// - Returns: a new dictionary with keys removed.
    public static func - <S>(lhs: [Key : Value], keys: S) -> [Key : Value] where Key == S.Element, S : Sequence

    /// ReerKit: Remove keys contained in the sequence from the dictionary.
    ///
    ///        var dict: [String: String] = ["key1": "value1", "key2": "value2", "key3": "value3"]
    ///        dict -= ["key1", "key2"]
    ///        dict.keys.contains("key3") -> true
    ///        dict.keys.contains("key1") -> false
    ///        dict.keys.contains("key2") -> false
    ///
    /// - Parameters:
    ///   - lhs: dictionary.
    ///   - keys: array with the keys to be removed.
    public static func -= <S>(lhs: inout [Key : Value], keys: S) where Key == S.Element, S : Sequence
}

public extension Dictionary {

    /// ReerKit: Creates a Dictionary from a given sequence grouped by a given key path.
    ///
    /// - Parameters:
    ///   - sequence: Sequence being grouped.
    ///   - keyPath: The key path to group by.
    public static func re<S>(_ sequence: S, groupBy keyPath: KeyPath<S.Element, Key>) -> [Key : Value] where Value == [S.Element], S : Sequence
}
```

### Double

```
import CoreGraphics
import Darwin

public extension Reer where Base == Double {

    /// ReerKit: Int.
    public var int: Int { get }

    /// ReerKit: Float.
    public var float: Float { get }

    /// ReerKit: CGFloat.
    public var cgFloat: CGFloat { get }
}

public extension Reer where Base == Double {

    /// ReerKit: Normalizes a Double value from an input range to an output range.
    ///
    /// - Parameters:
    ///   - inputRange: The range of the input value. This is the original range of the value.
    ///   - outputRange: The desired range for the output value. Defaults to 0...1 if not specified.
    /// - Returns: The normalized value within the output range.
    public func normalized(from inputRange: ClosedRange<Double>, to outputRange: ClosedRange<Double> = 0...1) -> Double
}
precedencegroup PowerPrecedence {
    higherThan: MultiplicationPrecedence
}
infix operator ** : PowerPrecedence

extension Double {

    /// ReerKit: Value of exponentiation.
    ///
    /// - Parameters:
    ///   - lhs: base double.
    ///   - rhs: exponent double.
    /// - Returns: exponentiation result (example: 4.4 ** 0.5 = 2.0976176963).
    public static func ** (lhs: Double, rhs: Double) -> Double
}
```

### Float

```
import CoreGraphics
import Darwin

public extension Reer where Base == Float {

    /// ReerKit: Int.
    public var int: Int { get }

    /// ReerKit: Double.
    public var double: Double { get }

    /// ReerKit: CGFloat.
    public var cgFloat: CGFloat { get }
}
precedencegroup PowerPrecedence {
    higherThan: MultiplicationPrecedence
}
infix operator ** : PowerPrecedence

extension Float {

    /// ReerKit: Value of exponentiation.
    ///
    /// - Parameters:
    ///   - lhs: base float.
    ///   - rhs: exponent float.
    /// - Returns: exponentiation result (4.4 ** 0.5 = 2.0976176963).
    public static func ** (lhs: Float, rhs: Float) -> Float
}
```

### FloatingPoint

```
import Foundation

public extension Reer where Base: FloatingPoint {

    /// ReerKit: Absolute value of number.
    public var abs: Base { get }

    /// ReerKit: Check if number is positive.
    public var isPositive: Bool { get }

    /// ReerKit: Check if number is negative.
    public var isNegative: Bool { get }

    /// ReerKit: Ceil of number.
    public var ceil: Base { get }

    /// ReerKit: Radian value of degree input.
    public var degreesToRadians: Base { get }

    /// ReerKit: Floor of number.
    public var floor: Base { get }

    /// ReerKit: Degree value of radian input.
    public var radiansToDegrees: Base { get }
}
infix operator ± : DefaultPrecedence

extension FloatingPoint {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    /// - Parameters:
    ///   - lhs: number.
    ///   - rhs: number.
    /// - Returns: tuple of plus-minus operation ( 2.5 ± 1.5 -> (4, 1)).
    public static func ± (lhs: Self, rhs: Self) -> (Self, Self)
}
prefix operator ±

extension FloatingPoint {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    /// - Parameter number: number.
    /// - Returns: tuple of plus-minus operation (± 2.5 -> (2.5, -2.5)).
    public prefix static func ± (number: Self) -> (Self, Self)
}
prefix operator √

extension FloatingPoint {

    /// ReerKit: Square root of float.
    ///
    /// - Parameter float: float value to find square root for.
    /// - Returns: square root of given float.
    public prefix static func √ (float: Self) -> Self
}
```

### Int

```
import CoreGraphics
import Darwin

public extension Reer where Base == Int {

    /// ReerKit: Bool
    public var bool: Bool { get }

    /// ReerKit: Radian value of degree input.
    public var degreesToRadians: Double { get }

    /// ReerKit: Degree value of radian input
    public var radiansToDegrees: Double { get }

    /// ReerKit: UInt.
    public var uInt: UInt { get }

    /// ReerKit: Double.
    public var double: Double { get }

    /// ReerKit: Float.
    public var float: Float { get }

    /// ReerKit: CGFloat.
    public var cgFloat: CGFloat { get }

    /// ReerKit: String formatted for values over ±1000 (example: 1k, -2k, 100k, 1m, -5m..)
    public var metricFormatted: String { get }

    /// ReerKit: Array of digits of integer value.
    public var digits: [Int] { get }

    /// ReerKit: Number of digits of integer value.
    public var digitsCount: Int { get }
}

public extension Reer where Base == Int {

    /// ReerKit: check if given integer prime or not.
    /// Warning: Using big numbers can be computationally expensive!
    /// - Returns: true or false depending on prime-ness
    public func isPrime() -> Bool

    /// ReerKit: Roman numeral string from integer (if applicable).
    ///
    ///     10.romanNumeral() -> "X"
    ///
    /// - Returns: The roman numeral string.
    public func romanNumeral() -> String?
}
precedencegroup PowerPrecedence {
    higherThan: MultiplicationPrecedence
}
infix operator ** : PowerPrecedence

extension Int {

    /// ReerKit: Value of exponentiation.
    ///
    /// - Parameters:
    ///   - lhs: base integer.
    ///   - rhs: exponent integer.
    /// - Returns: exponentiation result (example: 2 ** 3 = 8).
    public static func ** (lhs: Int, rhs: Int) -> Double
}
prefix operator √

extension Int {

    /// ReerKit: Square root of integer.
    ///
    /// - Parameter int: integer value to find square root for
    /// - Returns: square root of given integer.
    public prefix static func √ (int: Int) -> Double
}
infix operator ± : DefaultPrecedence

extension Int {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    ///     2 ± 3 -> (5, -1)
    /// - Parameters:
    ///   - lhs: integer number.
    ///   - rhs: integer number.
    /// - Returns: Tuple of plus-minus operation
    public static func ± (lhs: Int, rhs: Int) -> (Int, Int)
}
prefix operator ±

extension Int {

    /// ReerKit: Tuple of plus-minus operation.
    ///
    /// - Parameter int: integer number
    /// - Returns: Tuple of plus-minus operation (example: ± 2 -> (2, -2)).
    ///            The first value must be positive, the second is negative, or both is zero.
    public prefix static func ± (int: Int) -> (Int, Int)
}
```

### MutableCollection

```
public extension ReerForMutableCollection where Base: MutableCollection & RandomAccessCollection {

    /// ReerKit: Sort the collection based on a keypath and a compare function.
    ///
    /// - Parameter keyPath: Key path to sort by. The key path type must be Comparable.
    /// - Parameter compare: Comparation function that will determine the ordering.
    public mutating func sort<T>(by keyPath: KeyPath<Base.Element, T>, with compare: (T, T) -> Bool)

    /// ReerKit: Sort the collection based on a keypath.
    ///
    /// - Parameter keyPath: Key path to sort by. The key path type must be Comparable.
    public mutating func sort<T>(by keyPath: KeyPath<Base.Element, T>) where T : Comparable

    /// ReerKit: Sort the collection based on two key paths. The second one will be used in case the values of the first one match.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    public mutating func sort<T, U>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>) where T : Comparable, U : Comparable

    /// ReerKit: Sort the collection based on three key paths. Whenever the values of one key path match, the next one will be used.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    ///     - keyPath3: Key path to sort by in case the values of `keyPath1` and `keyPath2` match. Must be Comparable.
    public mutating func sort<T, U, V>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>, and keyPath3: KeyPath<Base.Element, V>) where T : Comparable, U : Comparable, V : Comparable
}

public extension ReerForMutableCollection where Base: MutableCollection {

    /// ReerKit: Assign a given value to a field `keyPath` of all elements in the collection.
    ///
    /// - Parameters:
    ///   - value: The new value of the field.
    ///   - keyPath: The actual field of the element.
    public mutating func assignToAll<Value>(value: Value, by keyPath: WritableKeyPath<Base.Element, Value>)
}
```

### Optional

```
import CoreGraphics

extension Optional : ReerGenericCompatible {

    public typealias T = Wrapped
}

public extension ReerGeneric where Base == Optional<T> {

    /// ReerKit: Contains a nil value.
    public var isNil: Bool { get }

    /// ReerKit: Contains a valid value.
    public var isNotNil: Bool { get }

    /// ReerKit: Contains a nil value.
    public var isNone: Bool { get }

    /// ReerKit: Contains a valid value.
    public var isSome: Bool { get }
}

public extension ReerGeneric where Base == Optional<T> {

    /// ReerKit: Get the optional wrapped value or the passed default value if it is nil.
    ///
    ///        let foo: String? = nil
    ///        print(foo.re.value(default: "bar")) -> "bar"
    ///
    ///        let bar: String? = "bar"
    ///        print(bar.re.value(default: "foo")) -> "bar"
    ///
    /// - Parameter defaultValue: default value to return if self is nil.
    /// - Returns: self if not nil or default value if nil.
    public func value(or defaultValue: @autoclosure () -> T) -> T

    /// ReerKit: Gets the wrapped value of an optional. If the optional is `nil`, throw a custom error.
    ///
    ///        let foo: String? = nil
    ///        try print(foo.re.value(throw: MyError.notFound)) -> error: MyError.notFound
    ///
    ///        let bar: String? = "bar"
    ///        try print(bar.re.value(throw: MyError.notFound)) -> "bar"
    ///
    /// - Parameter error: The error to throw if the optional is `nil`.
    /// - Throws: The error passed in.
    /// - Returns: The value wrapped by the optional.
    public func value(throw error: Error) throws -> T

    /// ReerKit: Runs a closure to Wrapped if not nil.
    ///
    ///        let foo: String? = nil
    ///        foo.re.run { unwrappedFoo in
    ///            // block will never run since foo is nil
    ///            print(unwrappedFoo)
    ///        }
    ///
    ///        let bar: String? = "bar"
    ///        bar.re.run { unwrappedBar in
    ///            // block will run since bar is not nil
    ///            print(unwrappedBar) -> "bar"
    ///        }
    ///
    /// - Parameter action: a block to run if self is not nil.
    public func run<U>(_ action: (T) throws -> U?) rethrows -> U?
}

public extension ReerGeneric where Base == Optional<T> {

    /// ReerKit: Transform the optional wrapped value to `Bool` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.bool -> Optional(true)
    public var bool: Bool? { get }

    /// ReerKit: Transform the optional wrapped value to `Bool` if possible.
    /// Return `false` if failed.
    public var boolValue: Bool { get }

    /// ReerKit: Transform the optional wrapped value to `Bool` if possible.
    /// Return the passed default value if it is nil.
    public func boolValue(or defaultValue: @autoclosure () -> Bool) -> Bool

    /// ReerKit: Transform the optional wrapped value to `Int` if possible.
    ///
    ///     let a: Any? = "23"
    ///     a.re.int -> Optional(23)
    public var int: Int? { get }

    /// ReerKit: Transform the optional wrapped value to `Int` if possible.
    /// Return `0` if failed.
    public var intValue: Int { get }

    /// ReerKit: Transform the optional wrapped value to `Int` if possible.
    /// Return the passed default value if it is nil.
    public func intValue(or defaultValue: @autoclosure () -> Int) -> Int

    /// ReerKit: Transform the optional wrapped value to `String` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.string -> Optional("23")
    public var string: String? { get }

    /// ReerKit: Transform the optional wrapped value to `String` if possible.
    /// Return `""` if failed.
    public var stringValue: String { get }

    /// ReerKit: Transform the optional wrapped value to `String` if possible.
    /// Return the passed default value if it is nil.
    public func stringValue(or defaultValue: @autoclosure () -> String) -> String

    /// ReerKit: Transform the optional wrapped value to `Double` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.double -> Optional(23.0)
    public var double: Double? { get }

    /// ReerKit: Transform the optional wrapped value to `Double` if possible.
    /// Return `0` if failed.
    public var doubleValue: Double { get }

    /// ReerKit: Transform the optional wrapped value to `Double` if possible.
    /// Return the passed default value if it is nil.
    public func doubleValue(or defaultValue: @autoclosure () -> Double) -> Double

    /// ReerKit: Transform the optional wrapped value to `Float` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.float -> Optional(23.0)
    public var float: Float? { get }

    /// ReerKit: Transform the optional wrapped value to `Float` if possible.
    /// Return `0` if failed.
    public var floatValue: Float { get }

    /// ReerKit: Transform the optional wrapped value to `Float` if possible.
    /// Return the passed default value if it is nil.
    public func floatValue(or defaultValue: @autoclosure () -> Float) -> Float

    /// ReerKit: Transform the optional wrapped value to `CGFloat` if possible.
    ///
    ///     let a: Any? = 23
    ///     a.re.cgFloat -> Optional(23.0)
    public var cgFloat: CGFloat? { get }

    /// ReerKit: Transform the optional wrapped value to `CGFloat` if possible.
    /// Return `0` if failed.
    public var cgFloatValue: CGFloat { get }

    /// ReerKit: Transform the optional wrapped value to `CGFloat` if possible.
    /// Return the passed default value if it is nil.
    public func cgFloatValue(or defaultValue: @autoclosure () -> CGFloat) -> CGFloat

    /// ReerKit: Transform the optional wrapped value to `Dictionay<AnyHashable, Any>` if possible.
    ///
    ///     let a: Any? = ["s": 123]
    ///     a.re.anyDict -> Optional(["s": 123])
    public var anyDict: [AnyHashable : Any]? { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<AnyHashable, Any>` if possible.
    /// Return `[:]` if failed.
    public var anyDictValue: [AnyHashable : Any] { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<String, Any>` if possible.
    ///
    ///     let a: Any? = ["s": 123]
    ///     a.re.anyDict -> Optional(["s": 123])
    public var stringAnyDict: [String : Any]? { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<String, Any>` if possible.
    /// Return `[:]` if failed.
    public var stringAnyDictValue: [String : Any] { get }

    /// ReerKit: Transform the optional wrapped value to `Dictionay<AnyHashable, Any>` if possible.
    /// Return the passed default value if it is nil.
    public func dictValue<Key, Value>(or defaultValue: @autoclosure () -> [Key : Value]) -> [Key : Value] where Key : Hashable

    /// ReerKit: Transform the optional wrapped value to `Array<Any>` if possible.
    ///
    ///     let a: Any? = [123]
    ///     a.re.anyArray -> Optional([123])
    public var anyArray: [Any]? { get }

    /// ReerKit: Transform the optional wrapped value to `Array<Any>` if possible.
    /// Return `[]` if failed.
    public var anyArrayValue: [Any] { get }

    /// ReerKit: Transform the optional wrapped value to `Array<Any>` if possible.
    /// Return the passed default value if it is nil.
    public func arrayValue<E>(or defaultValue: @autoclosure () -> [E]) -> [E]
}

public extension ReerGeneric where Base == Optional<T>, T: Collection {

    /// ReerKit: Check if optional is nil or empty collection.
    ///
    ///     let foo: String? = ""
    ///     print(foo.re.isEmpty) -> true
    public var isEmpty: Bool { get }
}

/// Make any type to an optional value.
postfix operator ~!
public postfix func ~! <T>(value: T) -> T?
prefix operator !

/// Make `Bool?` to a oppsite value if it is not nil.
public extension Optional where Wrapped == Bool {

    prefix public static func ! (value: Bool?) -> Bool?
}
infix operator ?! : NilCoalescingPrecedence

public extension Optional where Wrapped : Collection {

    /// ReerKit: Return the default value when the optional is nil, or it's not nil, but the collection is empty.
    ///
    ///     let value: String? = ""
    ///     let result = value ?! "abc"
    ///     // result is "abc"
    ///     
    /// - Returns: A non empty value.
    public static func ?! (optionalValue: Optional<Wrapped>, defaultValue: @autoclosure () -> Wrapped) -> Wrapped
}
```

### OptionSet

```
public extension ReerForOptionSet where Base: OptionSet, Base.RawValue: FixedWidthInteger {

    /// ReerKit: Return a sequence of OptionSet
    ///
    /// - Returns: a sequence of OptionSet
    public func elements() -> AnySequence<Base>
}
```

### Range

```
import Foundation

extension Range : ReerGenericCompatible {

    public typealias T = Bound
}

public extension ReerGeneric where Base == Range<T>, T: FixedWidthInteger {

    /// ReerKit: Get NSRange from Range<FixedWidthInteger>
    public var nsRange: NSRange { get }
}
```

### RangeReplaceableCollection

```
public extension ReerForRangeReplaceableCollection where Base: RangeReplaceableCollection {

    /// ReerKit: Removes the first element of the collection which satisfies the given predicate.
    ///
    ///        [1, 2, 2, 3, 4, 2, 5].re.removeFirst { $0 % 2 == 0 } -> [1, 2, 3, 4, 2, 5]
    ///        ["h", "e", "l", "l", "o"].re.removeFirst { $0 == "e" } -> ["h", "l", "l", "o"]
    ///
    /// - Parameter predicate: A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.
    /// - Returns: The first element for which predicate returns true, after removing it. If no elements in the collection satisfy the given predicate, returns `nil`.
    @discardableResult
    public mutating func removeFirst(where predicate: (Base.Element) throws -> Bool) rethrows -> Base.Element?

    /// ReerKit: Remove a random value from the collection.
    @discardableResult
    public mutating func removeRandomElement() -> Base.Element?

    /// ReerKit: Keep elements of Array while condition is true.
    ///
    ///        [0, 2, 4, 7].re.keep(while: { $0 % 2 == 0 }) -> [0, 2, 4]
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: self after applying provided condition.
    /// - Throws: provided condition exception.
    @discardableResult
    public mutating func keep(while condition: (Base.Element) throws -> Bool) rethrows -> ReerForRangeReplaceableCollection<Base>

    /// ReerKit: Remove all duplicate elements using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Equatable.
    public mutating func removeDuplicates<E>(keyPath path: KeyPath<Base.Element, E>) where E : Equatable

    /// ReerKit: Remove all duplicate elements using KeyPath to compare.
    ///
    /// - Parameter path: Key path to compare, the value must be Hashable.
    public mutating func removeDuplicates<E>(keyPath path: KeyPath<Base.Element, E>) where E : Hashable

    /// ReerKit: Safely accesses the element at the specified position.
    /// The collection should be a `var`, NOT work for `let`
    /// 
    ///     var string = "012345"
    ///     string.re[0] -> Optional(Character("0"))
    ///     string.re[5] -> Optional(Character("5"))
    ///     string.re[6] -> nil
    ///     string.re[-1] -> nil
    ///
    ///     string = "012345"
    ///     string.re[0] = "a"
    ///     // string == "a12345"
    ///
    ///     string = "012345"
    ///     string.re[0] = nil
    ///     // string == "12345"
    ///
    ///     string = "012345"
    ///     string.re[7] = "a"
    ///     // string == "012345"
    ///
    ///  ----------------------------------------------
    ///
    ///     var array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0] -> Optional(0)
    ///     array.re[5] -> Optional(5)
    ///     array.re[6] -> nil
    ///     array.re[-1] -> nil
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0] = 9
    ///     // array == [9, 1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0] = nil
    ///     array == [1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[7] = 9
    ///     // array == [0, 1, 2, 3, 4, 5]
    ///
    ///
    /// - Parameter offset: The offset position of the element to access.
    public subscript(offset: Int) -> Base.Element? { get set }

    /// ReerKit: Safely accesses a contiguous subrange of the collection’s elements.
    /// The collection should be a `var`, NOT work for `let`
    ///
    ///     var string = "012345"
    ///     string.re[1..<3] -> Optional("12")
    ///     string.re[..<3] -> Optional("012")
    ///     string.re[-2..<3] -> Optional("012")
    ///     string.re[3..<10] -> Optional("345")
    ///     string.re[3...] -> Optional("345")
    ///     string.re[7...] -> nil
    ///     string.re[-10..<(-1)] -> nil
    ///
    ///     string = "012345"
    ///     string.re[0..<1] = "a"
    ///     // string == "a12345"
    ///
    ///     string = "012345"
    ///     string.re[0..<1] = nil
    ///     // string == "12345"
    ///
    ///     string = "012345"
    ///     string.re[0..<1] = ""
    ///     // string == "12345"
    ///
    ///     string = "012345"
    ///     string.re[7...] = "a"
    ///     // string == "012345"
    ///
    ///     string = "012345"
    ///     string.re[0...5] = "a"
    ///     // string == "a"
    ///
    ///     string = "012345"
    ///     string.re[-1...6] = nil
    ///     // string == ""
    ///
    ///  -------------------------------------
    ///
    ///     var array = [0, 1, 2, 3, 4, 5]
    ///     array.re[1..<3] -> Optional([1, 2])
    ///     array.re[..<3] -> Optional([0, 1, 2])
    ///     array.re[-2..<3] -> Optional([0, 1, 2])
    ///     array.re[3..<10] -> Optional([3, 4, 5])
    ///     array.re[3...] -> Optional([3, 4, 5])
    ///     array.re[7...] -> nil
    ///     array.re[-10..<(-1)] -> nil
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0..<1] = [9]
    ///     // array == [9, 1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0..<1] = nil
    ///     // array == [1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0..<1] = []
    ///     // array == [1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[7...] = [9]
    ///     // array == [0, 1, 2, 3, 4, 5]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0...5] = [9]
    ///     // array == [9]
    ///
    ///     array = [0, 1, 2, 3, 4, 5]
    ///     array.re[0...5] = []
    ///     // array == []
    ///
    /// - Parameter range: A range of the collection’s indices offsets.
    public subscript<R>(range: R) -> Base? where R : RangeExpression, R.Bound == Int { get set }

    /// ReerKit: Adds a new element at the end of the array, mutates the array in place
    ///
    /// - Parameter newElement: The optional element to append to the array
    public mutating func appendIfNonNil(_ newElement: Base.Element?)

    /// ReerKit: Adds the elements of a sequence to the end of the array, mutates the array in place
    ///
    /// - Parameter newElements: The optional sequence to append to the array
    public mutating func appendIfNonNil<S>(contentsOf newElements: S?) where S : Sequence, Base.Element == S.Element
}

public extension RangeReplaceableCollection {

    /// ReerKit: Creates a new collection of a given size where for each position of the collection the value will be the result of a call of the given expression.
    ///
    ///     let values = Array.re(expression: "Value", count: 3)
    ///     print(values)
    ///     // Prints "["Value", "Value", "Value"]"
    ///
    /// - Parameters:
    ///   - expression: The expression to execute for each position of the collection.
    ///   - count: The count of the collection.
    public static func re(expression: @autoclosure () throws -> Self.Element, count: Int) rethrows -> Self
}
```

### Sequence

```
public extension Reer where Base: Sequence {

    /// ReerKit: Check if all elements in collection match a condition.
    ///
    ///     [2, 2, 4].re.all(matching: { $0 % 2 == 0 }) -> true
    ///     [1,2, 2, 4].re.all(matching: { $0 % 2 == 0 }) -> false
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: true when all elements in the array match the specified condition.
    public func all(matching condition: (Base.Element) throws -> Bool) rethrows -> Bool

    /// ReerKit: Check if no elements in collection match a condition.
    ///
    ///     [2, 2, 4].re.none(matching: { $0 % 2 == 0 }) -> false
    ///     [1, 3, 5, 7].re.none(matching: { $0 % 2 == 0 }) -> true
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: true when no elements in the array match the specified condition.
    public func none(matching condition: (Base.Element) throws -> Bool) rethrows -> Bool

    /// ReerKit: Check if any element in collection match a condition.
    ///
    ///     [1, 2, 5].re.any(matching: { $0 % 2 == 0 }) -> true
    ///     [1, 3, 5, 7].re.any(matching: { $0 % 2 == 0 }) -> false
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: true when no elements in the array match the specified condition.
    public func any(matching condition: (Base.Element) throws -> Bool) rethrows -> Bool

    /// ReerKit: Filter elements based on a rejection condition.
    ///
    ///     [2, 2, 4, 7].re.reject(where: { $0 % 2 == 0 }) -> [7]
    ///
    /// - Parameter condition: to evaluate the exclusion of an element from the array.
    /// - Returns: the array with rejected values filtered from it.
    public func reject(where condition: (Base.Element) throws -> Bool) rethrows -> [Base.Element]

    /// ReerKit: Get element count based on condition.
    ///
    ///     [2, 2, 4, 7].re.count(where: { $0 % 2 == 0 }) -> 3
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: number of times the condition evaluated to true.
    public func count(where condition: (Base.Element) throws -> Bool) rethrows -> Int

    /// ReerKit: Iterate over a collection in reverse order. (right to left)
    ///
    ///     [0, 2, 4, 7].re.reversedForEach({ print($0) }) -> // Order of print: 7,4,2,0
    ///
    /// - Parameter body: a closure that takes an element of the array as a parameter.
    public func reversedForEach(_ body: (Base.Element) throws -> Void) rethrows

    /// ReerKit: Calls the given closure with each element where condition is true.
    ///
    ///     [0, 2, 4, 7].re.forEach({ print($0) }, where: { $0 % 2 == 0 }) -> // print: 0, 2, 4
    ///
    /// - Parameters:
    ///   - body: a closure that takes an element of the array as a parameter.
    ///   - condition: condition to evaluate each element against.
    public func forEach(_ body: (Base.Element) throws -> Void, where condition: (Base.Element) throws -> Bool) rethrows

    /// ReerKit: Filtered and map in a single operation.
    ///
    ///     [1, 2, 3, 4, 5].re.map({ $0.re.string }, where: { $0 % 2 == 0 }) -> ["2", "4"]
    ///
    /// - Parameters:
    ///   - transform: transform element function to evaluate every element.
    ///   - condition: filter condition
    /// - Returns: Return an filtered and mapped array.
    public func map<T>(_ transform: (Base.Element) throws -> T, where condition: (Base.Element) throws -> Bool) rethrows -> [T]

    /// ReerKit: Separates all items into 2 lists based on a given predicate. The first list contains all items for which the specified condition evaluates to true.
    /// The second list contains those that don't.
    ///
    ///     let (even, odd) = [0, 1, 2, 3, 4, 5].re.divided { $0 % 2 == 0 }
    ///     let (minors, adults) = people.re.divided { $0.age < 18 }
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: A tuple of matched and non-matched items
    public func divided(by condition: (Base.Element) throws -> Bool) rethrows -> (matching: [Base.Element], nonMatching: [Base.Element])

    /// ReerKit: Return a sorted array based on a key path and a compare function.
    ///
    ///     ["James", "Wade", "Bryant"].re.sorted(by: \String.count, with: <) -> ["Wade", "James", "Bryant"]
    ///
    /// - Parameter keyPath: Key path to sort by.
    /// - Parameter compare: Comparation function that will determine the ordering.
    /// - Returns: The sorted array.
    public func sorted<T>(by keyPath: KeyPath<Base.Element, T>, with compare: (T, T) -> Bool) -> [Base.Element]

    /// ReerKit: Return a sorted array based on a key path.
    ///
    /// - Parameter keyPath: Key path to sort by. The key path type must be Comparable.
    /// - Returns: The sorted array.
    public func sorted<T>(by keyPath: KeyPath<Base.Element, T>) -> [Base.Element] where T : Comparable

    /// ReerKit: Returns a sorted sequence based on two key paths. The second one will be used in case the values of the first one match.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    public func sorted<T, U>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>) -> [Base.Element] where T : Comparable, U : Comparable

    /// ReerKit: Returns a sorted sequence based on three key paths. Whenever the values of one key path match, the next one will be used.
    ///
    /// - Parameters:
    ///     - keyPath1: Key path to sort by. Must be Comparable.
    ///     - keyPath2: Key path to sort by in case the values of `keyPath1` match. Must be Comparable.
    ///     - keyPath3: Key path to sort by in case the values of `keyPath1` and `keyPath2` match. Must be Comparable.
    public func sorted<T, U, V>(by keyPath1: KeyPath<Base.Element, T>, and keyPath2: KeyPath<Base.Element, U>, and keyPath3: KeyPath<Base.Element, V>) -> [Base.Element] where T : Comparable, U : Comparable, V : Comparable

    /// ReerKit: Sum of a `AdditiveArithmetic` property of each `Element` in a `Sequence`.
    ///
    ///     ["James", "Wade", "Bryant"].re.sum(for: \.count) -> 15
    ///
    /// - Parameter keyPath: Key path of the `AdditiveArithmetic` property.
    /// - Returns: The sum of the `AdditiveArithmetic` properties at `keyPath`.
    public func sum<T>(for keyPath: KeyPath<Base.Element, T>) -> T where T : AdditiveArithmetic

    /// ReerKit: Get last element that satisfies a conditon.
    ///
    ///     [2, 2, 4, 7].re.last(where: { $0 % 2 == 0 }) -> 4
    ///
    /// - Parameter condition: condition to evaluate each element against.
    /// - Returns: the last element in the array matching the specified condition. (optional)
    public func last(where condition: (Base.Element) throws -> Bool) rethrows -> Base.Element?
}

public extension Reer where Base: Sequence, Base.Element: Hashable {

    /// ReerKit: Check if array contains an array of elements.
    ///
    ///     [1, 2, 3, 4, 5].re.contains([1, 2]) -> true
    ///     [1.2, 2.3, 4.5, 3.4, 4.5].re.contains([2, 6]) -> false
    ///     ["h", "e", "l", "l", "o"].re.contains(["l", "o"]) -> true
    ///
    /// - Parameter elements: array of elements to check.
    /// - Returns: true if array contains all given items.
    /// - Complexity: _O(m + n)_, where _m_ is the length of `elements` and _n_ is the length of this sequence.
    public func contains(_ elements: [Base.Element]) -> Bool

    /// ReerKit: Check whether a sequence contains duplicates.
    ///
    /// - Returns: true if the receiver contains duplicates.
    public func containsDuplicates() -> Bool

    /// ReerKit: Getting the duplicated elements in a sequence.
    ///
    ///     [1, 1, 2, 2, 3, 3, 3, 4, 5].re.duplicates().sorted() -> [1, 2, 3])
    ///     ["h", "e", "l", "l", "o"].re.duplicates().sorted() -> ["l"])
    ///
    /// - Returns: An array of duplicated elements.
    ///
    public func duplicates() -> [Base.Element]

    /// ReerKit: Remove duplicate elements.
    ///
    ///     [1, 2, 1, 3, 2].re.withoutDuplicates() -> [1, 2, 3]
    ///
    /// - Returns: Sequence without repeating elements
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func withoutDuplicates() -> [Base.Element]
}

public extension Reer where Base: Sequence, Base.Element: Equatable {

    /// ReerKit: Check if array contains an array of elements.
    ///
    ///     [1, 2, 3, 4, 5].re.contains([1, 2]) -> true
    ///     [1.2, 2.3, 4.5, 3.4, 4.5].re.contains([2, 6]) -> false
    ///     ["h", "e", "l", "l", "o"].re.contains(["l", "o"]) -> true
    ///
    /// - Parameter elements: array of elements to check.
    /// - Returns: true if array contains all given items.
    /// - Complexity: _O(m·n)_, where _m_ is the length of `elements` and _n_ is the length of this sequence.
    public func contains(_ elements: [Base.Element]) -> Bool
}

public extension Reer where Base: Sequence, Base.Element: AdditiveArithmetic {

    /// ReerKit: Sum of all elements in array.
    ///
    ///        [1, 2, 3, 4, 5].re.sum() -> 15
    ///
    /// - Returns: sum of the array's elements.
    public func sum() -> Base.Element
}
```

### Set

```
extension Set : ReerReferenceGenericCompatible {

    public typealias T = Element
}

public extension ReerReferenceGeneric where Base == Set<T> {

    /// ReerKit: Toggle the presence of an element in the set
    ///
    /// - Parameter element: The element to toggle
    /// - Returns: True if the element was inserted, false if it was removed
    @discardableResult
    public mutating func toggle(_ element: T) -> Bool
}
```

### SignedInteger

```
import Foundation

public extension Reer where Base: SignedInteger {

    /// ReerKit: Absolute value of integer number.
    public var abs: Base { get }

    /// ReerKit: Check if integer is positive.
    public var isPositive: Bool { get }

    /// ReerKit: Check if integer is negative.
    public var isNegative: Bool { get }

    /// ReerKit: Check if integer is even.
    public var isEven: Bool { get }

    /// ReerKit: Check if integer is odd.
    public var isOdd: Bool { get }

    /// ReerKit: String of format (XXh XXm) from seconds Int.
    public var timeString: String { get }
}

public extension Reer where Base: SignedInteger {

    /// ReerKit: Greatest common divisor of integer value and n.
    ///
    /// - Parameter n: integer value to find gcd with.
    /// - Returns: greatest common divisor of self and n.
    public func gcd(with n: Base) -> Base

    /// ReerKit: Least common multiple of integer and n.
    ///
    /// - Parameter n: integer value to find lcm with.
    /// - Returns: least common multiple of self and n.
    public func lcm(with n: Base) -> Base

    /// ReerKit: Ordinal representation of an integer.
    ///
    ///        print((12).ordinalString()) // prints "12th"
    ///
    /// - Parameter locale: locale, default is .current.
    /// - Returns: string ordinal representation of number in specified locale language. E.g. input 92, output in "en": "92nd".
    public func ordinalString(locale: Locale = .current) -> String?
}
```

### SignedNumeric

```
import Foundation

public extension Reer where Base: SignedNumeric {

    /// ReerKit: String.
    public var string: String { get }
}

public extension Reer where Base: SignedNumeric {

    /// ReerKit: String with number and current locale currency.
    public func localeCurrency(_ locale: Locale = .current) -> String?

    /// ReerKit: Spelled out representation of a number.
    ///
    ///        print((12.32).spelledOutString()) // prints "twelve point three two"
    ///
    /// - Parameter locale: Locale, default is .current.
    /// - Returns: String representation of number spelled in specified locale language. E.g. input 92, output in "en": "ninety-two".
    public func spelledOutString(locale: Locale = .current) -> String?
}
```

### String

```
import Foundation
import UIKit
import CoreGraphics
import CommonCrypto

public extension Reer where Base == String {

    /// ReerKit: Returns an Data using UTF-8 encoding.
    public var utf8Data: Data? { get }

    /// ReerKit: String decoded from base64 (if applicable).
    ///
    ///        "SGVsbG8gV29ybGQh".re.base64Decoded = Optional("Hello World!")
    ///
    public var base64Decoded: String? { get }

    /// ReerKit: `Data` decoded from base64 (if applicable).
    public var base64DecodedData: Data? { get }

    /// ReerKit: String encoded in base64 (if applicable).
    ///
    ///        "Hello World!".re.base64Encoded -> Optional("SGVsbG8gV29ybGQh")
    ///
    public var base64Encoded: String? { get }

    /// ReerKit: Returns new string in punycode encoding (RFC 3492)
    ///
    /// - Returns: Punycode encoded string or nil if the string can't be encoded
    public var punycodeEncoded: String? { get }

    /// ReerKit: Returns new string decoded from punycode representation (RFC 3492)
    ///
    /// - Returns: Original string or nil if the string doesn't contain correct encoding
    public var punycodeDecoded: String? { get }

    /// ReerKit: Returns new string containing IDNA-encoded hostname
    ///
    /// - Returns: IDNA encoded hostname or nil if the string can't be encoded
    public var idnaEncoded: String? { get }

    /// ReerKit: Returns new string containing hostname decoded from IDNA representation
    ///
    /// - Returns: Original hostname or nil if the string doesn't contain correct encoding
    public var idnaDecoded: String? { get }

    /// ReerKit: Array of characters of a string.
    public var characters: [Character] { get }

    /// ReerKit: CamelCase of string.
    ///
    ///        "sOme vAriable naMe".re.camelCased -> "someVariableName"
    ///
    public var camelCased: String { get }

    /// ReerKit: Check if string contains one or more emojis.
    ///
    ///        "Hello 😀".re.containEmoji -> true
    ///
    public var containEmoji: Bool { get }

    /// ReerKit: Check if string contains one or more letters.
    ///
    ///        "123abc".re.hasLetters -> true
    ///        "123".re.hasLetters -> false
    ///
    public var hasLetters: Bool { get }

    /// ReerKit: Check if string contains one or more digits.
    ///
    ///        "abcd".re.hasDigits -> false
    ///        "123abc".re.hasDigits -> true
    ///
    public var hasDigits: Bool { get }

    /// ReerKit: Check if string only contains letters.
    ///
    ///     "abc".re.hasLettersOnly -> true
    ///     "123abc".re.hasLettersOnly -> false
    ///
    public var hasLettersOnly: Bool { get }

    /// ReerKit: Check if string only contains digits.
    ///
    ///     "123".re.hasDigitsOnly -> true
    ///     "1.3".re.hasDigitsOnly -> false
    ///     "abc".re.hasDigitsOnly -> false
    ///
    public var hasDigitsOnly: Bool { get }

    /// ReerKit: Check if string is palindrome.
    ///
    ///     "abcdcba".re.isPalindrome -> true
    ///     "Mom".re.isPalindrome -> true
    ///     "A man a plan a canal, Panama!".re.isPalindrome -> true
    ///     "Mama".re.isPalindrome -> false
    ///
    public var isPalindrome: Bool { get }

    /// ReerKit: Check if string is valid email format.
    ///
    /// - Note: Note that this property does not validate the email address against an email server. It merely attempts to determine whether its format is suitable     for an email address.
    ///
    ///        "john@doe.com".re.isValidEmail -> true
    ///
    public var isValidEmail: Bool { get }

    /// ReerKit: Check if string is a valid URL.
    ///
    ///        "https://google.com".re.isValidUrl -> true
    ///
    public var isValidUrl: Bool { get }

    /// ReerKit: Check if string is a valid schemed URL.
    ///
    ///        "https://google.com".re.isValidSchemedUrl -> true
    ///        "google.com".re.isValidSchemedUrl -> false
    ///
    public var isValidSchemedUrl: Bool { get }

    /// ReerKit: Check if string is a valid https URL.
    ///
    ///        "https://google.com".re.isValidHttpsUrl -> true
    ///
    public var isValidHttpsUrl: Bool { get }

    /// ReerKit: Check if string is a valid http URL.
    ///
    ///        "http://google.com".re.isValidHttpUrl -> true
    ///
    public var isValidHttpUrl: Bool { get }

    /// ReerKit: Check if string is a valid file URL.
    ///
    ///        "file://Documents/file.txt".re.isValidFileUrl -> true
    ///
    public var isValidFileUrl: Bool { get }

    /// ReerKit: Latinized string.
    ///
    ///        "Hèllö Wórld!".re.latinized -> "Hello World!"
    ///
    public var latinized: String { get }

    /// ReerKit: First character of string (if applicable).
    ///
    ///        "Hello".re.firstCharacterAsString -> Optional("H")
    ///        "".re.firstCharacterAsString -> nil
    ///
    public var firstCharacterAsString: String? { get }

    /// ReerKit: Last character of string (if applicable).
    ///
    ///        "Hello".re.lastCharacterAsString -> Optional("o")
    ///        "".re.lastCharacterAsString -> nil
    ///
    public var lastCharacterAsString: String? { get }

    /// ReerKit: Bool value from string (if applicable).
    ///
    ///        "1".re.bool -> true
    ///        "False".re.bool -> false
    ///        "Hello".re.bool = nil
    ///
    public var bool: Bool? { get }

    /// ReerKit: Integer value from string (if applicable).
    ///
    ///        "101".re.int -> 101
    ///
    public var int: Int? { get }

    /// ReerKit: Float value from string (if applicable).
    ///
    /// - Parameter locale: Locale (default is Locale.current)
    /// - Returns: Optional Float value from given string.
    public func float(locale: Locale = .current) -> Float?

    /// ReerKit: Double value from string (if applicable).
    ///
    /// - Parameter locale: Locale (default is Locale.current)
    /// - Returns: Optional Double value from given string.
    public func double(locale: Locale = .current) -> Double?

    /// ReerKit: CGFloat value from string (if applicable).
    ///
    /// - Parameter locale: Locale (default is Locale.current)
    /// - Returns: Optional CGFloat value from given string.
    public func cgFloat(locale: Locale = .current) -> CGFloat?

    /// ReerKit: Calculate height for a `String` with a constrained width.
    /// - Parameter width: A constrained of container view width.
    /// - Parameter font: The font for text.
    /// - Returns: Total height of the attributed string after rendering.
    public func height(forWidth width: CGFloat, font: UIFont) -> CGFloat

    /// ReerKit: Calculate width for a `String` with an unlimited height in one line.
    /// - Returns: Width of the string with the font after rendering.
    public func singleLineWidth(font: UIFont) -> CGFloat

    /// ReerKit: Date object from "yyyy-MM-dd" formatted string.
    ///
    ///        "2007-06-29".re.date -> Optional(Date)
    ///
    public var date: Date? { get }

    /// ReerKit: Date object from "yyyy-MM-dd HH:mm:ss" formatted string.
    ///
    ///        "2007-06-29 14:23:09".re.dateTime -> Optional(Date)
    ///
    public var dateTime: Date? { get }

    /// ReerKit: URL from string (if applicable).
    ///
    ///        "https://google.com".re.url -> URL(string: "https://google.com")
    ///        "not url".re.url -> nil
    ///
    public var url: URL? { get }

    /// ReerKit: String with no spaces or new lines in beginning and end.
    ///
    ///        "   hello  \n".re.trimmed -> "hello"
    ///
    public var trimmed: String { get }

    /// ReerKit: Readable string from a URL string.
    ///
    ///        "it's%20easy%20to%20decode%20strings".re.urlDecoded -> "it's easy to decode strings"
    ///
    public var urlDecoded: String { get }

    /// ReerKit: URL escaped string.
    ///
    ///        "it's easy to encode strings".re.urlEncoded -> "it's%20easy%20to%20encode%20strings"
    ///
    public var urlEncoded: String { get }

    /// ReerKit: Escaped string for inclusion in a regular expression pattern.
    ///
    /// "hello ^$ there" -> "hello \\^\\$ there"
    ///
    public var regexEscaped: String { get }

    /// ReerKit: String without spaces and new lines.
    ///
    ///        "   \n Swifter   \n  Swift  ".re.withoutSpacesAndNewLines -> "SwifterSwift"
    ///
    public var withoutSpacesAndNewLines: String { get }

    /// ReerKit: Check if the given string contains only white spaces.
    public var isWhitespace: Bool { get }

    /// ReerKit: Check if the given string spelled correctly.
    public var isSpelledCorrectly: Bool { get }

    /// ReerKit: Array of strings separated by new lines.
    ///
    ///        "Hello\ntest".re.lines() -> ["Hello", "test"]
    ///
    /// - Returns: Strings separated by new lines.
    public func lines() -> [String]

    /// ReerKit: Returns a localized string, with an optional comment for translators.
    ///
    ///        "Hello world".re.localized -> Hallo Welt
    ///
    public func localized(comment: String = "") -> String

    /// ReerKit: Array with unicodes for all characters in a string.
    ///
    ///        "SwifterSwift".re.unicodeArray() -> [83, 119, 105, 102, 116, 101, 114, 83, 119, 105, 102, 116]
    ///
    /// - Returns: The unicodes for all characters in a string.
    public func unicodeArray() -> [Int]

    /// ReerKit: an array of all words in a string.
    ///
    ///        "Swift is amazing".re.words() -> ["Swift", "is", "amazing"]
    ///
    /// - Returns: The words contained in a string.
    public func words() -> [String]

    /// ReerKit: Count of words in a string.
    ///
    ///        "Swift is amazing".re.wordsCount() -> 3
    ///
    /// - Returns: The count of words contained in a string.
    public func wordCount() -> Int

    /// ReerKit: Transforms the string into a slug string.
    ///
    ///        "Swift is amazing".re.toSlug() -> "swift-is-amazing"
    ///
    /// - Returns: The string in slug format.
    public func toSlug() -> String

    /// ReerKit: Safely subscript string with index.
    ///
    ///        "Hello World!".re[3] -> "l"
    ///        "Hello World!".re[20] -> nil
    ///
    /// - Parameter index: index.
    public subscript(index: Int) -> Character? { get }

    /// ReerKit: Safely subscript string within a given range.
    ///
    ///        "Hello World!".re[safe: 6..<11] -> "World"
    ///        "Hello World!".re[safe: 21..<110] -> nil
    ///
    ///        "Hello World!".re[safe: 6...11] -> "World!"
    ///        "Hello World!".re[safe: 21...110] -> nil
    ///
    /// - Parameter range: Range expression.
    public subscript<R>(range: R) -> String? where R : RangeExpression, R.Bound == Int { get }

    /// ReerKit: Copy string to global pasteboard.
    ///
    ///        "SomeText".re.copyToPasteboard() // copies "SomeText" to pasteboard
    ///
    public func copyToPasteboard()

    /// ReerKit: Check if string contains only unique characters.
    ///
    public func hasUniqueCharacters() -> Bool

    /// ReerKit: Check if string contains one or more instance of substring.
    ///
    ///        "Hello World!".re.contain("O") -> false
    ///        "Hello World!".re.contain("o", caseSensitive: false) -> true
    ///
    /// - Parameters:
    ///   - string: substring to search for.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: true if string contains one or more instance of substring.
    public func contains(_ string: String, caseSensitive: Bool = true) -> Bool

    /// ReerKit: Count of substring in string.
    ///
    ///        "Hello World!".re.count(of: "o") -> 2
    ///        "Hello World!".re.count(of: "L", caseSensitive: false) -> 3
    ///
    /// - Parameters:
    ///   - string: substring to search for.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: count of appearance of substring in string.
    public func count(of string: String, caseSensitive: Bool = true) -> Int

    /// ReerKit: Check if string starts with substring.
    ///
    ///        "hello World".re.starts(with: "h") -> true
    ///        "hello World".re.starts(with: "H", caseSensitive: false) -> true
    ///
    /// - Parameters:
    ///   - prefix: substring to search if string starts with.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: true if string starts with substring.
    public func starts(with prefix: String, caseSensitive: Bool = true) -> Bool

    /// ReerKit: Check if string ends with substring.
    ///
    ///        "Hello World!".re.ends(with: "!") -> true
    ///        "Hello World!".re.ends(with: "WoRld!", caseSensitive: false) -> true
    ///
    /// - Parameters:
    ///   - suffix: substring to search if string ends with.
    ///   - caseSensitive: set true for case sensitive search (default is true).
    /// - Returns: true if string ends with substring.
    public func ends(with suffix: String, caseSensitive: Bool = true) -> Bool

    /// ReerKit: Random string of given length.
    ///
    ///        String.re.random(ofLength: 18) -> "u7MMZYvGo9obcOcPj8"
    ///
    /// - Parameter length: number of characters in string.
    /// - Returns: random string of given length.
    public static func random(ofLength length: Int) -> String

    /// ReerKit: Sliced string from a start index with length.
    ///
    ///        "Hello World".re.slicing(from: 6, length: 5) -> "World"
    ///
    /// - Parameters:
    ///   - index: string index the slicing should start from.
    ///   - length: amount of characters to be sliced after given index.
    /// - Returns: sliced substring of length number of characters (if applicable) (example: "Hello World".slicing(from: 6, length: 5) -> "World").
    public func slicing(from index: Int, length: Int) -> String?

    /// ReerKit: Date object from string of date format.
    ///
    ///        "2017-01-15".re.date(withFormat: "yyyy-MM-dd") -> Date set to Jan 15, 2017
    ///        "not date string".re.date(withFormat: "yyyy-MM-dd") -> nil
    ///
    /// - Parameter format: date format.
    /// - Returns: Date object from string (if applicable).
    public func date(withFormat format: String) -> Date?

    /// ReerKit: Truncated string (limited to a given number of characters).
    ///
    ///        "This is a very long sentence".re.truncated(toLength: 14) -> "This is a very..."
    ///        "Short sentence".re.truncated(toLength: 14) -> "Short sentence"
    ///
    /// - Parameters:
    ///   - length: maximum number of characters before cutting.
    ///   - trailing: string to add at the end of truncated string.
    /// - Returns: truncated string (this is an extr...).
    public func truncated(toLength length: Int, trailing: String? = "...") -> String

    /// ReerKit: Verify if string matches the regex pattern.
    ///
    /// - Parameter pattern: Pattern to verify.
    /// - Returns: `true` if string matches the pattern.
    public func matches(pattern: String) -> Bool

    /// ReerKit: Verify if string matches the regex.
    ///
    /// - Parameters:
    ///   - regex: Regex to verify.
    ///   - options: The matching options to use.
    /// - Returns: `true` if string matches the regex.
    public func matches(regex: NSRegularExpression, options: NSRegularExpression.MatchingOptions = []) -> Bool

    /// ReerKit: Returns a new string in which all occurrences of a regex in a specified range of the receiver are replaced by the template.
    /// - Parameters:
    ///   - regex: Regex to replace.
    ///   - template: The template to replace the regex.
    ///   - options: The matching options to use
    ///   - searchRange: The range in the receiver in which to search.
    /// - Returns: A new string in which all occurrences of regex in searchRange of the receiver are replaced by template.
    public func replacingOccurrences(of regex: NSRegularExpression, with template: String, options: NSRegularExpression.MatchingOptions = [], range searchRange: Range<String.Index>? = nil) -> String

    /// ReerKit: Returns a string by padding to fit the length parameter size with another string in the start.
    ///
    ///     "hue".re.paddingStart(10) -> "       hue"
    ///     "hue".re.paddingStart(10, with: "br") -> "brbrbrbhue"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    /// - Returns: The string with the padding on the start.
    public func paddingStart(_ length: Int, with string: String = " ") -> String

    /// ReerKit: Returns a string by padding to fit the length parameter size with another string in the end.
    ///
    ///     "hue".re.paddingEnd(10) -> "hue       "
    ///     "hue".re.paddingEnd(10, with: "br") -> "huebrbrbrb"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    /// - Returns: The string with the padding on the end.
    public func paddingEnd(_ length: Int, with string: String = " ") -> String

    /// ReerKit: Removes given prefix from the string.
    ///
    ///     "Hello, World!".re.removingPrefix("Hello, ") -> "World!"
    ///
    /// - Parameter prefix: Prefix to remove from the string.
    /// - Returns: The string after prefix removing.
    public func removingPrefix(_ prefix: String) -> String

    /// ReerKit: Removes given suffix from the string.
    ///
    ///     "Hello, World!".re.removingSuffix(", World!") -> "Hello"
    ///
    /// - Parameter suffix: Suffix to remove from the string.
    /// - Returns: The string after suffix removing.
    public func removingSuffix(_ suffix: String) -> String

    /// ReerKit: Adds prefix to the string.
    ///
    ///     "www.apple.com".re.withPrefix("https://") -> "https://www.apple.com"
    ///
    /// - Parameter prefix: Prefix to add to the string.
    /// - Returns: The string with the prefix prepended.
    public func withPrefix(_ prefix: String) -> String
}

extension String: ReerReferenceCompatible {}
public extension ReerReference where Base == String {

    /// ReerKit: Converts string format to CamelCase.
    ///
    ///        var str = "sOme vaRiabLe Name"
    ///        str.re.camelize()
    ///        print(str) // prints "someVariableName"
    ///
    @discardableResult
    public mutating func camelize() -> String

    /// ReerKit: First character of string uppercased(if applicable) while keeping the original string.
    ///
    ///        "hello world".re.firstCharacterUppercased() -> "Hello world"
    ///        "".re.firstCharacterUppercased() -> ""
    ///
    public mutating func firstCharacterUppercased()

    /// ReerKit: Latinize string.
    ///
    ///        var str = "Hèllö Wórld!"
    ///        str.re.latinize()
    ///        print(str) // prints "Hello World!"
    ///
    @discardableResult
    public mutating func latinize() -> String

    /// ReerKit: Reverse string.
    @discardableResult
    public mutating func reverse() -> String

    /// ReerKit: Slice given string from a start index with length (if applicable).
    ///
    ///        var str = "Hello World"
    ///        str.re.slice(from: 6, length: 5)
    ///        print(str) // prints "World"
    ///
    /// - Parameters:
    ///   - index: string index the slicing should start from.
    ///   - length: amount of characters to be sliced after given index.
    @discardableResult
    public mutating func slice(from index: Int, length: Int) -> String

    /// ReerKit: Slice given string from a start index to an end index (if applicable).
    ///
    ///        var str = "Hello World"
    ///        str.re.slice(from: 6, to: 11)
    ///        print(str) // prints "World"
    ///
    /// - Parameters:
    ///   - start: string index the slicing should start from.
    ///   - end: string index the slicing should end at.
    @discardableResult
    public mutating func slice(from start: Int, to end: Int) -> String

    /// ReerKit: Slice given string from a start index (if applicable).
    ///
    ///        var str = "Hello World"
    ///        str.re.slice(at: 6)
    ///        print(str) // prints "World"
    ///
    /// - Parameter index: string index the slicing should start from.
    @discardableResult
    public mutating func slice(at index: Int) -> String

    /// ReerKit: Removes spaces and new lines in beginning and end of string.
    ///
    ///        var str = "  \n Hello World \n\n\n"
    ///        str.re.trim()
    ///        print(str) // prints "Hello World"
    ///
    @discardableResult
    public mutating func trim() -> String

    /// ReerKit: Truncate string (cut it to a given number of characters).
    ///
    ///        var str = "This is a very long sentence"
    ///        str.re.truncate(toLength: 14)
    ///        print(str) // prints "This is a very..."
    ///
    /// - Parameters:
    ///   - length: maximum number of characters before cutting.
    ///   - trailing: string to add at the end of truncated string (default is "...").
    @discardableResult
    public mutating func truncate(toLength length: Int, trailing: String? = "...") -> String

    /// ReerKit: Convert URL string to readable string.
    ///
    ///        var str = "it's%20easy%20to%20decode%20strings"
    ///        str.re.urlDecode()
    ///        print(str) // prints "it's easy to decode strings"
    ///
    @discardableResult
    public mutating func urlDecode() -> String

    /// ReerKit: Escape string.
    ///
    ///        var str = "it's easy to encode strings"
    ///        str.re.urlEncode()
    ///        print(str) // prints "it's%20easy%20to%20encode%20strings"
    ///
    @discardableResult
    public mutating func urlEncode() -> String

    /// ReerKit: Pad string to fit the length parameter size with another string in the start.
    ///
    ///     "hue".re.padStart(10) -> "       hue"
    ///     "hue".re.padStart(10, with: "br") -> "brbrbrbhue"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    @discardableResult
    public mutating func padStart(_ length: Int, with string: String = " ") -> String

    /// ReerKit: Pad string to fit the length parameter size with another string in the start.
    ///
    ///   "hue".padEnd(10) -> "hue       "
    ///   "hue".padEnd(10, with: "br") -> "huebrbrbrb"
    ///
    /// - Parameters:
    ///   - length: The target length to pad.
    ///   - string: Pad string. Default is " ".
    @discardableResult
    public mutating func padEnd(_ length: Int, with string: String = " ") -> String
}

public extension String {

    /// ReerKit: Overload Swift's 'contains' operator for matching regex pattern.
    ///
    /// - Parameters:
    ///   - lhs: String to check on regex pattern.
    ///   - rhs: Regex pattern to match against.
    /// - Returns: true if string matches the pattern.
    public static func ~= (lhs: String, rhs: String) -> Bool

    /// ReerKit: Overload Swift's 'contains' operator for matching regex.
    ///
    /// - Parameters:
    ///   - lhs: String to check on regex.
    ///   - rhs: Regex to match against.
    /// - Returns: `true` if there is at least one match for the regex in the string.
    public static func ~= (lhs: String, rhs: NSRegularExpression) -> Bool

    /// ReerKit: Repeat string multiple times.
    ///
    ///        'bar' * 3 -> "barbarbar"
    ///
    /// - Parameters:
    ///   - lhs: string to repeat.
    ///   - rhs: number of times to repeat character.
    /// - Returns: new string with given string repeated n times.
    public static func * (lhs: String, rhs: Int) -> String

    /// ReerKit: Repeat string multiple times.
    ///
    ///        3 * 'bar' -> "barbarbar"
    ///
    /// - Parameters:
    ///   - lhs: number of times to repeat character.
    ///   - rhs: string to repeat.
    /// - Returns: new string with given string repeated n times.
    public static func * (lhs: Int, rhs: String) -> String
}

public extension Reer where Base == String {

    /// ReerKit: NSString from a string.
    public var nsString: NSString { get }

    /// ReerKit: The full `NSRange` of the string.
    public var fullNSRange: NSRange { get }

    /// ReerKit: NSString lastPathComponent.
    public var lastPathComponent: String { get }

    /// ReerKit: NSString pathExtension.
    public var pathExtension: String { get }

    /// ReerKit: NSString deletingLastPathComponent.
    public var deletingLastPathComponent: String { get }

    /// ReerKit: NSString deletingPathExtension.
    public var deletingPathExtension: String { get }

    /// ReerKit: NSString pathComponents.
    public var pathComponents: [String] { get }

    /// ReerKit: Convert an `NSRange` into `Range<String.Index>`.
    /// - Parameter nsRange: The `NSRange` within the receiver.
    /// - Returns: The equivalent `Range<String.Index>` of `nsRange` found within the receiving string.
    public func range(from nsRange: NSRange) -> Range<Base.Index>

    /// ReerKit: Convert a `Range<String.Index>` into `NSRange`.
    /// - Parameter range: The `Range<String.Index>` within the receiver.
    /// - Returns: The equivalent `NSRange` of `range` found within the receiving string.
    public func nsRange(from range: Range<Base.Index>) -> NSRange

    /// ReerKit: NSString appendingPathComponent(str: String).
    ///
    /// - Note: This method only works with file paths (not, for example, string representations of URLs.
    ///   See NSString [appendingPathComponent(_:)](https://developer.apple.com/documentation/foundation/nsstring/1417069-appendingpathcomponent)
    /// - Parameter str: the path component to append to the receiver.
    /// - Returns: a new string made by appending aString to the receiver, preceded if necessary by a path separator.
    public func appendingPathComponent(_ str: String) -> String

    /// ReerKit: NSString appendingPathExtension(str: String).
    ///
    /// - Parameter str: The extension to append to the receiver.
    /// - Returns: a new string made by appending to the receiver an extension separator followed by ext (if applicable).
    public func appendingPathExtension(_ str: String) -> String?

    /// ReerKit: Accesses a contiguous subrange of the collection’s elements.
    /// - Parameter bounds: A range of the collection’s indices. The bounds of the range must be valid indices of the collection.
    /// - Returns: A slice of the receiving string.
    public subscript(bounds: NSRange) -> Substring { get }
}

public extension Reer where Base == String {

    /// ReerKit: Add attributes to string.
    /// - Parameter attributes: The attributes for the new attributed string. For a list of attributes that you can include in this dictionary, see NSAttributedString.Key.
    /// - Returns: A attributed string.
    public func with(attributes: [NSAttributedString.Key : Any]?) -> NSMutableAttributedString
}

public extension Reer where Base == String {

    /// ReerKit: Returns a lowercase String for md2 hash.
    public var md2String: String? { get }

    /// ReerKit: Returns a lowercase String for md4 hash.
    public var md4String: String? { get }

    /// ReerKit: Returns a lowercase String for md5 hash.
    public var md5String: String? { get }

    /// ReerKit: Returns a lowercase String for sha1 hash.
    public var sha1String: String? { get }

    /// ReerKit: Returns a lowercase String for sha224 hash.
    public var sha224String: String? { get }

    /// ReerKit: Returns a lowercase String for sha256 hash.
    public var sha256String: String? { get }

    /// ReerKit: Returns a lowercase String for sha384 hash.
    public var sha384String: String? { get }

    /// ReerKit: Returns a lowercase String for sha512 hash.
    public var sha512String: String? { get }

    /// ReerKit: Returns a base64 encoded string of the encrypted Data using AES.
    ///
    /// - Parameters:
    ///   - key: A key with a length of 16(AES128), 24(AES192) or 32(AES256) after conversion to data
    ///   - iv: An initialization vector with a length of 16(CBC) after conversion to data, or use the default data that length of 0(EBC)
    /// - Returns: A base64 encoded string of the encrypted Data encrypted, or nil if an error occurs.
    public func aesEncrypt(withKey key: String, iv: String = "") -> String?

    /// ReerKit: Returns an decrypted `String` using AES.
    ///
    /// - Parameters:
    ///   - key: A key with a length of 16(AES128), 24(AES192) or 32(AES256) after conversion to data
    ///   - iv: An initialization vector with a length of 16(CBC) after conversion to data, or use the default data that length of 0(EBC)
    /// - Returns: A decrypted string, or nil if an error occurs.
    public func aesDecrypt(withKey key: String, iv: String = "") -> String?

    /// ReerKit: Returns an RSA encrypted data string.
    /// - Parameter publicKey: RSA public key.
    /// - Returns: A base64 string represent the ecrypted data, or nil if an error occurs.
    public func rsaEncrypt(with publicKey: String) -> String?

    /// ReerKit: Returns an RSA decrypted data string.
    /// - Parameter privateKey: RSA private key.
    /// - Returns: A `String` decrypted, or nil if an error occurs.
    public func rsaDecrypt(with privateKey: String) -> String?

    /// ReerKit: Returns an RSA signed data string.
    /// - Parameter privateKey: RSA private key.
    /// - Returns: A base64 string represent the signature data, or nil if an error occurs.
    public func rsaSigned(with privateKey: String) -> String?

    /// ReerKit: Returns an RSA verified data string.
    /// - Parameter publicKey: RSA public key.
    /// - Returns: A verified `String`, or nil if an error occurs.
    public func rsaVerified(with publicKey: String) -> String?
}
```

### StringProtocol

```
import Foundation

public extension ReerForStringProtocol where Base: StringProtocol {

    /// ReerKit: The longest common suffix.
    ///
    ///        "Hello world!".re.commonSuffix(with: "It's cold!") = "ld!"
    ///
    /// - Parameters:
    ///     - Parameter aString: The string with which to compare the receiver.
    ///     - Parameter options: Options for the comparison.
    /// - Returns: The longest common suffix of the receiver and the given String.
    public func commonSuffix<T>(with aString: T, options: String.CompareOptions = []) -> String where T : StringProtocol
}
```

## Foundation+REExtensions

### Bundle

```
import Foundation

public extension Reer where Base: Bundle {

    /// ReerKit: Check file exist in the bundle.
    ///
    ///     Bundle.main.re.fileExists(withName: "abc.json")
    ///
    public func fileExists(withName name: String) -> Bool
}
```

### Calendar

```
import Foundation

extension Calendar: ReerCompatibleValue {}
public extension Reer where Base == Calendar {

    /// ReerKit: Return the number of days in the month for a specified 'Date'.
    ///
    ///        let date = Date() // "Jan 12, 2017, 7:07 PM"
    ///        Calendar.current.re.numberOfDaysInMonth(for: date) -> 31
    ///
    /// - Parameter date: the date form which the number of days in month is calculated.
    /// - Returns: The number of days in the month of 'Date'.
    public func numberOfDaysInMonth(for date: Date) -> Int
}
```

### ContiguousBytes

```
import Foundation

public struct ReerForContiguousBytes<Base> {

    public let base: Base

    public init(_ base: Base)
}

public extension ContiguousBytes {

    /// Gets a namespace holder for ReerKit compatible types.
    public var re: ReerForContiguousBytes<Self> { get set }

    /// Gets a namespace holder for ReerKit compatible meta types.
    public static var re: ReerForContiguousBytes<Self>.Type { get set }
}

public extension ReerForContiguousBytes where Base : ContiguousBytes {

    /// ReerKit: Transform `ContiguousBytes` to `Data`
    public var data: Data { get }
}
```

### Data

```
import Foundation
import CommonCrypto
import zlib

public extension Data {

    /// ReerKit: Convert hex string to Data.
    public static func re(hexString: String) -> Data?

    /// ReerKit: Create a data from a file in bundle.
    public static func re(fileName: String, inBundle bundle: Bundle = .main) -> Data?
}

public enum JSONError : Error {

    case invalidDict

    case invalidArray
}

public extension ReerForEquatable where Base == Data {

    /// ReerKit: Return data as an array of bytes.
    public var bytes: [UInt8] { get }

    /// ReerKit: Returns string decoded in UTF8.
    public var utf8String: String? { get }

    /// ReerKit: String by encoding Data using the given encoding (if applicable).
    ///
    /// - Parameter encoding: encoding.
    /// - Returns: String by encoding Data using the given encoding (if applicable).
    public func string(encoding: String.Encoding = .utf8) -> String?

    /// ReerKit: Returns a lowercase String in hex.
    public var hexString: String? { get }

    /// ReerKit: Returns an Dictionary or Array for decoded self.
    /// Returns nil if an error occurs.
    /// - Returns: an Dictionary or Array for decoded self.
    public var jsonValue: Any? { get }

    /// ReerKit: Returns a Foundation object from given JSON data.
    ///
    /// - Parameter options: Options for reading the JSON data and creating the Foundation object.
    ///
    ///   For possible values, see `JSONSerialization.ReadingOptions`.
    /// - Throws: An `NSError` if the receiver does not represent a valid JSON object.
    /// - Returns: A Foundation object from the JSON data in the receiver, or `nil` if an error occurs.
    public func jsonValue(options: JSONSerialization.ReadingOptions = []) throws -> Any

    /// ReerKit: Returns an Dictionary for decoded self.
    /// Returns nil if an error occurs.
    public var dictionary: [AnyHashable : Any]? { get }

    /// ReerKit: Returns [String: Any] for decoded self.
    /// Returns nil if an error occurs.
    public var stringAnyDictionary: [String : Any]? { get }

    /// ReerKit: Returns [String: String] for decoded self.
    /// Returns nil if an error occurs.
    public var stringDictionary: [String : String]? { get }

    /// ReerKit: Returns an Dictionary for decoded self.
    public func toDictionary() throws -> [AnyHashable : Any]

    /// ReerKit: Returns an Array for decoded self.
    /// Returns nil if an error occurs.
    public var array: [Any]? { get }

    /// ReerKit: Returns an Array for decoded self.
    public func toArray() throws -> [Any]

    /// ReerKit: Generate a random length of Data.
    public static func random(ofLength length: Int) -> Data
}

public extension ReerForEquatable where Base == Data {

    /// ReerKit: Returns an Data for md2 hash.
    public var md2Data: Data? { get }

    /// ReerKit: Returns a lowercase String for md2 hash.
    public var md2String: String? { get }

    /// ReerKit: Returns an Data for md4 hash.
    public var md4Data: Data? { get }

    /// ReerKit: Returns a lowercase String for md4 hash.
    public var md4String: String? { get }

    /// ReerKit: Returns an Data for md5 hash.
    public var md5Data: Data? { get }

    /// ReerKit: Returns a lowercase String for md5 hash.
    public var md5String: String? { get }

    /// ReerKit: Returns an Data for sha1 hash.
    public var sha1Data: Data? { get }

    /// ReerKit: Returns a lowercase String for sha1 hash.
    public var sha1String: String? { get }

    /// ReerKit: Returns an Data for sha224 hash.
    public var sha224Data: Data? { get }

    /// ReerKit: Returns a lowercase String for sha224 hash.
    public var sha224String: String? { get }

    /// ReerKit: Returns an Data for sha256 hash.
    public var sha256Data: Data? { get }

    /// ReerKit: Returns a lowercase String for sha256 hash.
    public var sha256String: String? { get }

    /// ReerKit: Returns an Data for sha384 hash.
    public var sha384Data: Data? { get }

    /// ReerKit: Returns a lowercase String for sha384 hash.
    public var sha384String: String? { get }

    /// ReerKit: Returns an Data for sha512 hash.
    public var sha512Data: Data? { get }

    /// ReerKit: Returns a lowercase String for sha512 hash.
    public var sha512String: String? { get }
}

public enum HMACAlgorithm {

    case md5, sha1, sha224, sha256, sha384, sha512
}

public extension ReerForEquatable where Base == Data {

    /// ReerKit: Returns a lowercase String for hmac using the algorithm with key.
    /// - Parameters:
    ///   - alg: HMAC algorithm.
    ///   - key: The hmac key.
    /// - Returns: HMAC handled hex string.
    public func hmacString(using alg: HMACAlgorithm, key: String) -> String?

    /// ReerKit: Returns a Data for hmac using the algorithm with key.
    /// - Parameters:
    ///   - alg: HMAC algorithm.
    ///   - key: The hmac key.
    /// - Returns: HMAC handled data.
    public func hmacData(using alg: HMACAlgorithm, key: String) -> Data?

    /// ReerKit: Returns a lowercase String for hmac using the algorithm with key data.
    /// - Parameters:
    ///   - alg: HMAC algorithm.
    ///   - key: The hmac key.
    /// - Returns: HMAC handled hex string.
    public func hmacString(using alg: HMACAlgorithm, key: Data) -> String?

    /// ReerKit: Returns a Data for hmac using the algorithm with key data.
    /// - Parameters:
    ///   - alg: HMAC algorithm.
    ///   - key: The hmac key.
    /// - Returns: HMAC handled data.
    public func hmacData(using alg: HMACAlgorithm, key: Data) -> Data?
}

public extension ReerForEquatable where Base == Data {

    /// ReerKit: Returns an encrypted Data using AES.
    ///
    /// - Parameters:
    ///   - key: A key length of 16(AES128), 24(AES192) or 32(AES256)
    ///   - iv: An initialization vector length of 16(CBC), or use the default data that length of 0(ECB)
    /// - Returns: A `Data` encrypted, or nil if an error occurs.
    public func aesEncrypt(withKey key: Data, iv: Data = .init()) -> Data?

    /// ReerKit: Returns an decrypted Data using AES.
    ///
    /// - Parameters:
    ///   - key: A key length of 16(AES128), 24(AES192) or 32(AES256)
    ///   - iv: An initialization vector length of 16(CBC), or use the default data that length of 0(ECB)
    /// - Returns: An `Data` decrypted, or nil if an error occurs.
    public func aesDecrypt(withKey key: Data, iv: Data = .init()) -> Data?

    /// ReerKit: Returns an RSA encrypted data.
    /// - Parameter publicKey: RSA public key.
    /// - Returns: A `Data` encrypted, or nil if an error occurs.
    public func rsaEncrypt(with publicKey: String) -> Data?

    /// ReerKit: Returns an RSA decrypted data.
    /// - Parameter privateKey: RSA private key.
    /// - Returns: A `Data` decrypted, or nil if an error occurs.
    public func rsaDecrypt(with privateKey: String) -> Data?

    /// ReerKit: Returns an RSA signed data.
    /// - Parameter privateKey: RSA private key.
    /// - Returns: A signature, or nil if an error occurs.
    public func rsaSigned(with privateKey: String) -> Data?

    /// ReerKit: Returns an RSA verified data.
    /// - Parameter publicKey: RSA public key.
    /// - Returns: A verified `Data`, or nil if an error occurs.
    public func rsaVerified(with publicKey: String) -> Data?
}

/// ReerKit: Compression level whose rawValue is based on the zlib's constants.
public struct CompressionLevel : RawRepresentable {

    /// Compression level in the range of `0` (no compression) to `9` (maximum compression).
    public let rawValue: Int32

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init(rawValue: Int32)

    public static let noCompression: main.CompressionLevel

    public static let bestSpeed: main.CompressionLevel

    public static let bestCompression: main.CompressionLevel

    public static let defaultCompression: main.CompressionLevel
}

public extension ReerForEquatable where Base == Data {

    /// ReerKit: Whether the receiver is compressed in gzip format.
    public var isGzipped: Bool { get }

    /// ReerKit: Whether the receiver is compressed in zlib format.
    public var isZlibbed: Bool { get }

    /// ReerKit: Comperss data to zlib-compressed in default compresssion level.
    ///
    /// - Returns: Compressed data.
    public func zlibCompressed(level: CompressionLevel = .defaultCompression) -> Data?

    /// ReerKit: Decompress data from zlib-compressed data.
    ///
    /// - Returns: Decompressed data.
    public func zlibDecompressed() -> Data?

    /// ReerKit: Compress data to gzip in default compresssion level.
    ///
    /// - Returns: Compressed data.
    public func gzipCompressed(level: CompressionLevel = .defaultCompression) -> Data?

    /// ReerKit: Decompress data from gzip data.
    ///
    /// - Returns: Decompressed data.
    public func gzipDecompressed() -> Data?
}
```

### Date

```
import Foundation
import Darwin

public extension Date {

    /// ReerKit: Day name format.
    ///
    /// - threeLetters: 3 letter day abbreviation of day name.
    /// - oneLetter: 1 letter day abbreviation of day name.
    /// - full: Full day name.
    public enum NameStyle {

        /// ReerKit: 3 letter day abbreviation of day name.
        case threeLetters

        /// ReerKit: 1 letter day abbreviation of day name.
        case oneLetter

        /// ReerKit: Full day name.
        case full
    }
}

public extension ReerForEquatable where Base == Date {

    /// ReerKit: User’s current calendar.
    public var calendar: Calendar { get }

    /// ReerKit: Era.
    ///
    ///        Date().re.era -> 1
    ///
    public var era: Int { get }

    /// ReerKit: Quarter.
    ///
    ///        Date().quarter -> 3 // date in third quarter of the year.
    ///
    public var quarter: Int { get }

    /// ReerKit: Week of year.
    ///
    ///        Date().weekOfYear -> 2 // second week in the year.
    ///
    public var weekOfYear: Int { get }

    /// ReerKit: Week of month.
    ///
    ///        Date().weekOfMonth -> 3 // date is in third week of the month.
    ///
    public var weekOfMonth: Int { get }

    /// ReerKit: Weekday.
    ///
    ///     Date().weekday -> 5 // fifth day in the current week.
    ///
    public var weekday: Int { get }

    /// ReerKit: Year.
    ///
    ///        Date().year -> 2017
    ///
    public var year: Int { get }

    /// ReerKit: Month.
    ///
    ///     Date().month -> 1
    ///
    public var month: Int { get }

    /// ReerKit: Day.
    ///
    ///     Date().day -> 12
    ///
    public var day: Int { get }

    /// ReerKit: Hour.
    ///
    ///     Date().hour -> 17 // 5 pm
    ///
    ///     var someDate = Date()
    ///     someDate.hour = 13 // sets someDate's hour to 1 pm.
    ///
    public var hour: Int { get }

    /// ReerKit: Minutes.
    ///
    ///     Date().minute -> 39
    ///
    ///     var someDate = Date()
    ///     someDate.minute = 10 // sets someDate's minutes to 10.
    ///
    public var minute: Int { get }

    /// ReerKit: Seconds.
    ///
    ///     Date().second -> 55
    ///
    ///     var someDate = Date()
    ///     someDate.second = 15 // sets someDate's seconds to 15.
    ///
    public var second: Int { get }

    /// ReerKit: Nanoseconds.
    ///
    ///     Date().nanosecond -> 981379985
    ///
    ///     var someDate = Date()
    ///     someDate.nanosecond = 981379985 // sets someDate's seconds to 981379985.
    ///
    public var nanosecond: Int { get }

    /// ReerKit: Milliseconds.
    ///
    ///     Date().millisecond -> 68
    ///
    ///     var someDate = Date()
    ///     someDate.millisecond = 68 // sets someDate's nanosecond to 68000000.
    ///
    public var millisecond: Int { get }

    /// ReerKit: Check if date is in leap year
    public var isLeapYear: Bool { get }

    /// ReerKit: Check if date is within today.
    ///
    ///     Date().isToday -> true
    ///
    public var isToday: Bool { get }

    /// ReerKit: Check if date is within yesterday.
    ///
    ///     Date().isYesterday -> false
    ///
    public var isYesterday: Bool { get }

    /// ReerKit: Check if date is in future.
    ///
    ///     Date(timeInterval: 100, since: Date()).isFuture -> true
    ///
    public var isFuture: Bool { get }

    /// ReerKit: Check if date is in past.
    ///
    ///     Date(timeInterval: -100, since: Date()).isPast -> true
    ///
    public var isPast: Bool { get }

    /// ReerKit: Check if date is within tomorrow.
    ///
    ///     Date().isTomorrow -> false
    ///
    public var isTomorrow: Bool { get }

    /// ReerKit: Check if date is within a weekend period.
    public var isWeekend: Bool { get }

    /// ReerKit: Check if date is within a weekday period.
    public var isWorkday: Bool { get }

    /// ReerKit: Check if date is within the current week.
    public var isThisWeek: Bool { get }

    /// ReerKit: Check if date is within the current month.
    public var isThisMonth: Bool { get }

    /// ReerKit: Check if date is within the current year.
    public var isThisYear: Bool { get }

    /// ReerKit: ISO8601 string of format (yyyy-MM-dd'T'HH:mm:ss.SSS) from date.
    ///
    ///     Date().iso8601String -> "2017-01-12T14:51:29.574Z"
    ///
    public var iso8601String: String { get }

    /// ReerKit: Nearest five minutes to date.
    ///
    ///     var date = Date() // "5:54 PM"
    ///     date.minute = 32 // "5:32 PM"
    ///     date.nearestFiveMinutes // "5:30 PM"
    ///
    ///     date.minute = 44 // "5:44 PM"
    ///     date.nearestFiveMinutes // "5:45 PM"
    ///
    public var nearestFiveMinutes: Date { get }

    /// ReerKit: Nearest ten minutes to date.
    ///
    ///     var date = Date() // "5:57 PM"
    ///     date.minute = 34 // "5:34 PM"
    ///     date.nearestTenMinutes // "5:30 PM"
    ///
    ///     date.minute = 48 // "5:48 PM"
    ///     date.nearestTenMinutes // "5:50 PM"
    ///
    public var nearestTenMinutes: Date { get }

    /// ReerKit: Nearest quarter hour to date.
    ///
    ///     var date = Date() // "5:57 PM"
    ///     date.minute = 34 // "5:34 PM"
    ///     date.nearestQuarterHour // "5:30 PM"
    ///
    ///     date.minute = 40 // "5:40 PM"
    ///     date.nearestQuarterHour // "5:45 PM"
    ///
    public var nearestQuarterHour: Date { get }

    /// ReerKit: Nearest half hour to date.
    ///
    ///     var date = Date() // "6:07 PM"
    ///     date.minute = 41 // "6:41 PM"
    ///     date.nearestHalfHour // "6:30 PM"
    ///
    ///     date.minute = 51 // "6:51 PM"
    ///     date.nearestHalfHour // "7:00 PM"
    ///
    public var nearestHalfHour: Date { get }

    /// ReerKit: Nearest hour to date.
    ///
    ///     var date = Date() // "6:17 PM"
    ///     date.nearestHour // "6:00 PM"
    ///
    ///     date.minute = 36 // "6:36 PM"
    ///     date.nearestHour // "7:00 PM"
    ///
    public var nearestHour: Date { get }

    /// ReerKit: Yesterday date.
    ///
    ///     let date = Date() // "Oct 3, 2018, 10:57:11"
    ///     let yesterday = date.yesterday // "Oct 2, 2018, 10:57:11"
    ///
    public var yesterday: Date { get }

    /// ReerKit: Tomorrow's date.
    ///
    ///     let date = Date() // "Oct 3, 2018, 10:57:11"
    ///     let tomorrow = date.tomorrow // "Oct 4, 2018, 10:57:11"
    ///
    public var tomorrow: Date { get }

    /// ReerKit: UNIX timestamp from date.
    ///
    ///        Date().unixTimestamp -> 1484233862.826291
    ///
    public var unixTimestamp: Double { get }

    /// ReerKit: Return Int milliseconds timestamp.
    public var millisecondsSince1970: Int { get }

    /// ReerKit: Calculates the number of milliseconds from this date to now
    ///
    /// - Returns: An integer representing the number of milliseconds from this date to now.
    ///            If this date is in the future, the returned value will be negative.
    ///
    /// - Note: This method uses `timeIntervalSince` to calculate the time difference,
    ///         then multiplies the result by 1000 to convert it to milliseconds.
    ///         The result is rounded to the nearest integer.
    public var millisecondsToNow: Int { get }

    /// ReerKit: Date by adding multiples of calendar component.
    ///
    ///     let date = Date() // "Jan 12, 2017, 7:07 PM"
    ///     let date2 = date.adding(.minute, value: -10) // "Jan 12, 2017, 6:57 PM"
    ///     let date3 = date.adding(.day, value: 4) // "Jan 16, 2017, 7:07 PM"
    ///     let date4 = date.adding(.month, value: 2) // "Mar 12, 2017, 7:07 PM"
    ///     let date5 = date.adding(.year, value: 13) // "Jan 12, 2030, 7:07 PM"
    ///
    /// - Parameters:
    ///   - component: component type.
    ///   - value: multiples of components to add.
    /// - Returns: original date + multiples of component added.
    public func adding(_ component: Calendar.Component, value: Int) -> Date

    /// ReerKit: Date by changing value of calendar component.
    ///
    ///     let date = Date() // "Jan 12, 2017, 7:07 PM"
    ///     let date2 = date.changing(.minute, value: 10) // "Jan 12, 2017, 7:10 PM"
    ///     let date3 = date.changing(.day, value: 4) // "Jan 4, 2017, 7:07 PM"
    ///     let date4 = date.changing(.month, value: 2) // "Feb 12, 2017, 7:07 PM"
    ///     let date5 = date.changing(.year, value: 2000) // "Jan 12, 2000, 7:07 PM"
    ///
    /// - Parameters:
    ///   - component: component type.
    ///   - value: new value of component to change.
    /// - Returns: original date after changing given component to given value.
    public func changing(_ component: Calendar.Component, value: Int) -> Date?

    /// ReerKit: Date at the beginning of calendar component.
    ///
    ///     let date = Date() // "Jan 12, 2017, 7:14 PM"
    ///     let date2 = date.beginning(of: .hour) // "Jan 12, 2017, 7:00 PM"
    ///     let date3 = date.beginning(of: .month) // "Jan 1, 2017, 12:00 AM"
    ///     let date4 = date.beginning(of: .year) // "Jan 1, 2017, 12:00 AM"
    ///
    /// - Parameter component: calendar component to get date at the beginning of.
    /// - Returns: date at the beginning of calendar component (if applicable).
    public func beginning(of component: Calendar.Component) -> Date?

    /// ReerKit: Date at the end of calendar component.
    ///
    ///     let date = Date() // "Jan 12, 2017, 7:27 PM"
    ///     let date2 = date.end(of: .day) // "Jan 12, 2017, 11:59 PM"
    ///     let date3 = date.end(of: .month) // "Jan 31, 2017, 11:59 PM"
    ///     let date4 = date.end(of: .year) // "Dec 31, 2017, 11:59 PM"
    ///
    /// - Parameter component: calendar component to get date at the end of.
    /// - Returns: date at the end of calendar component (if applicable).
    public func end(of component: Calendar.Component) -> Date?

    /// ReerKit: Check if date is in current given calendar component.
    ///
    ///     Date().isInCurrent(.day) -> true
    ///     Date().isInCurrent(.year) -> true
    ///
    /// - Parameter component: calendar component to check.
    /// - Returns: true if date is in current given calendar component.
    public func isInCurrent(_ component: Calendar.Component) -> Bool

    /// ReerKit: Date string from date.
    ///
    ///     Date().string(withFormat: "dd/MM/yyyy") -> "1/12/17"
    ///     Date().string(withFormat: "HH:mm") -> "23:50"
    ///     Date().string(withFormat: "dd/MM/yyyy HH:mm") -> "1/12/17 23:50"
    ///
    /// - Parameter format: Date format (default is "dd/MM/yyyy").
    /// - Returns: date string.
    public func string(withFormat format: String = "dd/MM/yyyy HH:mm") -> String

    /// ReerKit: Date string from date.
    ///
    ///     Date().dateString(ofStyle: .short) -> "1/12/17"
    ///     Date().dateString(ofStyle: .medium) -> "Jan 12, 2017"
    ///     Date().dateString(ofStyle: .long) -> "January 12, 2017"
    ///     Date().dateString(ofStyle: .full) -> "Thursday, January 12, 2017"
    ///
    /// - Parameter style: DateFormatter style (default is .medium).
    /// - Returns: date string.
    public func dateString(ofStyle style: DateFormatter.Style = .medium) -> String

    /// ReerKit: Date and time string from date.
    ///
    ///     Date().dateTimeString(ofStyle: .short) -> "1/12/17, 7:32 PM"
    ///     Date().dateTimeString(ofStyle: .medium) -> "Jan 12, 2017, 7:32:00 PM"
    ///     Date().dateTimeString(ofStyle: .long) -> "January 12, 2017 at 7:32:00 PM GMT+3"
    ///     Date().dateTimeString(ofStyle: .full) -> "Thursday, January 12, 2017 at 7:32:00 PM GMT+03:00"
    ///
    /// - Parameter style: DateFormatter style (default is .medium).
    /// - Returns: date and time string.
    public func dateTimeString(ofStyle style: DateFormatter.Style = .medium) -> String

    /// ReerKit: Time string from date.
    ///
    ///     Date().timeString(ofStyle: .short) -> "7:37 PM"
    ///     Date().timeString(ofStyle: .medium) -> "7:37:02 PM"
    ///     Date().timeString(ofStyle: .long) -> "7:37:02 PM GMT+3"
    ///     Date().timeString(ofStyle: .full) -> "7:37:02 PM GMT+03:00"
    ///
    /// - Parameter style: DateFormatter style (default is .medium).
    /// - Returns: time string.
    public func timeString(ofStyle style: DateFormatter.Style = .medium) -> String

    /// ReerKit: Day name from date.
    ///
    ///     Date().dayName(ofStyle: .oneLetter) -> "T"
    ///     Date().dayName(ofStyle: .threeLetters) -> "Thu"
    ///     Date().dayName(ofStyle: .full) -> "Thursday"
    ///
    /// - Parameter style: style of day name (default is NameStyle.full).
    /// - Returns: day name string (example: W, Wed, Wednesday).
    public func dayName(ofStyle style: Date.NameStyle = .full) -> String

    /// ReerKit: Month name from date.
    ///
    ///     Date().monthName(ofStyle: .oneLetter) -> "J"
    ///     Date().monthName(ofStyle: .threeLetters) -> "Jan"
    ///     Date().monthName(ofStyle: .full) -> "January"
    ///
    /// - Parameter style: style of month name (default is NameStyle.full).
    /// - Returns: month name string (example: D, Dec, December).
    public func monthName(ofStyle style: Date.NameStyle = .full) -> String

    /// ReerKit: get number of milliseconds between two date
    ///
    /// - Parameter date: date to compare self to.
    /// - Returns: number of milliseconds between self and given date.
    public func millisecondsSince(_ date: Date) -> Double

    /// ReerKit: get number of seconds between two date
    ///
    /// - Parameter date: date to compare self to.
    /// - Returns: number of seconds between self and given date.
    public func secondsSince(_ date: Date) -> Double

    /// ReerKit: get number of minutes between two date
    ///
    /// - Parameter date: date to compare self to.
    /// - Returns: number of minutes between self and given date.
    public func minutesSince(_ date: Date) -> Double

    /// ReerKit: get number of hours between two date
    ///
    /// - Parameter date: date to compare self to.
    /// - Returns: number of hours between self and given date.
    public func hoursSince(_ date: Date) -> Double

    /// ReerKit: get number of days between two date
    ///
    /// - Parameter date: date to compare self to.
    /// - Returns: number of days between self and given date.
    public func daysSince(_ date: Date) -> Double

    /// ReerKit: check if a date is between two other dates.
    ///
    /// - Parameters:
    ///   - startDate: start date to compare self to.
    ///   - endDate: endDate date to compare self to.
    ///   - includeBounds: true if the start and end date should be included (default is false).
    /// - Returns: true if the date is between the two given dates.
    public func isBetween(_ startDate: Date, _ endDate: Date, includeBounds: Bool = false) -> Bool

    /// ReerKit: check if a date is a number of date components of another date.
    ///
    /// - Parameters:
    ///   - value: number of times component is used in creating range.
    ///   - component: Calendar.Component to use.
    ///   - date: Date to compare self to.
    /// - Returns: true if the date is within a number of components of another date.
    public func isWithin(_ value: UInt, _ component: Calendar.Component, of date: Date) -> Bool

    /// ReerKit: Returns a random date within the specified range.
    ///
    /// - Parameter range: The range in which to create a random date. `range` must not be empty.
    /// - Returns: A random date within the bounds of `range`.
    public static func random(in range: Range<Date>) -> Date

    /// ReerKit: Returns a random date within the specified range.
    ///
    /// - Parameter range: The range in which to create a random date.
    /// - Returns: A random date within the bounds of `range`.
    public static func random(in range: ClosedRange<Date>) -> Date

    /// ReerKit: Returns a random date within the specified range, using the given generator as a source for randomness.
    ///
    /// - Parameters:
    ///   - range: The range in which to create a random date. `range` must not be empty.
    ///   - generator: The random number generator to use when creating the new random date.
    /// - Returns: A random date within the bounds of `range`.
    public static func random<T>(in range: Range<Date>, using generator: inout T) -> Date where T : RandomNumberGenerator

    /// ReerKit: Returns a random date within the specified range, using the given generator as a source for randomness.
    ///
    /// - Parameters:
    ///   - range: The range in which to create a random date.
    ///   - generator: The random number generator to use when creating the new random date.
    /// - Returns: A random date within the bounds of `range`.
    public static func random<T>(in range: ClosedRange<Date>, using generator: inout T) -> Date where T : RandomNumberGenerator
}

extension Date: ReerReferenceCompatible {}
public extension ReerReference where Base == Date {

    /// ReerKit: Add calendar component to date.
    ///
    ///     var date = Date() // "Jan 12, 2017, 7:07 PM"
    ///     date.add(.minute, value: -10) // "Jan 12, 2017, 6:57 PM"
    ///     date.add(.day, value: 4) // "Jan 16, 2017, 7:07 PM"
    ///     date.add(.month, value: 2) // "Mar 12, 2017, 7:07 PM"
    ///     date.add(.year, value: 13) // "Jan 12, 2030, 7:07 PM"
    ///
    /// - Parameters:
    ///   - component: component type.
    ///   - value: multiples of component to add.
    public mutating func add(_ component: Calendar.Component, value: Int)

    /// ReerKit: Setup year of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setYear(2000)  // sets someDate's year to 2000
    ///
    public mutating func setYear(_ year: Int)

    /// ReerKit: Setup month of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setMonth(10)  // sets someDate's month to 10.
    ///
    public mutating func setMonth(_ month: Int)

    /// ReerKit: Setup day of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setDay(1)  // sets someDate's day of month to 1.
    ///
    public mutating func setDay(_ day: Int)

    /// ReerKit: Setup hour of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setHour(13)  // sets someDate's hour to 1 pm.
    ///
    public mutating func setHour(_ hour: Int)

    /// ReerKit: Setup minute of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setMinute(10)  // sets someDate's minutes to 10.
    ///
    public mutating func setMinute(_ minute: Int)

    /// ReerKit: Setup second of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setSecond(15)  // sets someDate's seconds to 15.
    ///
    public mutating func setSecond(_ second: Int)

    /// ReerKit: Setup nanosecond of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setNanosecond(981379985)  // sets someDate's nanoseconds to 981379985.
    ///
    public mutating func setNanosecond(_ nanosecond: Int)

    /// ReerKit: Setup millisecond of date.
    ///
    ///        var someDate = Date()
    ///        someDate.re.setMillisecond(68)  // sets someDate's nanosecond to 68000000.
    ///
    public mutating func setMillisecond(_ millisecond: Int)
}

public extension Date {

    /// ReerKit: Create a new date form calendar components.
    ///
    ///     let date = Date(year: 2010, month: 1, day: 12) // "Jan 12, 2010, 7:45 PM"
    ///
    /// - Parameters:
    ///   - calendar: Calendar (default is current).
    ///   - timeZone: TimeZone (default is current).
    ///   - era: Era (default is current era).
    ///   - year: Year (default is current year).
    ///   - month: Month (default is current month).
    ///   - day: Day (default is today).
    ///   - hour: Hour (default is current hour).
    ///   - minute: Minute (default is current minute).
    ///   - second: Second (default is current second).
    ///   - nanosecond: Nanosecond (default is current nanosecond).
    public static func re(calendar: Calendar? = Calendar.current, timeZone: TimeZone? = NSTimeZone.default, era: Int? = Date().re.era, year: Int? = Date().re.year, month: Int? = Date().re.month, day: Int? = Date().re.day, hour: Int? = Date().re.hour, minute: Int? = Date().re.minute, second: Int? = Date().re.second, nanosecond: Int? = Date().re.nanosecond) -> Date?

    /// ReerKit: Create date object from ISO8601 string.
    ///
    ///     let date = Date(iso8601String: "2017-01-12T16:48:00.959Z") // "Jan 12, 2017, 7:48 PM"
    ///
    /// - Parameter iso8601String: ISO8601 string of format (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
    public static func re(iso8601String: String) -> Date?

    /// ReerKit: Create new date object from UNIX timestamp.
    ///
    ///     let date = Date(unixTimestamp: 1484239783.922743) // "Jan 12, 2017, 7:49 PM"
    ///
    /// - Parameter unixTimestamp: UNIX timestamp.
    public static func re(unixTimestamp: Double) -> Date
}
```

### FileManager

```
import Foundation

public extension Reer where Base: FileManager {

    /// ReerKit: Read from a JSON file at a given path.
    ///
    /// - Parameters:
    ///   - path: JSON file path.
    ///   - readingOptions: JSONSerialization reading options.
    /// - Throws: Throws any errors thrown by Data creation or JSON serialization.
    /// - Returns: Optional dictionary.
    public func jsonFromFile(atPath path: String, readingOptions: JSONSerialization.ReadingOptions = .allowFragments) throws -> [String : Any]?

    /// ReerKit: Read from a JSON file with a given filename.
    ///
    /// - Parameters:
    ///   - filename: File to read.
    ///   - bundleClass: Bundle where the file is associated.
    ///   - readingOptions: JSONSerialization reading options.
    /// - Throws: Throws any errors thrown by Data creation or JSON serialization.
    /// - Returns: Optional dictionary.
    public func jsonFromFile(withFilename filename: String, at bundleClass: AnyClass? = nil, readingOptions: JSONSerialization.ReadingOptions = .allowFragments) throws -> [String : Any]?

    /// ReerKit: Creates a unique directory for saving temporary files. The directory can be used to create multiple temporary files used for a common purpose.
    ///
    ///     let tempDirectory = try fileManager.createTemporaryDirectory()
    ///     let tempFile1URL = tempDirectory.appendingPathComponent(ProcessInfo().globallyUniqueString)
    ///     let tempFile2URL = tempDirectory.appendingPathComponent(ProcessInfo().globallyUniqueString)
    ///
    /// - Throws: An error if a temporary directory cannot be found or created.
    /// - Returns: A URL to a new directory for saving temporary files.
    public func createTemporaryDirectory() throws -> URL
}
```

### Locale

```
import Foundation

public extension ReerForEquatable where Base == Locale {

    /// ReerKit: UNIX representation of locale usually used for normalizing.
    public static var posix: Locale { get }

    /// ReerKit: Returns bool value indicating if locale has 12h format.
    public var is12HourTimeFormat: Bool { get }

    /// ReerKit: Get the flag emoji for a given country region code.
    /// - Parameter isoRegionCode: The IOS region code.
    ///
    /// Adapted from https://stackoverflow.com/a/30403199/1627511
    /// - Returns: A flag emoji string for the given region code (optional).
    public static func flagEmoji(forRegionCode isoRegionCode: String) -> String?
}
```

### NSAttributedString

```
import Foundation
import UIKit

public extension Reer where Base: NSAttributedString {

    /// ReerKit: Dictionary of the attributes applied across the whole string.
    public var attributes: [NSAttributedString.Key : Any] { get }

    @available(*, deprecated, renamed: "numberOfLines(forWidth:ignoreBlankLines:)", message: "Use numberOfLines(forWidth:ignoringBlankLines:) instead.")
    public func lines(forWidth width: CGFloat, ignoreBlankLines: Bool = false) -> Int

    /// ReerKit: Calculate lines for a `NSAttributedString` with a width constrained.
    /// - Parameters:
    ///   - width: A constrained of container view width.
    ///   - ignoreBlankLines: Whether should ignore blank lines.
    /// - Returns: Total lines of the attributed string after rendering.
    public func numberOfLines(forWidth width: CGFloat, ignoreBlankLines: Bool = false) -> Int

    /// ReerKit: Calculate height for a `NSAttributedString` with a constrained width.
    /// - Parameter width: A constrained of container view width.
    /// - Returns: Total height of the attributed string after rendering.
    public func height(forWidth width: CGFloat) -> CGFloat

    /// ReerKit: Calculate width for a `NSAttributedString` with an unlimited height in one line.
    /// - Returns: Width of the attributed string after rendering.
    public func singleLineWidth() -> CGFloat

    /// ReerKit: Applies given attributes to the new instance of NSAttributedString initialized with self object.
    ///
    /// - Parameter attributes: Dictionary of attributes.
    /// - Returns: NSAttributedString with applied attributes.
    public func with(attributes: [NSAttributedString.Key : Any]) -> NSMutableAttributedString

    /// ReerKit: Apply attributes to substrings matching a regular expression.
    ///
    /// - Parameters:
    ///   - attributes: Dictionary of attributes.
    ///   - pattern: a regular expression to target.
    ///   - options: The regular expression options that are applied to the expression during matching. See NSRegularExpression.Options for possible values.
    /// - Returns: An NSAttributedString with attributes applied to substrings matching the pattern.
    public func with(attributes: [NSAttributedString.Key : Any], toRangesMatching pattern: String, options: NSRegularExpression.Options = []) -> NSMutableAttributedString

    /// ReerKit: Apply attributes to occurrences of a given string.
    ///
    /// - Parameters:
    ///   - attributes: Dictionary of attributes.
    ///   - target: a subsequence string for the attributes to be applied to.
    /// - Returns: An NSAttributedString with attributes applied on the target string.
    public func with<T>(attributes: [NSAttributedString.Key : Any], toOccurrencesOf target: T) -> NSMutableAttributedString where T : StringProtocol
}

public extension NSAttributedString {

    /// ReerKit: Add a NSAttributedString to another NSAttributedString.
    ///
    /// - Parameters:
    ///   - lhs: NSAttributedString to add to.
    ///   - rhs: NSAttributedString to add.
    public static func += (lhs: inout NSAttributedString, rhs: NSAttributedString)

    /// ReerKit: Add a NSAttributedString to another NSAttributedString and return a new NSAttributedString instance.
    ///
    /// - Parameters:
    ///   - lhs: NSAttributedString to add.
    ///   - rhs: NSAttributedString to add.
    /// - Returns: New instance with added NSAttributedString.
    public static func + (lhs: NSAttributedString, rhs: NSAttributedString) -> NSMutableAttributedString

    /// ReerKit: Add a NSAttributedString to another NSAttributedString.
    ///
    /// - Parameters:
    ///   - lhs: NSAttributedString to add to.
    ///   - rhs: String to add.
    public static func += (lhs: inout NSAttributedString, rhs: String)

    /// ReerKit: Add a NSAttributedString to another NSAttributedString and return a new NSAttributedString instance.
    ///
    /// - Parameters:
    ///   - lhs: NSAttributedString to add.
    ///   - rhs: String to add.
    /// - Returns: New instance with added NSAttributedString.
    public static func + (lhs: NSAttributedString, rhs: String) -> NSMutableAttributedString
}

public extension ReerGeneric where Base == Array<T>, T: NSAttributedString {

    /// ReerKit: Returns a new `NSAttributedString` by concatenating the elements of the sequence, adding the given separator between each element.
    ///
    /// - Parameter separator: An `NSAttributedString` to add between the elements of the sequence.
    /// - Returns: NSAttributedString with applied attributes.
    public func joined(separator: NSAttributedString) -> NSMutableAttributedString

    public func joined(separator: String) -> NSMutableAttributedString
}
```

### NSObject

```
import ObjectiveC
import Foundation

extension NSObject: ReerCompatible {}


// MARK: - TypeName

extension NSObject: TypeNameDescribable {}


// MARK: - Association & Once & Swizzle & Observe Deinit

extension NSObject: AnyObjectExtensionable {}

public extension Reer where Base: NSObject {

    /// ReerKit: Get all instance variables implemented by the class.
    ///
    /// - Returns: An array of instance variables.
    public static var ivars: [String] { get }

    /// ReerKit: Get all selectors implemented by the class.
    ///
    /// - Returns: An array of selectors.
    public static var ocSelectors: [Selector] { get }

    /// ReerKit: Get all protocols implemented by the class.
    ///
    /// - Returns: An array of protocol names.
    public static var ocProtocols: [String] { get }

    /// ReerKit: Get all properties implemented by the class.
    ///
    /// - Returns: An array of property names.
    public static var ocProperties: [String] { get }

    /// ReerKit: Add a selector that is implemented on another object to the current class.
    ///
    /// - Parameters:
    ///   - selector: Selector.
    ///   - originalClass: Object implementing the selector.
    public static func addSelector(_ selector: Selector, from originalClass: AnyClass)

    /// ReerKit: Add a custom method to the current class.
    ///
    /// - Parameters:
    ///   - identifier: Selector name.
    ///   - implementation: Implementation as a closure.
    public static func addMethod(_ identifier: String, implementation: @convention(block) @escaping () -> Void)

    /// ReerKit: A convenience method to perform selectors by identifier strings.
    ///
    /// - Parameter identifier: Selector name.
    public func performMethod(_ identifier: String)
}
```

### NSPredicate

```
import Foundation

public extension Reer where Base: NSPredicate {

    /// ReerKit Returns a new predicate formed by NOT-ing the predicate.
    public var not: NSCompoundPredicate { get }

    /// ReerKit Returns a new predicate formed by AND-ing the argument to the predicate.
    ///
    /// - Parameter predicate: NSPredicate.
    /// - Returns: NSCompoundPredicate.
    public func and(_ predicate: NSPredicate) -> NSCompoundPredicate

    /// ReerKit Returns a new predicate formed by OR-ing the argument to the predicate.
    ///
    /// - Parameter predicate: NSPredicate.
    /// - Returns: NSCompoundPredicate.
    public func or(_ predicate: NSPredicate) -> NSCompoundPredicate
}

public extension NSPredicate {

    /// ReerKit Returns a new predicate formed by NOT-ing the predicate.
    /// - Parameters: rhs: NSPredicate to convert.
    /// - Returns: NSCompoundPredicate
    prefix public static func ! (rhs: NSPredicate) -> NSCompoundPredicate

    /// ReerKit Returns a new predicate formed by AND-ing the argument to the predicate.
    ///
    /// - Parameters:
    ///   - lhs: NSPredicate.
    ///   - rhs: NSPredicate.
    /// - Returns: NSCompoundPredicate
    public static func + (lhs: NSPredicate, rhs: NSPredicate) -> NSCompoundPredicate

    /// ReerKit Returns a new predicate formed by OR-ing the argument to the predicate.
    ///
    /// - Parameters:
    ///   - lhs: NSPredicate.
    ///   - rhs: NSPredicate.
    /// - Returns: NSCompoundPredicate
    public static func | (lhs: NSPredicate, rhs: NSPredicate) -> NSCompoundPredicate

    /// ReerKit Returns a new predicate formed by remove the argument to the predicate.
    ///
    /// - Parameters:
    ///   - lhs: NSPredicate.
    ///   - rhs: NSPredicate.
    /// - Returns: NSCompoundPredicate
    public static func - (lhs: NSPredicate, rhs: NSPredicate) -> NSCompoundPredicate
}
```

### NSRange

```
import Foundation

public extension Reer where Base == NSRange {

    /// ReerKit: Get Range<Int> from NSRange
    public var range: Range<Int> { get }
}
```

### NSRegularExpression

```
import Foundation

public extension Reer where Base: NSRegularExpression {

    /// ReerKit: Enumerates the string allowing the Block to handle each regular expression match.
    ///
    /// - Parameters:
    ///   - string: The string.
    ///   - options: The matching options to report. See `NSRegularExpression.MatchingOptions` for the supported values.
    ///   - range: The range of the string to test.
    ///   - block: The Block enumerates the matches of the regular expression in the string.
    ///     The block takes three arguments and returns `Void`:
    ///     - result:
    ///         An `NSTextCheckingResult` specifying the match. This result gives the overall matched range via its `range` property, and the range of each individual capture group via its `range(at:)` method. The range {NSNotFound, 0} is returned if one of the capture groups did not participate in this particular match.
    ///     - flags:
    ///         The current state of the matching progress. See `NSRegularExpression.MatchingFlags` for the possible values.
    ///     - stop:
    ///         A reference to a Boolean value. The Block can set the value to true to stop further processing of the array. The stop argument is an out-only argument. You should only ever set this Boolean to true within the Block.
    public func enumerateMatches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: Range<String.Index>, using block: @escaping (_ result: NSTextCheckingResult?, _ flags: NSRegularExpression.MatchingFlags, _ stop: inout Bool) -> Void)

    /// ReerKit: Returns an array containing all the matches of the regular expression in the string.
    ///
    /// - Parameters:
    ///   - string: The string to search.
    ///   - options: The matching options to use. See NSRegularExpression.MatchingOptions for possible values.
    ///   - range: The range of the string to search.
    /// - Returns: An array of `NSTextCheckingResult` objects. Each result gives the overall matched range via its `range` property, and the range of each individual capture group via its `range(at:)` method. The range {NSNotFound, 0} is returned if one of the capture groups did not participate in this particular match.
    public func matches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: Range<String.Index>) -> [NSTextCheckingResult]

    /// ReerKit: Returns the number of matches of the regular expression within the specified range of the string.
    ///
    /// - Parameters:
    ///   - string: The string to search.
    ///   - options: The matching options to use. See NSRegularExpression.MatchingOptions for possible values.
    ///   - range: The range of the string to search.
    /// - Returns: The number of matches of the regular expression.
    public func numberOfMatches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: Range<String.Index>) -> Int

    /// ReerKit: Returns the first match of the regular expression within the specified range of the string.
    ///
    /// - Parameters:
    ///   - string: The string to search.
    ///   - options: The matching options to use. See `NSRegularExpression.MatchingOptions` for possible values.
    ///   - range: The range of the string to search.
    /// - Returns: An `NSTextCheckingResult` object. This result gives the overall matched range via its `range` property, and the range of each individual capture group via its `range(at:)` method. The range {NSNotFound, 0} is returned if one of the capture groups did not participate in this particular match.
    public func firstMatch(in string: String, options: NSRegularExpression.MatchingOptions = [], range: Range<String.Index>) -> NSTextCheckingResult?

    /// ReerKit: Returns the range of the first match of the regular expression within the specified range of the string.
    ///
    /// - Parameters:
    ///   - string: The string to search.
    ///   - options: The matching options to use. See `NSRegularExpression.MatchingOptions` for possible values.
    ///   - range: The range of the string to search.
    /// - Returns: The range of the first match. Returns `nil` if no match is found.
    public func rangeOfFirstMatch(in string: String, options: NSRegularExpression.MatchingOptions = [], range: Range<String.Index>) -> Range<String.Index>?

    /// ReerKit: Returns a new string containing matching regular expressions replaced with the template string.
    ///
    /// - Parameters:
    ///   - string: The string to search for values within.
    ///   - options: The matching options to use. See `NSRegularExpression.MatchingOptions` for possible values.
    ///   - range: The range of the string to search.
    ///   - templ: The substitution template used when replacing matching instances.
    /// - Returns: A string with matching regular expressions replaced by the template string.
    public func stringByReplacingMatches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: Range<String.Index>, withTemplate templ: String) -> String

    /// ReerKit: Replaces regular expression matches within the mutable string using the template string.
    ///
    /// - Parameters:
    ///   - string: The mutable string to search and replace values within.
    ///   - options: The matching options to use. See `NSRegularExpression.MatchingOptions` for possible values.
    ///   - range: The range of the string to search.
    ///   - templ: The substitution template used when replacing matching instances.
    /// - Returns: The number of matches.
    @discardableResult
    public func replaceMatches(in string: inout String, options: NSRegularExpression.MatchingOptions = [], range: Range<String.Index>, withTemplate templ: String) -> Int
}
```

### NotificationCenter

```
import Foundation

public extension Reer where Base: NotificationCenter {

    /// ReerKit: Adds a one-time entry to the notification center's dispatch table that includes a notification queue and a block to add to the queue, and an optional notification name and sender.
    /// - Parameters:
    ///   - name: The name of the notification for which to register the observer; that is, only notifications with this name are used to add the block to the operation queue.
    ///
    ///     If you pass `nil`, the notification center doesn’t use a notification’s name to decide whether to add the block to the operation queue.
    ///   - obj: The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.
    ///
    ///     If you pass `nil`, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer.
    ///   - queue: The operation queue to which block should be added.
    ///
    ///     If you pass `nil`, the block is run synchronously on the posting thread.
    ///   - block: The block to be executed when the notification is received.
    ///
    ///     The block is copied by the notification center and (the copy) held until the observer registration is removed.
    ///
    ///     The block takes one argument:
    ///   
    public func observeOnce(forName name: NSNotification.Name?, object obj: Any? = nil, queue: OperationQueue? = nil, using block: @escaping (_ notification: Notification) -> Void)
}
```

### Timer

```
import Foundation
import ObjectiveC

public extension Reer where Base: Timer {

    /// ReerKit: Creates a timer and schedules it on the current run loop in the default mode.
    /// The target will be wrapped with a WeakProxy.
    public static func scheduledTimer(timeInterval: TimeInterval, weakTarget: NSObject, selector: Selector, userInfo: Any?, repeats: Bool) -> Timer

    /// ReerKit: Initializes a timer object with the specified object and selector.
    /// The target will be wrapped with a WeakProxy.
    public static func timer(timeInterval: TimeInterval, weakTarget: NSObject, selector: Selector, userInfo: Any?, repeats: Bool) -> Timer

    /// ReerKit: Resumes the timer.
    public func resume()

    /// ReerKit: Suspends the timer.
    public func suspend()
}
```

### URL

```
import Foundation
import AVFoundation
import UIKit

public extension ReerForEquatable where Base == URL {

    /// ReerKit: Dictionary of the URL's query parameters.
    public var queryParameters: [String : String]? { get }

    /// ReerKit: URL with appending query parameters.
    ///
    ///        let url = URL(string: "https://google.com")!
    ///        let param = ["q": "Hello Swift"]
    ///        url.appendingQueries(params) -> "https://google.com?q=Hello%20Swift"
    ///
    /// - Returns: URL with appending given query parameters.
    public func appendingQueries(_ queries: [String : String]) -> URL

    /// ReerKit: URL with removing query parameters.
    ///
    ///        let url = URL(string: "https://google.com?q=Hello%20Swift")!
    ///        url.removingQueries(["q"]) -> "https://google.com"
    ///
    /// - Returns: URL with appending given query parameters.
    public func removingQueries(_ queries: [String]) -> URL

    /// ReerKit: Get value of a query key.
    ///
    ///    var url = URL(string: "https://google.com?code=12345")!
    ///    queryValue(for: "code") -> "12345"
    ///
    /// - Parameter key: The key of a query value.
    public func queryValue(for key: String) -> String?

    /// ReerKit: Returns a new URL by removing all the path components.
    ///
    ///     let url = URL(string: "https://domain.com/path/other")!
    ///     print(url.deletingAllPathComponents()) // prints "https://domain.com/"
    ///
    /// - Returns: URL with all path components removed.
    public func deletingAllPathComponents() -> URL

    /// ReerKit: Generates new URL that does not have scheme.
    ///
    ///        let url = URL(string: "https://domain.com")!
    ///        print(url.droppedScheme()) // prints "domain.com"
    public func droppedScheme() -> URL?

    /// ReerKit: Generate a thumbnail image from given url. Returns nil if no thumbnail could be created. This function may take some time to complete. It's recommended to dispatch the call if the thumbnail is not generated from a local resource.
    ///
    ///     var url = URL(string: "https://video.golem.de/files/1/1/20637/wrkw0718-sd.mp4")!
    ///     var thumbnail = url.thumbnail()
    ///     thumbnail = url.thumbnail(fromTime: 5)
    ///
    ///     DisptachQueue.main.async {
    ///         someImageView.image = url.thumbnail()
    ///     }
    ///
    /// - Parameter time: Seconds into the video where the image should be generated.
    /// - Returns: The UIImage result of the AVAssetImageGenerator
    public func thumbnail(fromTime time: Float64 = 0) -> UIImage?
}

extension URL: ReerReferenceCompatible {}
public extension ReerReference where Base == URL {

    /// ReerKit: Append query parameters to URL.
    ///
    ///        var url = URL(string: "https://google.com")!
    ///        let param = ["q": "Hello Swift"]
    ///        url.appendQueryParameters(params)
    ///        print(url) // prints "https://google.com?q=Hello%20Swift"
    ///
    public mutating func appendQueries(_ queries: [String : String])

    /// ReerKit: Remove query parameters to URL.
    ///
    ///        let url = URL(string: "https://google.com?q=Hello%20Swift")!
    ///        url.removeQueries(["q"])
    ///        print(url) // "https://google.com"
    ///
    public mutating func removeQueries(_ queries: [String])

    /// ReerKit: Remove all the path components from the URL.
    ///
    ///        var url = URL(string: "https://domain.com/path/other")!
    ///        url.deleteAllPathComponents()
    ///        print(url) // prints "https://domain.com/"
    public mutating func deleteAllPathComponents()
}

public extension URL {

    public static func re(string: String?, relativeTo url: URL? = nil) -> URL?
}
```

### URLRequest

```
import Foundation

public extension URLRequest {

    /// ReerKit: Create URLRequest from URL string.
    ///
    /// - Parameter urlString: URL string to initialize URL request from
    public static func re(urlString: String) -> URLRequest?
}

public extension ReerForEquatable where Base == URLRequest {

    /// ReerKit: cURL command representation of this URL request.
    public var curlString: String { get }
}
```

## Shared+REExtensions

### Color

```
#if canImport(UIKit)
import UIKit
/// ReerKit: Color
public typealias REColor = UIColor
#endif

#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
/// ReerKit: Color
public typealias REColor = NSColor
#endif

public extension REColor {

    /// ReerKit: Create Color from RGB values with optional transparency.
    ///
    /// - Parameters:
    ///   - red: red component.
    ///   - green: green component.
    ///   - blue: blue component.
    ///   - alpha: optional transparency value (default is 1).
    public static func re(red: Int, green: Int, blue: Int, alpha: CGFloat = 1) -> REColor

    /// ReerKit: Create Color from hexadecimal value with optional transparency.
    ///
    /// - Parameters:
    ///   - hex: hex Int with 6 digits (example: 0xDECEB5).
    ///   - alpha: optional transparency value (default is 1).
    public static func re(hex: Int, alpha: CGFloat = 1) -> REColor

    /// ReerKit: Create Color from hexadecimal string with optional transparency (if applicable).
    ///
    /// - Parameters:
    ///   - hexString: hexadecimal string (examples: EDE7F6, 0xEDE7F6, #EDE7F6, #0ff, 0xF0F, ..).
    ///   - alpha: optional transparency value (default is 1).
    public static func re(hexString: String, alpha: CGFloat = 1) -> REColor

    /// ReerKit: Create Color from hexadecimal value in the format ARGB (alpha-red-green-blue).
    ///
    /// - Parameters:
    ///   - argbHex: hexadecimal value with 8 digits (examples: 0x7FEDE7F6).
    public static func re(argbHex: Int) -> REColor

    /// ReerKit: Create Color from hexadecimal string in the format ARGB (alpha-red-green-blue).
    ///
    /// - Parameters:
    ///   - argbHexString: hexadecimal string (examples: 7FEDE7F6, 0x7FEDE7F6, #7FEDE7F6, #f0ff, 0xFF0F, ..).
    public static func re(argbHexString: String) -> REColor

    /// ReerKit: Create Color from hexadecimal value in the format RGBA (red-green-blue-alpha).
    ///
    /// - Parameters:
    ///   - rgbaHex: hexadecimal value with 8 digits  (examples: 0x7FEDE7F6).
    public static func re(rgbaHex: Int) -> REColor

    /// ReerKit: Create Color from hexadecimal string in the format RGBA (red-green-blue-alpha).
    ///
    /// - Parameters:
    ///   - rgbaHexString: hexadecimal string (examples: 7FEDE7F6, 0x7FEDE7F6, #7FEDE7F6, #f0ff, 0xFF0F, ..).
    public static func re(rgbaHexString: String) -> REColor

    /// ReerKit: Create a dynamic color with light and dark color.
    public static func re(light: REColor, dark: REColor) -> REColor
}

public extension Reer where Base: REColor {

    /// ReerKit: Random color.
    public static var random: REColor { get }

    /// ReerKit: Get brightness of color.
    public var brightness: CGFloat { get }

    /// ReerKit: Alpha of Color (read-only).
    public var alpha: CGFloat { get }

    /// ReerKit: Get components of hue, saturation, and brightness, and alpha (read-only).
    public var hsba: (hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat) { get }

    /// ReerKit: RGBA components for a Color (RGB between 0 and 255).
    ///
    ///     UIColor.red.re.rgba.red -> 255
    ///     NSColor.green.re.rgba.green -> 255
    ///     UIColor.blue.re.rgba.blue -> 255
    ///
    public var rgba: (red: Int, green: Int, blue: Int, alpha: CGFloat) { get }

    /// ReerKit: RGBA components of percentage for a Color (RGB between 0 and 1.0).
    ///
    ///     UIColor.red.re.rgba.red -> 255
    ///     NSColor.green.re.rgba.green -> 255
    ///     UIColor.blue.re.rgba.blue -> 255
    ///
    public var rgbaPercent: (red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat) { get }

    /// ReerKit: Hexadecimal value string (read-only).
    public var hexString: String { get }

    /// ReerKit: Hexadecimal value string in RGBA mode (read-only).
    public var rgbaHexString: String { get }

    /// ReerKit: Hexadecimal value string in ARGB mode (read-only).
    public var argbHexString: String { get }

    /// ReerKit: Lighten a color
    ///
    ///     let color = UIColor(red: r, green: g, blue: b, alpha: a)
    ///     let lighterColor: UIColor = color.lighten(by: 0.2)
    ///
    /// - Parameter percentage: Percentage by which to lighten the color
    /// - Returns: A lightened color
    public func lighten(by percentage: CGFloat = 0.2) -> REColor

    /// ReerKit: Darken a color
    ///
    ///     let color = UIColor(red: r, green: g, blue: b, alpha: a)
    ///     let darkerColor: UIColor = color.darken(by: 0.2)
    ///
    /// - Parameter percentage: Percentage by which to darken the color
    /// - Returns: A darkened color
    public func darken(by percentage: CGFloat = 0.2) -> REColor

    /// ReerKit: Blend two Colors.
    ///
    /// - Parameters:
    ///   - color1: first color to blend
    ///   - intensity1: intensity of first color (default is 0.5)
    ///   - color2: second color to blend
    ///   - intensity2: intensity of second color (default is 0.5)
    /// - Returns: Color created by blending first and second colors.
    public static func blend(_ color1: REColor, intensity1: CGFloat = 0.5, with color2: REColor, intensity2: CGFloat = 0.5) -> REColor

    /// ReerKit: Blend the color with a color
    ///
    /// - Parameter color: second color to blend
    /// - Returns: Color created by blending self and seond colors.
    public func blend(with color: REColor) -> REColor
}
```

### EdgeInsets

```
import UIKit
/// ReerKit: EdgeInsets
public typealias REEdgeInsets = UIEdgeInsets

public extension REEdgeInsets {

    /// ReerKit: Creates an `EdgeInsets` with the inset value applied to all (top, bottom, right, left).
    ///
    /// - Parameter inset: Inset to be applied in all the edges.
    public static func re(inset: CGFloat) -> REEdgeInsets
}

public extension ReerForEquatable where Base == REEdgeInsets {

    /// ReerKit: Return the vertical insets. The vertical insets is composed by top + bottom.
    public var vertical: CGFloat { get }

    /// ReerKit: Return the horizontal insets. The horizontal insets is composed by  left + right.
    public var horizontal: CGFloat { get }

    /// ReerKit: Creates an `EdgeInsets` based on current value and top offset.
    ///
    /// - Parameters:
    ///   - top: Offset to be applied in to the top edge.
    /// - Returns: EdgeInsets offset with given offset.
    public func insetBy(top: CGFloat) -> REEdgeInsets

    /// ReerKit: Creates an `EdgeInsets` based on current value and left offset.
    ///
    /// - Parameters:
    ///   - left: Offset to be applied in to the left edge.
    /// - Returns: EdgeInsets offset with given offset.
    public func insetBy(left: CGFloat) -> REEdgeInsets

    /// ReerKit: Creates an `EdgeInsets` based on current value and bottom offset.
    ///
    /// - Parameters:
    ///   - bottom: Offset to be applied in to the bottom edge.
    /// - Returns: EdgeInsets offset with given offset.
    public func insetBy(bottom: CGFloat) -> REEdgeInsets

    /// ReerKit: Creates an `EdgeInsets` based on current value and right offset.
    ///
    /// - Parameters:
    ///   - right: Offset to be applied in to the right edge.
    /// - Returns: EdgeInsets offset with given offset.
    public func insetBy(right: CGFloat) -> REEdgeInsets
}

public extension REEdgeInsets {

    /// ReerKit: Add all the properties of two `EdgeInsets` to create their addition.
    ///
    /// - Parameters:
    ///   - lhs: The left-hand expression
    ///   - rhs: The right-hand expression
    /// - Returns: A new `EdgeInsets` instance where the values of `lhs` and `rhs` are added together.
    public static func + (lhs: REEdgeInsets, rhs: REEdgeInsets) -> REEdgeInsets

    /// ReerKit: Add all the properties of two `EdgeInsets` to the left-hand instance.
    ///
    /// - Parameters:
    ///   - lhs: The left-hand expression to be mutated
    ///   - rhs: The right-hand expression
    public static func += (lhs: inout REEdgeInsets, rhs: REEdgeInsets)
}
```

## UIKit+REExtensions

### UIAlertController

```
import UIKit
import AudioToolbox

public extension Reer where Base: UIAlertController {

    /// ReerKit: Present alert view controller in the current view controller.
    ///
    /// - Parameters:
    ///   - animated: set true to animate presentation of alert controller (default is true).
    ///   - vibrate: set true to vibrate the device while presenting the alert (default is false).
    ///   - completion: an optional completion handler to be called after presenting alert controller (default is nil).
    @available(iOSApplicationExtension, unavailable)
    @available(visionOS, unavailable)
    public func show(animated: Bool = true, vibrate: Bool = false, completion: (() -> Void)? = nil)

    /// ReerKit: Add an action to Alert.
    ///
    /// - Parameters:
    ///   - title: action title.
    ///   - style: action style (default is UIAlertActionStyle.default).
    ///   - isEnabled: isEnabled status for action (default is true).
    ///   - handler: optional action handler to be called when button is tapped (default is nil).
    /// - Returns: action created by this method.
    @discardableResult
    public func addAction(title: String, style: UIAlertAction.Style = .default, isEnabled: Bool = true, handler: ((UIAlertAction) -> Void)? = nil) -> UIAlertAction

    /// ReerKit: Add a text field to Alert.
    ///
    /// - Parameters:
    ///   - text: text field text (default is nil).
    ///   - placeholder: text field placeholder text (default is nil).
    ///   - editingChangedTarget: an optional target for text field's editingChanged.
    ///   - editingChangedSelector: an optional selector for text field's editingChanged.
    public func addTextField(text: String? = nil, placeholder: String? = nil, editingChangedTarget: Any?, editingChangedSelector: Selector?)
}

public extension UIAlertController {

    /// ReerKit: Create a alert view controller with actions.
    /// - Parameters:
    ///   - title: alert controller's title.
    ///   - message: alert controller's message (default is nil).
    ///   - preferredStyle: alert controller's display style.
    ///   - tintColor: alert controller's tint color (default is nil).
    ///   - actions: button clicked actions.
    @MainActor public static func re(title: String? = nil, message: String? = nil, preferredStyle: UIAlertController.Style = .alert, tintColor: UIColor? = nil, actions: [UIAlertAction]) -> UIAlertController

    /// ReerKit: Create new alert view controller with default OK action.
    ///
    /// - Parameters:
    ///   - title: alert controller's title.
    ///   - message: alert controller's message (default is nil).
    ///   - defaultActionButtonTitle: default action button title (default is "OK").
    ///   - tintColor: alert controller's tint color (default is nil).
    @MainActor public static func re(title: String? = nil, message: String? = nil, defaultActionButtonTitle: String = "OK", tintColor: UIColor? = nil) -> UIAlertController

    /// ReerKit: Create new error alert view controller from Error with default OK action.
    ///
    /// - Parameters:
    ///   - title: alert controller's title (default is "Error").
    ///   - error: error to set alert controller's message to it's localizedDescription.
    ///   - defaultActionButtonTitle: default action button title (default is "OK").
    ///   - preferredStyle: type of alert to display (default is .alert).
    ///   - tintColor: alert controller's tint color (default is nil).
    @MainActor public static func re(title: String = "Error", error: Error, defaultActionButtonTitle: String = "OK", preferredStyle: UIAlertController.Style = .alert, tintColor: UIColor? = nil) -> UIAlertController
}
```

### UIApplication

```
import UIKit

public extension UIApplication {

    /// ReerKit: Application running environment.
    ///
    /// - debug: Application is running in debug mode.
    /// - testFlight: Application is installed from Test Flight.
    /// - appStore: Application is installed from the App Store.
    public enum Environment {

        /// ReerKit: Application is running in debug mode.
        case debug

        /// ReerKit: Application is installed from Test Flight.
        case testFlight

        /// ReerKit: Application is installed from the App Store.
        case appStore
    }
}

public extension Reer where Base: UIApplication {

    /// ReerKit: Current inferred app environment.
    public static var inferredEnvironment: UIApplication.Environment { get }

    /// ReerKit: Return the main bundle's `CFBundleDisplayName` or `CFBundleName`.
    public static var name: String { get }

    /// ReerKit: Return the main bundle's bundle identifier.
    public static var bundleID: String { get }

    /// ReerKit: App current build number.
    public static var buildNumber: String { get }

    /// ReerKit: App's current version number.
    public static var version: String { get }

    /// ReerKit: App's scheme list.
    public static var schemes: [String] { get }
}

public extension Reer where Base: UIApplication {

    /// ReerKit: App's key window.
    /// https://github.com/SwiftKickMobile/SwiftMessages/blob/master/SwiftMessages/UIWindow%2BExtensions.swift
    public static var keyWindow: UIWindow? { get }

    /// ReerKit: The app's visible and hidden windows.
    public static var windows: [UIWindow] { get }

    /// ReerKit: The app's main screen.
    public static var mainScreen: UIScreen? { get }

    /// ReerKit: App's top most view controller.
    public static var topViewController: UIViewController? { get }

    /// ReerKit: App's top most navigation controller.
    public static var topNavigationController: UINavigationController? { get }

    /// ReerKit: A view controller's top most view controller.
    public static func topViewController(of viewController: UIViewController?) -> UIViewController?
}

public extension Reer where Base: UIApplication {

    /// ReerKit: "Documents" URL in this app's sandbox.
    public static var documentsURL: URL { get }

    /// ReerKit: "Documents" path in this app's sandbox.
    public static var documentsPath: String { get }

    /// ReerKit: "Caches" URL in this app's sandbox.
    public static var cachesURL: URL { get }

    /// ReerKit: "Caches" path in this app's sandbox.
    public static var cachesPath: String { get }

    /// ReerKit: "Library" URL in this app's sandbox.
    public static var libraryURL: URL { get }

    /// ReerKit: "Library" path in this app's sandbox.
    public static var libraryPath: String { get }
}
```

### UIBarButtonItem

```
import UIKit

public extension Reer where Base: UIBarButtonItem {

    /// ReerKit: Creates a flexible space UIBarButtonItem.
    public static var flexibleSpace: UIBarButtonItem { get }

    /// ReerKit: Add Target to UIBarButtonItem.
    ///
    /// - Parameters:
    ///   - target: target.
    ///   - action: selector to run when button is tapped.
    public func addTargetForAction(_ target: AnyObject, action: Selector)

    /// ReerKit: Creates a fixed space UIBarButtonItem with a specific width.
    ///
    /// - Parameter width: Width of the UIBarButtonItem.
    public static func fixedSpace(width: CGFloat) -> UIBarButtonItem
}
```

### UIBezierPath

```
import UIKit

public extension UIBezierPath {

    /// ReerKit: Initializes a UIBezierPath with a line from a CGPoint to another CGPoint.
    ///
    /// - Parameters:
    ///   - from: The point from which to path should start.
    ///   - otherPoint: The point where the path should end.
    public static func re(from: CGPoint, to otherPoint: CGPoint) -> UIBezierPath

    /// ReerKit: Initializes a UIBezierPath connecting the given CGPoints with straight lines.
    ///
    /// - Parameter points: The points of which the path should consist.
    public static func re(points: [CGPoint]) -> UIBezierPath

    /// ReerKit: Initializes a polygonal UIBezierPath with the given CGPoints. At least 3 points must be given.
    ///
    /// - Parameter points: The points of the polygon which the path should form.
    public static func re(polygonWithPoints points: [CGPoint]) -> UIBezierPath?

    /// ReerKit: Initializes a UIBezierPath with an oval path of given size.
    ///
    /// - Parameters:
    ///   - size: The width and height of the oval.
    ///   - centered: Whether the oval should be centered in its coordinate space.
    public static func re(ovalOf size: CGSize, centered: Bool) -> UIBezierPath

    /// ReerKit: Initializes a UIBezierPath with a  rectangular path of given size.
    ///
    /// - Parameters:
    ///   - size: The width and height of the rect.
    ///   - centered: Whether the oval should be centered in its coordinate space.
    public static func re(rectOf size: CGSize, centered: Bool) -> UIBezierPath
}
```

### UIButton

```
import UIKit

public extension Reer where Base: UIButton {

    /// ReerKit: Image of disabled state for button; also inspectable from Storyboard.
    public var imageForDisabled: UIImage? { get set }

    /// ReerKit: Image of highlighted state for button; also inspectable from Storyboard.
    public var imageForHighlighted: UIImage? { get set }

    /// ReerKit: Image of normal state for button; also inspectable from Storyboard.
    public var imageForNormal: UIImage? { get set }

    /// ReerKit: Image of selected state for button; also inspectable from Storyboard.
    public var imageForSelected: UIImage? { get set }

    /// ReerKit: Image of focused state for button; also inspectable from Storyboard.
    public var imageForFocused: UIImage? { get set }

    /// ReerKit: Title color of disabled state for button; also inspectable from Storyboard.
    public var titleColorForDisabled: UIColor? { get set }

    /// ReerKit: Title color of highlighted state for button; also inspectable from Storyboard.
    public var titleColorForHighlighted: UIColor? { get set }

    /// ReerKit: Title color of normal state for button; also inspectable from Storyboard.
    public var titleColorForNormal: UIColor? { get set }

    /// ReerKit: Title color of selected state for button; also inspectable from Storyboard.
    public var titleColorForSelected: UIColor? { get set }

    /// ReerKit: Title color of focused state for button; also inspectable from Storyboard.
    public var titleColorForFocused: UIColor? { get set }

    /// ReerKit: Title of disabled state for button; also inspectable from Storyboard.
    public var titleForDisabled: String? { get set }

    /// ReerKit: Title of highlighted state for button; also inspectable from Storyboard.
    public var titleForHighlighted: String? { get set }

    /// ReerKit: Title of normal state for button; also inspectable from Storyboard.
    public var titleForNormal: String? { get set }

    /// ReerKit: Title of selected state for button; also inspectable from Storyboard.
    public var titleForSelected: String? { get set }

    /// ReerKit: Title of focused state for button; also inspectable from Storyboard.
    public var titleForFocused: String? { get set }

    /// ReerKit: Attributed title of disabled state for button.
    public var attributedTitleForDisabled: NSAttributedString? { get set }

    /// ReerKit: Attributed title of highlighted state for button.
    public var attributedTitleForHighlighted: NSAttributedString? { get set }

    /// ReerKit: Attributed title of normal state for button.
    public var attributedTitleForNormal: NSAttributedString? { get set }

    /// ReerKit: Attributed title of selected state for button.
    public var attributedTitleForSelected: NSAttributedString? { get set }

    /// ReerKit: Attributed title of focused state for button.
    public var attributedTitleForFocused: NSAttributedString? { get set }

    /// ReerKit: Set image for all states.
    ///
    /// - Parameter image: UIImage.
    public func setImageForAllStates(_ image: UIImage?)

    /// ReerKit: Set title color for all states.
    ///
    /// - Parameter color: UIColor.
    public func setTitleColorForAllStates(_ color: UIColor?)

    /// ReerKit: Set title for all states.
    ///
    /// - Parameter title: title string.
    public func setTitleForAllStates(_ title: String?)

    /// ReerKit: Set attributed title for all states.
    ///
    /// - Parameter title: title string.
    public func setAttributedTitleForAllStates(_ title: NSAttributedString?)

    public enum ContentLayoutType {

        case leftImageRightText

        case leftTextRightImage

        case topImageBottomText

        case topTextBottomImage
    }

    /// ReerKit: Layout button's image and text. Setup title, font, image before invoking this method.
    /// - Parameters:
    ///   - type: layout type.
    ///   - spacing: spacing between title text and image.
    ///   - offsetFromCenter: offset from center of button.
    public func layoutContent(with type: ContentLayoutType, spacing: CGFloat = 0, offsetFromCenter: CGVector = .init(dx: 0, dy: 0))

    /// ReerKit: Set background color for specified state.
    /// - Parameters:
    ///   - color: The color of the image that will be set as background for the button in the given state.
    ///   - forState: set the UIControl.State for the desired color.
    public func setBackgroundColor(color: UIColor?, forState: UIControl.State)
}
```

### UICollectionView

```
import UIKit

public extension Reer where Base: UICollectionView {

    /// ReerKit: Index path of last item in collectionView.
    public var indexPathOfLastItem: IndexPath? { get }

    /// ReerKit: Index of last section in collectionView.
    public var lastSection: Int { get }

    /// ReerKit: Number of all items in all sections of collectionView.
    ///
    /// - Returns: The count of all rows in the collectionView.
    public func numberOfItems() -> Int

    /// ReerKit: IndexPath for last item in section.
    ///
    /// - Parameter section: section to get last item in.
    /// - Returns: optional last indexPath for last item in section (if applicable).
    public func indexPathOfLastItem(inSection section: Int) -> IndexPath?

    /// ReerKit: Reload data with a completion handler.
    ///
    /// - Parameter completion: completion handler to run after reloadData finishes.
    public func reloadData(_ completion: @escaping () -> Void)

    /// ReerKit: Dequeue reusable UICollectionViewCell using class name.
    ///
    /// - Parameters:
    ///   - name: UICollectionViewCell type.
    ///   - indexPath: location of cell in collectionView.
    /// - Returns: UICollectionViewCell object with associated class name.
    public func dequeueReusableCell<T>(_ name: T.Type, for indexPath: IndexPath) -> T where T : UICollectionViewCell

    /// ReerKit: Dequeue reusable UICollectionReusableView using class name.
    ///
    /// - Parameters:
    ///   - kind: the kind of supplementary view to retrieve. This value is defined by the layout object.
    ///   - name: UICollectionReusableView type.
    ///   - indexPath: location of cell in collectionView.
    /// - Returns: UICollectionReusableView object with associated class name.
    public func dequeueReusableSupplementaryView<T>(ofKind kind: String, withClass name: T.Type, for indexPath: IndexPath) -> T where T : UICollectionReusableView

    /// ReerKit: Register UICollectionReusableView using class name.
    ///
    /// - Parameters:
    ///   - kind: the kind of supplementary view to retrieve. This value is defined by the layout object.
    ///   - name: UICollectionReusableView type.
    public func register<T>(supplementaryViewOfKind kind: String, withClass name: T.Type) where T : UICollectionReusableView

    /// ReerKit: Register UICollectionViewCell using class name.
    ///
    /// - Parameters:
    ///   - nib: Nib file used to create the collectionView cell.
    ///   - name: UICollectionViewCell type.
    public func register<T>(nib: UINib?, forCellWithClass name: T.Type) where T : UICollectionViewCell

    /// ReerKit: Register UICollectionViewCell using class name.
    ///
    /// - Parameter name: UICollectionViewCell type.
    public func register<T>(cell name: T.Type) where T : UICollectionViewCell

    /// ReerKit: Register UICollectionReusableView using class name.
    ///
    /// - Parameters:
    ///   - nib: Nib file used to create the reusable view.
    ///   - kind: the kind of supplementary view to retrieve. This value is defined by the layout object.
    ///   - name: UICollectionReusableView type.
    public func register<T>(nib: UINib?, forSupplementaryViewOfKind kind: String, withClass name: T.Type) where T : UICollectionReusableView

    /// ReerKit: Register UICollectionViewCell with .xib file using only its corresponding class.
    ///               Assumes that the .xib filename and cell class has the same name.
    ///
    /// - Parameters:
    ///   - name: UICollectionViewCell type.
    ///   - bundleClass: Class in which the Bundle instance will be based on.
    public func register<T>(nibWithCellClass name: T.Type, at bundleClass: AnyClass? = nil) where T : UICollectionViewCell

    /// ReerKit: Safely scroll to possibly invalid IndexPath.
    ///
    /// - Parameters:
    ///   - indexPath: Target IndexPath to scroll to.
    ///   - scrollPosition: Scroll position.
    ///   - animated: Whether to animate or not.
    public func scrollToItem(at indexPath: IndexPath, at scrollPosition: UICollectionView.ScrollPosition, animated: Bool)

    /// ReerKit: Check whether IndexPath is valid within the CollectionView.
    ///
    /// - Parameter indexPath: An IndexPath to check.
    /// - Returns: Boolean value for valid or invalid IndexPath.
    public func isValidIndexPath(_ indexPath: IndexPath) -> Bool
}
```

### UIControl

```
import UIKit
import ObjectiveC

public extension Reer where Base: UIControl {

    /// ReerKit: Removes all targets and actions for a particular event (or events)
    /// from an internal dispatch table.
    public func removeAllTargets()

    /// ReerKit: Adds a action for a particular event (or events) to an internal dispatch table.
    /// It will cause a strong reference to @a action.
    ///
    /// - Parameters:
    ///   - events: The action which is invoked then the action message is
    ///             sent  (cannot be nil). The action is retained.
    ///   - action: A bitmask specifying the control events for which the
    ///            action message is sent.
    public func addAction(forControlEvents events: UIControl.Event, action: @escaping (UIControl) -> Void)

    /// ReerKit: Adds or replaces a action for a particular event (or events) to an internal
    /// dispatch table. It will cause a strong reference to @a action.
    ///
    /// - Parameters:
    ///   - events: A bitmask specifying the control events for which the
    ///             action message is sent.
    ///   - action: The action which is invoked then the action message is
    ///            sent (cannot be nil). The action is retained.
    public func setAction(forControlEvents events: UIControl.Event, action: @escaping (UIControl) -> Void)

    /// ReerKit: Removes all actions for a particular event (or events) from an internal
    /// dispatch table.
    ///
    /// - Parameter events: A bitmask specifying the control events for which the
    ///                     action message is sent.
    public func removeAllActions(forControlEvents events: UIControl.Event)

    /// ReerKit: Adds or replaces a target and action for a particular event (or events)
    /// to an internal dispatch table.
    ///
    /// - Parameters:
    ///   - target: The target object—that is, the object to which the
    ///             action message is sent. If this is nil, the responder
    ///             chain is searched for an object willing to respond to the
    ///             action message.
    ///   - action: A selector identifying an action message.
    ///   - events: A bitmask specifying the control events for which the
    ///             action message is sent.
    public func setTarget(_ target: Any?, action: Selector, forControlEvents events: UIControl.Event)
}
```

### UIDevice

```
import UIKit
import Darwin

public extension UIDevice {

    public enum Name {

        /// Device is an [iPod touch (5th generation)](https://support.apple.com/kb/SP657)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP657/sp657_ipod-touch_size.jpg)
        case iPodTouch5

        /// Device is an [iPod touch (6th generation)](https://support.apple.com/kb/SP720)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP720/SP720-ipod-touch-specs-color-sg-2015.jpg)
        case iPodTouch6

        /// Device is an [iPod touch (7th generation)](https://support.apple.com/kb/SP796)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP796/ipod-touch-7th-gen_2x.png)
        case iPodTouch7

        /// Device is an [iPhone 4](https://support.apple.com/kb/SP587)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP643/sp643_iphone4s_color_black.jpg)
        case iPhone4

        /// Device is an [iPhone 4s](https://support.apple.com/kb/SP643)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP643/sp643_iphone4s_color_black.jpg)
        case iPhone4s

        /// Device is an [iPhone 5](https://support.apple.com/kb/SP655)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP655/sp655_iphone5_color.jpg)
        case iPhone5

        /// Device is an [iPhone 5c](https://support.apple.com/kb/SP684)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP684/SP684-color_yellow.jpg)
        case iPhone5c

        /// Device is an [iPhone 5s](https://support.apple.com/kb/SP685)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP685/SP685-color_black.jpg)
        case iPhone5s

        /// Device is an [iPhone 6](https://support.apple.com/kb/SP705)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP705/SP705-iphone_6-mul.png)
        case iPhone6

        /// Device is an [iPhone 6 Plus](https://support.apple.com/kb/SP706)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP706/SP706-iphone_6_plus-mul.png)
        case iPhone6Plus

        /// Device is an [iPhone 6s](https://support.apple.com/kb/SP726)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP726/SP726-iphone6s-gray-select-2015.png)
        case iPhone6s

        /// Device is an [iPhone 6s Plus](https://support.apple.com/kb/SP727)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP727/SP727-iphone6s-plus-gray-select-2015.png)
        case iPhone6sPlus

        /// Device is an [iPhone 7](https://support.apple.com/kb/SP743)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP743/iphone7-black.png)
        case iPhone7

        /// Device is an [iPhone 7 Plus](https://support.apple.com/kb/SP744)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP744/iphone7-plus-black.png)
        case iPhone7Plus

        /// Device is an [iPhone SE](https://support.apple.com/kb/SP738)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP738/SP738.png)
        case iPhoneSE

        /// Device is an [iPhone 8](https://support.apple.com/kb/SP767)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP767/iphone8.png)
        case iPhone8

        /// Device is an [iPhone 8 Plus](https://support.apple.com/kb/SP768)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP768/iphone8plus.png)
        case iPhone8Plus

        /// Device is an [iPhone X](https://support.apple.com/kb/SP770)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP770/iphonex.png)
        case iPhoneX

        /// Device is an [iPhone Xs](https://support.apple.com/kb/SP779)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP779/SP779-iphone-xs.jpg)
        case iPhoneXS

        /// Device is an [iPhone Xs Max](https://support.apple.com/kb/SP780)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP780/SP780-iPhone-Xs-Max.jpg)
        case iPhoneXSMax

        /// Device is an [iPhone Xʀ](https://support.apple.com/kb/SP781)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP781/SP781-iPhone-xr.jpg)
        case iPhoneXR

        /// Device is an [iPhone 11](https://support.apple.com/kb/SP804)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP804/sp804-iphone11_2x.png)
        case iPhone11

        /// Device is an [iPhone 11 Pro](https://support.apple.com/kb/SP805)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP805/sp805-iphone11pro_2x.png)
        case iPhone11Pro

        /// Device is an [iPhone 11 Pro Max](https://support.apple.com/kb/SP806)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP806/sp806-iphone11pro-max_2x.png)
        case iPhone11ProMax

        /// Device is an [iPhone SE (2nd generation)](https://support.apple.com/kb/SP820)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP820/iphone-se-2nd-gen_2x.png)
        case iPhoneSE2

        /// Device is an [iPhone 12](https://support.apple.com/kb/SP830)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP830/sp830-iphone12-ios14_2x.png)
        case iPhone12

        /// Device is an [iPhone 12 mini](https://support.apple.com/kb/SP829)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP829/sp829-iphone12mini-ios14_2x.png)
        case iPhone12Mini

        /// Device is an [iPhone 12 Pro](https://support.apple.com/kb/SP831)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP831/iphone12pro-ios14_2x.png)
        case iPhone12Pro

        /// Device is an [iPhone 12 Pro Max](https://support.apple.com/kb/SP832)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP832/iphone12promax-ios14_2x.png)
        case iPhone12ProMax

        /// Device is an [iPhone 13](https://support.apple.com/kb/SP851)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1092/en_US/iphone-13-240.png)
        case iPhone13

        /// Device is an [iPhone 13 mini](https://support.apple.com/kb/SP847)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1091/en_US/iphone-13mini-240.png)
        case iPhone13Mini

        /// Device is an [iPhone 13 Pro](https://support.apple.com/kb/SP852)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1093/en_US/iphone-13pro-240.png)
        case iPhone13Pro

        /// Device is an [iPhone 13 Pro Max](https://support.apple.com/kb/SP848)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1095/en_US/iphone-13promax-240.png)
        case iPhone13ProMax

        /// Device is an [iPhone SE (3rd generation)](https://support.apple.com/kb/SP867)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1136/en_US/iphone-se-3rd-gen-colors-240.png)
        case iPhoneSE3

        /// Device is an [iPhone 14](https://support.apple.com/kb/SP873)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1092/en_US/TODO)
        case iPhone14

        /// Device is an [iPhone 14 Plus](https://support.apple.com/kb/SP874)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1091/en_US/TODO)
        case iPhone14Plus

        /// Device is an [iPhone 14 Pro](https://support.apple.com/kb/SP875)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1093/en_US/TODO)
        case iPhone14Pro

        /// Device is an [iPhone 14 Pro Max](https://support.apple.com/kb/SP876)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1095/en_US/TODO)
        case iPhone14ProMax

        /// Device is an [iPhone 15](https://support.apple.com/en-us/111831)
        ///
        /// ![Image]()
        case iPhone15

        /// Device is an [iPhone 15 Plus](https://support.apple.com/en-us/111830)
        ///
        /// ![Image]()
        case iPhone15Plus

        /// Device is an [iPhone 15 Pro](https://support.apple.com/en-us/111829)
        ///
        /// ![Image]()
        case iPhone15Pro

        /// Device is an [iPhone 15 Pro Max](https://support.apple.com/en-us/111828)
        ///
        /// ![Image]()
        case iPhone15ProMax

        /// Device is an [iPhone 16](https://support.apple.com/en-us/121029)
        ///
        /// ![Image]()
        case iPhone16

        /// Device is an [iPhone 16 Plus](https://support.apple.com/en-us/121030)
        ///
        /// ![Image]()
        case iPhone16Plus

        /// Device is an [iPhone 16 Pro](https://support.apple.com/en-us/121031)
        ///
        /// ![Image]()
        case iPhone16Pro

        /// Device is an [iPhone 16 Pro Max](https://support.apple.com/en-us/121032)
        ///
        /// ![Image]()
        case iPhone16ProMax

        /// Device is an [iPhone 16e](https://support.apple.com/en-us/122208)
        ///
        /// ![Image](https://cdsassets.apple.com/live/7WUAS350/images/tech-specs/122208-iphone-16e.png)
        case iPhone16e

        /// Device is an [iPad 2](https://support.apple.com/kb/SP622)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP622/SP622_01-ipad2-mul.png)
        case iPad2

        /// Device is an [iPad (3rd generation)](https://support.apple.com/kb/SP647)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP662/sp662_ipad-4th-gen_color.jpg)
        case iPad3

        /// Device is an [iPad (4th generation)](https://support.apple.com/kb/SP662)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP662/sp662_ipad-4th-gen_color.jpg)
        case iPad4

        /// Device is an [iPad Air](https://support.apple.com/kb/SP692)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP692/SP692-specs_color-mul.png)
        case iPadAir

        /// Device is an [iPad Air 2](https://support.apple.com/kb/SP708)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP708/SP708-space_gray.jpeg)
        case iPadAir2

        /// Device is an [iPad (5th generation)](https://support.apple.com/kb/SP751)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP751/ipad_5th_generation.png)
        case iPad5

        /// Device is an [iPad (6th generation)](https://support.apple.com/kb/SP774)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP774/sp774-ipad-6-gen_2x.png)
        case iPad6

        /// Device is an [iPad Air (3rd generation)](https://support.apple.com/kb/SP787)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP787/ipad-air-2019.jpg)
        case iPadAir3

        /// Device is an [iPad (7th generation)](https://support.apple.com/kb/SP807)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP807/sp807-ipad-7th-gen_2x.png)
        case iPad7

        /// Device is an [iPad (8th generation)](https://support.apple.com/kb/SP822)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP822/sp822-ipad-8gen_2x.png)
        case iPad8

        /// Device is an [iPad (9th generation)](https://support.apple.com/kb/SP849)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1096/en_US/ipad-9gen-240.png)
        case iPad9

        /// Device is an [iPad (10th generation)](https://support.apple.com/kb/SP884)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1096/en_US/TODO.png)
        case iPad10

        /// Device is an [iPad (11th generation)]()
        ///
        /// ![Image]()
        case iPad11

        /// Device is an [iPad Air (4th generation)](https://support.apple.com/kb/SP828)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP828/sp828ipad-air-ipados14-960_2x.png)
        case iPadAir4

        /// Device is an [iPad Air (5th generation)](https://support.apple.com/kb/TODO)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/TODO)
        case iPadAir5

        /// Device is an [iPad Air 11-inch (M2)](https://support.apple.com/en-us/119894)
        ///
        /// ![Image](https://cdsassets.apple.com/content/services/pub/image?productid=301027&size=240x240)
        case iPadAir11InchM2

        /// Device is an [iPad Air 13-inch (M2)](https://support.apple.com/en-us/119893)
        ///
        /// ![Image](https://cdsassets.apple.com/content/services/pub/image?productid=301029&size=240x240)
        case iPadAir13InchM2

        /// Device is an [iPad Air 11-inch (M3)]()
        ///
        /// ![Image]()
        case iPadAir11InchM3

        /// Device is an [iPad Air 13-inch (M3)]()
        ///
        /// ![Image]()
        case iPadAir13InchM3

        /// Device is an [iPad Mini](https://support.apple.com/kb/SP661)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP661/sp661_ipad_mini_color.jpg)
        case iPadMini

        /// Device is an [iPad Mini 2](https://support.apple.com/kb/SP693)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP693/SP693-specs_color-mul.png)
        case iPadMini2

        /// Device is an [iPad Mini 3](https://support.apple.com/kb/SP709)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP709/SP709-space_gray.jpeg)
        case iPadMini3

        /// Device is an [iPad Mini 4](https://support.apple.com/kb/SP725)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP725/SP725ipad-mini-4.png)
        case iPadMini4

        /// Device is an [iPad Mini (5th generation)](https://support.apple.com/kb/SP788)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP788/ipad-mini-2019.jpg)
        case iPadMini5

        /// Device is an [iPad Mini (6th generation)](https://support.apple.com/kb/SP850)
        ///
        /// ![Image](https://km.support.apple.com/resources/sites/APPLE/content/live/IMAGES/1000/IM1097/en_US/ipad-mini-6gen-240.png)
        case iPadMini6

        /// Device is an [iPad Mini (7th generation)]()
        ///
        /// ![Image]()
        case iPadMini7

        /// Device is an [iPad Pro 9.7-inch](https://support.apple.com/kb/SP739)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP739/SP739.png)
        case iPadPro9Inch

        /// Device is an [iPad Pro 12-inch](https://support.apple.com/kb/SP723)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP723/SP723-iPad_Pro_2x.png)
        case iPadPro12Inch

        /// Device is an [iPad Pro 12-inch (2nd generation)](https://support.apple.com/kb/SP761)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP761/ipad-pro-12in-hero-201706.png)
        case iPadPro12Inch2

        /// Device is an [iPad Pro 10.5-inch](https://support.apple.com/kb/SP762)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP761/ipad-pro-10in-hero-201706.png)
        case iPadPro10Inch

        /// Device is an [iPad Pro 11-inch](https://support.apple.com/kb/SP784)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP784/ipad-pro-11-2018_2x.png)
        case iPadPro11Inch

        /// Device is an [iPad Pro 12.9-inch (3rd generation)](https://support.apple.com/kb/SP785)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP785/ipad-pro-12-2018_2x.png)
        case iPadPro12Inch3

        /// Device is an [iPad Pro 11-inch (2nd generation)](https://support.apple.com/kb/SP814)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP814/ipad-pro-11-2020.jpeg)
        case iPadPro11Inch2

        /// Device is an [iPad Pro 12.9-inch (4th generation)](https://support.apple.com/kb/SP815)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP815/ipad-pro-12-2020.jpeg)
        case iPadPro12Inch4

        /// Device is an [iPad Pro 11-inch (3rd generation)](https://support.apple.com/kb/SP843)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP843/ipad-pro-11_2x.png)
        case iPadPro11Inch3

        /// Device is an [iPad Pro 12.9-inch (5th generation)](https://support.apple.com/kb/SP844)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP844/ipad-pro-12-9_2x.png)
        case iPadPro12Inch5

        /// Device is an [iPad Pro 11-inch (4th generation)](https://support.apple.com/kb/SP882)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP843/TODO.png)
        case iPadPro11Inch4

        /// Device is an [iPad Pro 12.9-inch (6th generation)](https://support.apple.com/kb/SP883)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP844/TODO.png)
        case iPadPro12Inch6

        /// Device is an [iPad Pro 11-inch (M4)](https://support.apple.com/en-us/119892)
        ///
        /// ![Image](https://cdsassets.apple.com/content/services/pub/image?productid=301031&size=240x240)
        case iPadPro11InchM4

        /// Device is an [iPad Pro 13-inch (M4)](https://support.apple.com/en-us/119891)
        ///
        /// ![Image](https://cdsassets.apple.com/content/services/pub/image?productid=301033&size=240x240)
        case iPadPro13InchM4

        /// Device is a [HomePod](https://support.apple.com/kb/SP773)
        ///
        /// ![Image](https://support.apple.com/library/APPLE/APPLECARE_ALLGEOS/SP773/homepod_space_gray_large_2x.jpg)
        case homePod

        /// Device is [Simulator](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/Introduction/Introduction.html)
        ///
        /// ![Image](https://developer.apple.com/assets/elements/icons/256x256/xcode-6.png)
        indirect case simulator(Name)

        /// Device is not yet known (implemented)
        /// You can still use this enum as before but the description equals the identifier (you can get multiple identifiers for the same product class
        /// (e.g. "iPhone6,1" or "iPhone 6,2" do both mean "iPhone 5s"))
        case unknown(String)
    }
}

public extension Reer where Base: UIDevice {

    /// ReerKit: Get current device's os version.
    public static var osVersion: String { get }

    /// ReerKit: Get current device's os version number.
    public static var osVersionNumber: Float { get }

    /// ReerKit: Get current device's current language.
    public static var currentLanguage: String { get }

    /// ReerKit: Whether the device is iPhone or iPod touch.
    public static var isPhone: Bool { get }

    /// ReerKit: Whether the device is iPad/iPad mini.
    public static var isPad: Bool { get }

    /// ReerKit: Whether the device is Mac.
    public static var isMac: Bool { get }

    /// ReerKit: Whether the device is Apple TV.
    public static var isTV: Bool { get }

    /// ReerKit: Whether the device is Vision Pro.
    public static var isVision: Bool { get }

    /// ReerKit: Whether the device is a simulator.
    public static var isSimulator: Bool { get }

    /// ReerKit: Whether the device is jailbroken.
    public static var isJailbroken: Bool { get }

    /// ReerKit: Wherher the device can make phone calls.
    public static var canMakePhoneCalls: Bool { get }

    /// ReerKit: WIFI IP address of this device (can be nil). e.g. @"192.168.1.111"
    public static var ipAddressWIFI: String? { get }

    /// ReerKit: Cell IP address of this device (can be nil). e.g. @"10.2.2.222"
    public static var ipAddressCell: String? { get }

    public static var isRectangularScreen: Bool { get }

    public static var isNotchScreen: Bool { get }

    public static var isDynamicIslandScreen: Bool { get }

    /// ReerKit: The device's hardware machine id.  e.g. "iPhone6,1" "iPad4,6"
    ///
    /// [reference](http://theiphonewiki.com/wiki/Models)
    public static var machineModelIdentifier: String { get }

    /// ReerKit: The device's machine model internal name.  e.g. "D83AP" "D16AP"
    public static var machineModelName: String { get }

    /// ReerKit: Get product model name of the device. e.g `.iPhone13ProMax`
    /// or get string version `UIDevice.current.re.modelName.description` -> "iPhone13 Pro Max"
    public static var modelName: UIDevice.Name { get }

    /// ReerKit: Mount id
    public static var mntID: String { get }

    /// ReerKit: Total disk space in byte. (-1 when error occurs)
    public static var diskSpace: Int64 { get }

    /// ReerKit: Free disk space in byte. (-1 when error occurs)
    public static var diskSpaceFree: Int64 { get }

    /// ReerKit: Used disk space in byte. (-1 when error occurs)
    public static var diskSpaceUsed: Int64 { get }

    /// ReerKit: Total physical memory in byte. (-1 when error occurs)
    public static var memoryTotal: Int64 { get }

    /// ReerKit: Used app memory and total memory
    ///
    /// [Reference](https://github.com/zixun/SystemEye/blob/master/SystemEye/Classes/Memory.swift)
    public static var appMemoryUsage: (used: Int64, total: Int64) { get }

    /// ReerKit: System memory usage
    public static var systemMemoryUsage: (free: Int64, active: Int64, inactive: Int64, wired: Int64, compressed: Int64, purgable: Int64, total: Int64) { get }

    /// ReerKit: App CPU usage
    public static var appCPUUsage: Double { get }

    /// ReerKit: System CPU usage
    public static var systemCPUUsage: (system: Double, user: Double, idle: Double, nice: Double) { get }
}



extension UIDevice.Name : CustomStringConvertible {

    /// A textual representation of the device.
    public var description: String { get }
}
```

### UIFont

```
import UIKit

public extension Reer where Base: UIFont {

    /// ReerKit: Font as bold font.
    public var bold: UIFont { get }

    /// ReerKit: Font as italic font.
    public var italic: UIFont { get }

    /// ReerKit: Font as monospaced font.
    ///
    ///     UIFont.re.preferredFont(forTextStyle: .body).monospaced
    ///
    public var monospaced: UIFont { get }
}
```

### UIGestureRecognizer

```
import UIKit

public extension Reer where Base: UIGestureRecognizer {

    /// ReerKit: Remove Gesture Recognizer from its view.
    public func removeFromView()
}
```

### UIImage

```
import UIKit
import Accelerate
import Darwin

public extension Reer where Base: UIImage {

    /// ReerKit: Size in bytes of UIImage.
    public var bytesSize: Int { get }

    /// ReerKit: Size in kilo bytes of UIImage.
    public var kilobytesSize: Int { get }

    /// ReerKit: UIImage with .alwaysOriginal rendering mode.
    public var original: UIImage { get }

    /// ReerKit: UIImage with .alwaysTemplate rendering mode.
    public var template: UIImage { get }

    /// ReerKit: Whether this image has alpha channel.
    public var hasAlphaChannel: Bool { get }

    /// ReerKit: Average color for this image.
    public func averageColor() -> UIColor?

    /// ReerKit: Pick the color at a point of the image.
    /// It will return nil if the point is out of bounds.
    public func color(at point: CGPoint) -> UIColor?

    /// ReerKit: Compressed UIImage from original UIImage.
    ///
    /// - Parameter quality: The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality), (default is 0.5).
    /// - Returns: optional UIImage (if applicable).
    public func compressed(quality: CGFloat = 0.5) -> UIImage?

    /// ReerKit: Compressed UIImage data from original UIImage.
    ///
    /// - Parameter quality: The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality), (default is 0.5).
    /// - Returns: optional Data (if applicable).
    public func compressedData(quality: CGFloat = 0.5) -> Data?

    /// ReerKit: UIImage filled with color
    ///
    /// - Parameter color: color to fill image with.
    /// - Returns: UIImage filled with given color.
    public func filled(withColor color: UIColor) -> UIImage

    /// ReerKit: UIImage blended with color.
    ///
    /// - Parameters:
    ///   - color: color to blend image with.
    ///   - mode: how to blend the tint.
    ///   - alpha: alpha value used to draw.
    /// - Returns: UIImage tinted with given color.
    public func blend(_ color: UIColor, mode: CGBlendMode, alpha: CGFloat = 1.0) -> UIImage

    /// ReerKit: UImage with background color.
    ///
    /// - Parameters:
    ///   - backgroundColor: Color to use as background color.
    /// - Returns: UIImage with a background color that is visible where alpha < 1.
    public func withBackgroundColor(_ backgroundColor: UIColor) -> UIImage

    ///  ReerKit: UIImage with rounded corners.
    ///
    /// - Parameters:
    ///   - radius: corner radius (optional), resulting image will be round if unspecified.
    ///   - corners: corners
    ///   - borderWidth: borderWidth
    ///   - borderColor: borderColor
    ///   - borderLineJoin: borderLineJoin
    /// - Returns: UIImage with all corners rounded.
    public func withRoundedCorners(radius: CGFloat? = nil, corners: UIRectCorner = .allCorners, borderWidth: CGFloat = 0, borderColor: UIColor? = nil, borderLineJoin: CGLineJoin = .miter) -> UIImage

    /// ReerKit: Returns a new image which is edge inset from this image.
    ///
    /// - Parameters:
    ///   - insets: Inset (positive) for each of the edges, values can be negative to 'outset'.
    ///   - color: Extend edge's fill color, nil means clear color.
    /// - Returns: The new image
    public func withEdge(byInsets insets: UIEdgeInsets, color: UIColor?) -> UIImage?

    /// ReerKit: Base 64 encoded PNG data of the image.
    ///
    /// - Returns: Base 64 encoded PNG data of the image as a String.
    public func pngBase64String() -> String?

    /// ReerKit: Base 64 encoded JPEG data of the image.
    ///
    /// - Parameter compressionQuality: The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality).
    /// - Returns: Base 64 encoded JPEG data of the image as a String.
    public func jpegBase64String(compressionQuality: CGFloat) -> String?

    /// ReerKit: UIImage with color uses .alwaysOriginal rendering mode.
    ///
    /// - Parameters:
    ///   - color: Color of image.
    /// - Returns: UIImage with color.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func withAlwaysOriginalTintColor(_ color: UIColor) -> UIImage
}

public extension Reer where Base: UIImage {

    /// ReerKit: A new image rotated counterclockwise by a quarter‑turn (90°). ⤺
    /// The width and height will be exchanged.
    public var rotateLeft90: UIImage? { get }

    /// ReerKit: A new image rotated clockwise by a quarter‑turn (90°). ⤼
    /// The width and height will be exchanged.
    public var rotateRight90: UIImage? { get }

    /// ReerKit: A new image rotated 180° . ↻
    public var rotate180: UIImage? { get }

    /// ReerKit: Returns a new rotated image (relative to the center).
    ///
    /// - Parameters:
    ///   - radians: Rotated radians in counterclockwise.⟲
    ///   - fitSize: true: new image's size is extend to fit all content.
    ///              false: image's size will not change, content may be clipped.
    /// - Returns: The new image
    public func rotated(by radians: CGFloat, fitSize: Bool = true) -> UIImage?

    /// ReerKit: Creates a copy of the receiver rotated by the given angle.
    ///
    ///     // Rotate the image by 180°
    ///     image.rotated(by: Measurement(value: 180, unit: .degrees))
    ///
    /// - Parameter angle: The angle measurement by which to rotate the image.
    /// - Returns: A new image rotated by the given angle.
    @available(tvOS 10.0, watchOS 3.0, *)
    public func rotated(by angle: Measurement<UnitAngle>) -> UIImage?

    /// ReerKit: UIImage Cropped to CGRect.
    ///
    /// - Parameter rect: CGRect to crop UIImage to.
    /// - Returns: cropped UIImage
    public func cropped(to rect: CGRect) -> UIImage

    /// ReerKit: UIImage scaled to height with respect to aspect ratio.
    ///
    /// - Parameters:
    ///   - toHeight: new height.
    ///   - opaque: flag indicating whether the bitmap is opaque.
    /// - Returns: optional scaled UIImage (if applicable).
    public func resize(toHeight: CGFloat, opaque: Bool = false) -> UIImage?

    /// ReerKit: UIImage scaled to width with respect to aspect ratio.
    ///
    /// - Parameters:
    ///   - toWidth: new width.
    ///   - opaque: flag indicating whether the bitmap is opaque.
    /// - Returns: optional scaled UIImage (if applicable).
    public func resize(toWidth: CGFloat, opaque: Bool = false) -> UIImage?

    /// ReerKit: Returns a new image which is scaled from this image.
    /// The image content will be changed with the contentMode.
    ///
    /// - Parameters:
    ///   - size: The new size to be scaled, values should be positive.
    ///   - contentMode: The content mode for image content.
    ///   - opaque: flag indicating whether the bitmap is opaque.
    /// - Returns: The new image with the given size.
    public func resize(to size: CGSize, contentMode: UIView.ContentMode = .scaleToFill, opaque: Bool = false) -> UIImage?

    /// ReerKit: Draws the entire image in the specified rectangle, content changed with
    /// the contentMode.
    ///
    /// - Note: This method draws the entire image in the current graphics context,
    /// respecting the image's orientation setting. In the default coordinate system,
    /// images are situated down and to the right of the origin of the specified
    /// rectangle. This method respects any transforms applied to the current graphics
    /// context, however.
    ///
    /// - Parameters:
    ///   - rect: The rectangle in which to draw the image.
    ///   - contentMode: Draw content mode
    ///   - clipsToBounds: A Boolean value that determines whether content are confined to the rect.
    public func draw(inRect rect: CGRect, contentMode: UIView.ContentMode, clipsToBounds: Bool)

    /// ReerKit: A vertically flipped image. ⥯
    public var flipVertical: UIImage? { get }

    /// ReerKit: A horizontally flipped image. ⇋
    public var flipHorizontal: UIImage? { get }
}

public extension Reer where Base: UIImage {

    /// ReerKit: Applies a blur effect to this image. Suitable for blur any content.
    public var blurSoft: UIImage? { get }

    /// ReerKit: Applies a blur effect to this image. Suitable for blur any content except pure white.
    /// (same as iOS Control Panel)
    public var blurLight: UIImage? { get }

    /// ReerKit: Applies a blur effect to this image. Suitable for displaying black text.
    /// (same as iOS Navigation Bar White)
    public var blurExtraLight: UIImage? { get }

    /// ReerKit: Applies a blur effect to this image. Suitable for displaying white text.
    /// (same as iOS Notification Center)
    public var blurDark: UIImage? { get }

    /// ReerKit: Applies a blur and tint color to this image.
    ///
    /// - Parameter tintColor: The tint color.
    /// - Returns: The new image
    public func blurWithTintColor(_ tintColor: UIColor) -> UIImage?

    /// ReerKit: Applies a blur, tint color, and saturation adjustment to this image,
    /// optionally within the area specified by @a maskImage.
    ///
    /// - Parameters:
    ///   - radius: The radius of the blur in points, 0 means no blur effect.
    ///   - tintColor: An optional UIColor object that is uniformly blended with
    ///                the result of the blur and saturation operations. The
    ///                alpha channel of this color determines how strong the
    ///                tint is. nil means no tint.
    ///   - tintBlendMode: The @a tintColor blend mode.
    ///                    Default is CGBlendMode.normal.
    ///   - saturation: A value of 1.0 produces no change in the resulting image.
    ///                 Values less than 1.0 will desaturation the resulting image
    ///                 while values greater than 1.0 will have the opposite effect.
    ///                 0 means gray scale.
    ///   - maskImage: If specified, @a inputImage is only modified in the area(s)
    ///                defined by this mask.  This must be an image mask or it
    ///                must meet the requirements of the mask parameter of
    ///                CGContextClipToMask.
    /// - Returns: The blured new Image
    public func blur(radius: CGFloat, tintColor: UIColor? = nil, tintBlendMode: CGBlendMode, saturation: CGFloat, maskImage: UIImage? = nil) -> UIImage?
}

public struct ImageFilterName : ExpressibleByStringLiteral, Hashable, RawRepresentable {

    public static let chrome: `Self`

    public static let fade: `Self`

    public static let instant: `Self`

    public static let mono: `Self`

    public static let noir: `Self`

    public static let process: `Self`

    public static let tonal: `Self`

    public static let transfer: `Self`

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    public typealias StringLiteralType = String

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public private(set) var rawValue: String { get }

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String)

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: `Self`, rhs: `Self`) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

public extension Reer where Base: UIImage {

    /// ReerKit: A grayscaled image.
    public var grayscale: UIImage? { get }

    /// ReerKit:
    /// - Parameter filterName: Name of the filter.
    /// - Returns: A filtered image.
    public func with(filter filterName: ImageFilterName) -> UIImage?
}

public extension UIImage {

    /// ReerKit: Create UIImage from color and size.
    ///
    /// - Parameters:
    ///   - color: image fill color.
    ///   - size: image size.
    public static func re(color: UIColor, size: CGSize = .init(width: 1, height: 1)) -> UIImage

    /// ReerKit: Create a new image from a base 64 string.
    ///
    /// - Parameters:
    ///   - base64String: a base-64 `String`, representing the image
    ///   - scale: The scale factor to assume when interpreting the image data created from the base-64 string. Applying a scale factor of 1.0 results in an image whose size matches the pixel-based dimensions of the image. Applying a different scale factor changes the size of the image as reported by the `size` property.
    public static func re(base64String: String, scale: CGFloat = 1.0) -> UIImage?

    /// ReerKit: Create a new image from a URL
    ///
    /// - Important:
    ///   Use this method to convert data:// URLs to UIImage objects.
    ///   Don't use this synchronous initializer to request network-based URLs. For network-based URLs, this method can block the current thread for tens of seconds on a slow network, resulting in a poor user experience, and in iOS, may cause your app to be terminated.
    ///   Instead, for non-file URLs, consider using this in an asynchronous way, using `dataTask(with:completionHandler:)` method of the URLSession class or a library such as `AlamofireImage`, `Kingfisher`, `SDWebImage`, or others to perform asynchronous network image loading.
    /// - Parameters:
    ///   - url: a `URL`, representing the image location
    ///   - scale: The scale factor to assume when interpreting the image data created from the URL. Applying a scale factor of 1.0 results in an image whose size matches the pixel-based dimensions of the image. Applying a different scale factor changes the size of the image as reported by the `size` property.
    public static func re(url: URL, scale: CGFloat = 1.0) throws -> UIImage?

    /// ReerKit: Create an image from a PDF file data or path.
    ///
    /// - Parameter dataOrPath: PDF data in `Data`, or PDF file path in `String`.
    /// - Returns: A new image create from PDF, or nil when an error occurs.
    public static func re(pdf dataOrPath: Any) -> UIImage?

    /// ReerKit: Create an image from a PDF file data or path.
    ///
    /// - Parameters:
    ///   - dataOrPath: PDF data in `Data`, or PDF file path in `String`.
    ///   - size: The new image's size, PDF's content will be stretched as needed.
    /// - Returns: A new image create from PDF, or nil when an error occurs.
    public static func re(pdf dataOrPath: Any, size: CGSize) -> UIImage?

    /// ReerKit: Create a square image from apple emoji.
    ///
    /// - Parameters:
    ///   - emoji: single emoji, such as "😄".
    ///   - size: image's size.
    /// - Returns: Image from emoji, or nil when an error occurs.
    public static func re(emoji: String, size: CGFloat) -> UIImage?
}
```

### UIImageView

```
import UIKit

public extension Reer where Base: UIImageView {

    /// ReerKit: Set image from a URL.
    ///
    /// - Parameters:
    ///   - url: URL of image.
    ///   - contentMode: imageView content mode (default is .scaleAspectFit).
    ///   - placeholder: optional placeholder image
    ///   - completionHandler: optional completion handler to run when download finishes (default is nil).
    public func download(from url: URL, contentMode: UIView.ContentMode = .scaleAspectFit, placeholder: UIImage? = nil, completionHandler: ((UIImage?) -> Void)? = nil)

    /// ReerKit: Make image view blurry.
    ///
    /// - Parameter style: UIBlurEffectStyle (default is .light).
    public func blur(withStyle style: UIBlurEffect.Style = .light)

    /// ReerKit: Blurred version of an image view.
    ///
    /// - Parameter style: UIBlurEffectStyle (default is .light).
    /// - Returns: blurred version of self.
    public func blurred(withStyle style: UIBlurEffect.Style = .light) -> UIImageView
}
```

### UILabel

```
import UIKit

public extension Reer where Base: UILabel {

    /// ReerKit: Required height for a label.
    public var requiredHeight: CGFloat { get }
}
```

### UINavigationBar

```
import UIKit

public extension Reer where Base: UINavigationBar {

    /// ReerKit: Set Navigation Bar title, title color and font.
    ///
    /// - Parameters:
    ///   - font: title font.
    ///   - color: title text color (default is .black).
    public func setTitleFont(_ font: UIFont, color: UIColor = .black)

    /// ReerKit: Make navigation bar transparent.
    ///
    /// - Parameter tint: tint color (default is .white).
    public func makeTransparent(withTint tint: UIColor = .white)

    /// ReerKit: Set navigationBar background and text colors.
    ///
    /// - Parameters:
    ///   - background: background color.
    ///   - text: text color.
    public func setColors(background: UIColor, text: UIColor)
}
```

### UINavigationController

```
import UIKit

public extension Reer where Base: UINavigationController {

    /// ReerKit: Pop ViewController with completion handler.
    ///
    /// - Parameters:
    ///   - animated: Set this value to true to animate the transition (default is true).
    ///   - completion: optional completion handler (default is nil).
    public func popViewController(animated: Bool = true, _ completion: (() -> Void)? = nil)

    /// ReerKit: Push ViewController with completion handler.
    ///
    /// - Parameters:
    ///   - viewController: viewController to push.
    ///   - animated: Specify true to animate the transition or false if you do not want the transition to be animated. You might specify false if you are setting up the navigation controller at launch time.
    ///   - completion: optional completion handler (default is nil).
    public func pushViewController(_ viewController: UIViewController, animated: Bool = true, completion: (() -> Void)? = nil)

    /// ReerKit: Make navigation controller's navigation bar transparent.
    ///
    /// - Parameter tint: tint color (default is .white).
    public func makeTransparent(withTint tint: UIColor = .white)
}
```

### UINavigationItem

```
import UIKit

public extension Reer where Base: UINavigationItem {

    /// ReerKit: Replace title label with an image in navigation item.
    ///
    /// - Parameter image: UIImage to replace title with.
    public func replaceTitle(with image: UIImage)
}
```

### UIRefreshControl

```
import UIKit

public extension Reer where Base: UIRefreshControl {

    /// ReerKit: Programmatically begin refresh control inside of UITableView.
    ///
    /// - Parameters:
    ///   - tableView: UITableView instance, inside which the refresh control is contained.
    ///   - animated: Boolean, indicates that is the content offset changing should be animated or not.
    ///   - sendAction: Boolean, indicates that should it fire sendActions method for valueChanged UIControlEvents.
    public func beginRefreshing(in tableView: UITableView, animated: Bool, sendAction: Bool = false)

    /// ReerKit: Programmatically begin refresh control inside of UIScrollView.
    ///
    /// - Parameters:
    ///   - animated: Boolean, indicates that is the content offset changing should be animated or not.
    ///   - sendAction: Boolean, indicates that should it fire sendActions method for valueChanged UIControlEvents.
    public func beginRefreshing(animated: Bool, sendAction: Bool = false)
}
```

### UIResponder

```
import UIKit
public typealias ResponderEventAction = (_ userInfo: [AnyHashable : Any]?, _ toNext: inout Bool) -> Void

/// ReerKit: Event name.
///
///     extension ResponderEventName {
///         static let testButtonClicked: ResponderEventName = "XXTestButtonClicked"
///     }
public struct ResponderEventName : ExpressibleByStringLiteral, Hashable, RawRepresentable {

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    public typealias StringLiteralType = String

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public private(set) var rawValue: String { get }

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String)

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ResponderEventName, rhs: ResponderEventName) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

public extension Reer where Base: UIResponder {

    /// ReerKit: Throw a responder event in a responder.
    /// - Parameters:
    ///   - eventName: A customize event name.
    ///   - userInfo: The user info for the event.
    public func post(_ eventName: ResponderEventName, userInfo: [AnyHashable : Any]? = nil)

    /// ReerKit: Obeserve a responder event in some next responder.
    /// - Parameters:
    ///   - eventName: A customize event name.
    ///   - action: Action will be execute when receive the event.
    public mutating func observeResponderEvent(_ eventName: ResponderEventName, action: @escaping ResponderEventAction)

    /// ReerKit: Unobserve a responder event.
    /// - Parameter eventName: The customize event name.
    public mutating func unobserveResponderEvent(_ eventName: ResponderEventName)
}
```

### UIScreen

```
import UIKit

public extension Reer where Base: UIScreen {

    /// ReerKit: Main screen size.
    public static var size: CGSize { get }

    /// ReerKit: Main screen width.
    public static var width: CGFloat { get }

    /// ReerKit: Main screen height.
    public static var height: CGFloat { get }

    /// ReerKit: Point value of one physical pixel for different screen.
    public static var onePixel: CGFloat { get }

    /// ReerKit: Half point value for aligning physical pixel.
    public static var halfPoint: CGFloat { get }
}
```

### UIScrollView

```
import UIKit

public extension Reer where Base: UIScrollView {

    /// ReerKit: Takes a snapshot of an entire ScrollView.
    ///
    ///    AnySubclassOfUIScrollView().snapshot
    ///    UITableView().snapshot
    ///
    /// - Returns: Snapshot as UIImage for rendered ScrollView.
    public var snapshot: UIImage? { get }

    /// ReerKit: The currently visible region of the scroll view.
    public var visibleRect: CGRect { get }

    /// ReerKit: Scroll to the top-most content offset.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollToTop(animated: Bool = true)

    /// ReerKit: Scroll to the left-most content offset.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollToLeft(animated: Bool = true)

    /// ReerKit: Scroll to the bottom-most content offset.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollToBottom(animated: Bool = true)

    /// ReerKit: Scroll to the right-most content offset.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollToRight(animated: Bool = true)

    /// ReerKit: Scroll up one page of the scroll view.
    /// If `isPagingEnabled` is `true`, the previous page location is used.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollUp(animated: Bool = true)

    /// ReerKit: Scroll left one page of the scroll view.
    /// If `isPagingEnabled` is `true`, the previous page location is used.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollLeft(animated: Bool = true)

    /// ReerKit: Scroll down one page of the scroll view.
    /// If `isPagingEnabled` is `true`, the next page location is used.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollDown(animated: Bool = true)

    /// ReerKit: Scroll right one page of the scroll view.
    /// If `isPagingEnabled` is `true`, the next page location is used.
    /// - Parameter animated: `true` to animate the transition at a constant velocity to the new offset, `false` to make the transition immediate.
    public func scrollRight(animated: Bool = true)
}
```

### UISearchBar

```
import UIKit

public extension Reer where Base: UISearchBar {

    /// ReerKit: Text field inside search bar (if applicable).
    public var textField: UITextField? { get }

    /// ReerKit: Text with no spaces or new lines in beginning and end (if applicable).
    public var trimmedText: String? { get }

    /// ReerKit: Clear text.
    public func clear()
}
```

### UISegmentedControl

```
import UIKit

public extension Reer where Base: UISegmentedControl {

    /// ReerKit: Segments titles.
    public var segmentTitles: [String] { get set }

    /// ReerKit: Segments images.
    public var segmentImages: [UIImage] { get set }
}
```

### UISlider

```
import UIKit

public extension Reer where Base: UISlider {

    /// ReerKit: Set slide bar value with completion handler.
    ///
    /// - Parameters:
    ///   - value: slider value.
    ///   - animated: set true to animate value change (default is true).
    ///   - duration: animation duration in seconds (default is 1 second).
    ///   - completion: an optional completion handler to run after value is changed (default is nil).
    public func setValue(_ value: Float, animated: Bool = true, duration: TimeInterval = 1, completion: (() -> Void)? = nil)
}
```

### UIStackView

```
import UIKit

public extension UIStackView {

    /// ReerKit: Initialize an UIStackView with an array of UIView and common parameters.
    ///
    ///     let stackView = UIStackView(arrangedSubviews: [UIView(), UIView()], axis: .vertical)
    ///
    /// - Parameters:
    ///   - arrangedSubviews: The UIViews to add to the stack.
    ///   - axis: The axis along which the arranged views are laid out.
    ///   - spacing: The distance in points between the adjacent edges of the stack view’s arranged views (default: 0.0).
    ///   - alignment: The alignment of the arranged subviews perpendicular to the stack view’s axis (default: .fill).
    ///   - distribution: The distribution of the arranged views along the stack view’s axis (default: .fill).
    @MainActor public static func re(arrangedSubviews: [UIView], axis: NSLayoutConstraint.Axis, spacing: CGFloat = 0.0, alignment: UIStackView.Alignment = .fill, distribution: UIStackView.Distribution = .fill) -> UIStackView
}

public extension Reer where Base: UIStackView {

    /// ReerKit: Adds array of views to the end of the arrangedSubviews array.
    ///
    /// - Parameter views: views array.
    public func addArrangedSubviews(_ views: [UIView])

    /// ReerKit: Removes all views in stack’s array of arranged subviews.
    public func removeArrangedSubviews()

    /// ReerKit: Exchanges two views of the arranged subviews.
    /// - Parameters:
    ///   - view1: first view to swap.
    ///   - view2: second view to swap.
    ///   - animated: set true to animate swap (default is true).
    ///   - duration: animation duration in seconds (default is 1 second).
    ///   - delay: animation delay in seconds (default is 1 second).
    ///   - options: animation options (default is AnimationOptions.curveLinear).
    ///   - completion: optional completion handler to run with animation finishes (default is nil).
    public func swap(_ view1: UIView, _ view2: UIView, animated: Bool = false, duration: TimeInterval = 0.25, delay: TimeInterval = 0, options: UIView.AnimationOptions = .curveLinear, completion: ((Bool) -> Void)? = nil)
}
```

### UIStoryboard

```
import UIKit

public extension Reer where Base: UIStoryboard {

    /// ReerKit: Get main storyboard for application.
    public static var main: UIStoryboard? { get }

    /// ReerKit: Instantiate a UIViewController using its class name.
    ///
    /// - Parameter name: UIViewController type.
    /// - Returns: The view controller corresponding to specified class name.
    public func instantiateViewController<T>(withClass name: T.Type) -> T? where T : UIViewController
}
```

### UISwitch

```
import UIKit

public extension Reer where Base: UISwitch {

    /// ReerKit: Toggle a UISwitch.
    ///
    /// - Parameter animated: set true to animate the change (default is true).
    public func toggle(animated: Bool = true)
}
```

### UITabBar

```
import UIKit

public extension Reer where Base: UITabBar {

    /// ReerKit: Set tabBar colors.
    ///
    /// - Parameters:
    ///   - background: background color.
    ///   - selectedBackground: background color for selected tab.
    ///   - item: icon tint color for items.
    ///   - selectedItem: icon tint color for item.
    public func setColors(background: UIColor? = nil, selectedBackground: UIColor? = nil, item: UIColor? = nil, selectedItem: UIColor? = nil)
}
```

### UITableView

```
import UIKit

public extension Reer where Base: UITableView {

    /// ReerKit: Index path of last row in tableView.
    public var indexPathForLastRow: IndexPath? { get }

    /// ReerKit: Index of last section in tableView.
    public var lastSection: Int? { get }

    /// ReerKit: Number of all rows in all sections of tableView.
    ///
    /// - Returns: The count of all rows in the tableView.
    public func numberOfRows() -> Int

    /// ReerKit: IndexPath for last row in section.
    ///
    /// - Parameter section: section to get last row in.
    /// - Returns: optional last indexPath for last row in section (if applicable).
    public func indexPathForLastRow(inSection section: Int) -> IndexPath?

    /// ReerKit: Reload data with a completion handler.
    ///
    /// - Parameter completion: completion handler to run after reloadData finishes.
    public func reloadData(_ completion: @escaping () -> Void)

    /// ReerKit: Reload tableView height only animatablly. It will not trigger `cellForRow` to reload data.
    public func reloadHeight()

    /// ReerKit: Remove TableFooterView.
    public func removeTableFooterView()

    /// ReerKit: Remove TableHeaderView.
    public func removeTableHeaderView()

    /// ReerKit: Dequeue reusable UITableViewCell using class name.
    ///
    /// - Parameter name: UITableViewCell type.
    /// - Returns: UITableViewCell object with associated class name.
    public func dequeueReusableCell<T>(withClass name: T.Type) -> T where T : UITableViewCell

    /// ReerKit: Dequeue reusable UITableViewCell using class name for indexPath.
    ///
    /// - Parameters:
    ///   - name: UITableViewCell type.
    ///   - indexPath: location of cell in tableView.
    /// - Returns: UITableViewCell object with associated class name.
    public func dequeueReusableCell<T>(_ name: T.Type, for indexPath: IndexPath) -> T where T : UITableViewCell

    /// ReerKit: Dequeue reusable UITableViewHeaderFooterView using class name.
    ///
    /// - Parameter name: UITableViewHeaderFooterView type.
    /// - Returns: UITableViewHeaderFooterView object with associated class name.
    public func dequeueReusableHeaderFooterView<T>(_ name: T.Type) -> T where T : UITableViewHeaderFooterView

    /// ReerKit: Register UITableViewHeaderFooterView using class name.
    ///
    /// - Parameters:
    ///   - nib: Nib file used to create the header or footer view.
    ///   - name: UITableViewHeaderFooterView type.
    public func register<T>(nib: UINib?, withHeaderFooterViewClass name: T.Type) where T : UITableViewHeaderFooterView

    /// ReerKit: Register UITableViewHeaderFooterView using class name.
    ///
    /// - Parameter name: UITableViewHeaderFooterView type.
    public func register<T>(headerFooterView name: T.Type) where T : UITableViewHeaderFooterView

    /// ReerKit: Register UITableViewCell using class name.
    ///
    /// - Parameter name: UITableViewCell type.
    public func register<T>(cell name: T.Type) where T : UITableViewCell

    /// ReerKit: Register UITableViewCell using class name.
    ///
    /// - Parameters:
    ///   - nib: Nib file used to create the tableView cell.
    ///   - name: UITableViewCell type.
    public func register<T>(nib: UINib?, withCellClass name: T.Type) where T : UITableViewCell

    /// ReerKit: Register UITableViewCell with .xib file using only its corresponding class.
    ///               Assumes that the .xib filename and cell class has the same name.
    ///
    /// - Parameters:
    ///   - name: UITableViewCell type.
    ///   - bundleClass: Class in which the Bundle instance will be based on.
    public func register<T>(nibWithCellClass name: T.Type, at bundleClass: AnyClass? = nil) where T : UITableViewCell

    /// ReerKit: Check whether IndexPath is valid within the tableView.
    ///
    /// - Parameter indexPath: An IndexPath to check.
    /// - Returns: Boolean value for valid or invalid IndexPath.
    public func isValidIndexPath(_ indexPath: IndexPath) -> Bool

    /// ReerKit: Safely scroll to possibly invalid IndexPath.
    ///
    /// - Parameters:
    ///   - indexPath: Target IndexPath to scroll to.
    ///   - scrollPosition: Scroll position.
    ///   - animated: Whether to animate or not.
    public func scrollToRow(at indexPath: IndexPath, at scrollPosition: UITableView.ScrollPosition, animated: Bool)
}
```

### UITextField

```
import UIKit

public extension UITextField {

    /// ReerKit: UITextField text type.
    ///
    /// - emailAddress: UITextField is used to enter email addresses.
    /// - password: UITextField is used to enter passwords.
    /// - generic: UITextField is used to enter generic text.
    public enum TextType {

        /// ReerKit: UITextField is used to enter email addresses.
        case emailAddress

        /// ReerKit: UITextField is used to enter passwords.
        case password

        /// ReerKit: UITextField is used to enter generic text.
        case generic
    }
}

public extension Reer where Base: UITextField {

    /// ReerKit: Set textField for common text types.
    public var textType: UITextField.TextType { get set }

    /// ReerKit: Check if text field is empty.
    public var isEmpty: Bool { get }

    /// ReerKit: Return text with no spaces or new lines in beginning and end.
    public var trimmedText: String? { get }

    /// ReerKit: Check if textFields text is a valid email format.
    ///
    ///        textField.text = "john@doe.com"
    ///        textField.hasValidEmail -> true
    ///
    ///        textField.text = "swifterswift"
    ///        textField.hasValidEmail -> false
    ///
    public var hasValidEmail: Bool { get }

    /// ReerKit: Left view tint color.
    public var leftViewTintColor: UIColor? { get set }

    /// ReerKit: Right view tint color.
    public var rightViewTintColor: UIColor? { get set }

    /// ReerKit: Clear text.
    public func clear()

    /// ReerKit: Set placeholder text color.
    ///
    /// - Parameter color: placeholder text color.
    public func setPlaceHolderTextColor(_ color: UIColor?)

    /// ReerKit: Add padding to the left of the textfield rect.
    ///
    /// - Parameter padding: amount of padding to apply to the left of the textfield rect.
    public func addPaddingLeft(_ padding: CGFloat)

    /// ReerKit: Add padding to the right of the textfield rect.
    ///
    /// - Parameter padding: amount of padding to apply to the right of the textfield rect.
    public func addPaddingRight(_ padding: CGFloat)

    /// ReerKit: Add padding to the left of the textfield rect.
    ///
    /// - Parameters:
    ///   - image: left image.
    ///   - padding: amount of padding between icon and the left of textfield.
    public func addPaddingLeftIcon(_ image: UIImage, padding: CGFloat)

    /// ReerKit: Add padding to the right of the textfield rect.
    ///
    /// - Parameters:
    ///   - image: right image.
    ///   - padding: amount of padding between icon and the right of textfield.
    public func addPaddingRightIcon(_ image: UIImage, padding: CGFloat)

    @discardableResult
    public func addToolbar(items: [UIBarButtonItem]?, height: CGFloat = 44) -> UIToolbar
}
```

### UITextView

```
import UIKit

public extension Reer where Base: UITextView {

    /// ReerKit: Clear text.
    public func clear()

    /// ReerKit: Scroll to the bottom of text view.
    public func scrollToBottom()

    /// ReerKit: Scroll to the top of text view.
    public func scrollToTop()

    /// ReerKit: Wrap to the content (Text / Attributed Text).
    public func wrapToContent()
}
```

### UIViewController

```
import UIKit

public extension Reer where Base: UIViewController {

    /// ReerKit: Check if ViewController is onscreen and not hidden.
    public var isVisible: Bool { get }

    /// ReerKit: Instantiate UIViewController from storyboard.
    ///
    /// - Parameters:
    ///   - storyboard: Name of the storyboard where the UIViewController is located.
    ///   - bundle: Bundle in which storyboard is located.
    ///   - identifier: UIViewController's storyboard identifier.
    /// - Returns: Custom UIViewController instantiated from storyboard.
    public static func instantiate(from storyboard: String = "Main", bundle: Bundle? = nil, identifier: String? = nil) -> Base

    /// ReerKit: Assign as listener to notification.
    ///
    /// - Parameters:
    ///   - name: notification name.
    ///   - selector: selector to run with notified.
    public func addNotificationObserver(name: Notification.Name, selector: Selector)

    /// ReerKit: Unassign as listener to notification.
    ///
    /// - Parameter name: notification name.
    public func removeNotificationObserver(name: Notification.Name)

    /// ReerKit: Unassign as listener from all notifications.
    public func removeNotificationsObserver()

    /// ReerKit: Helper method to display an alert on any UIViewController subclass. Uses UIAlertController to show an alert.
    ///
    /// - Parameters:
    ///   - title: title of the alert.
    ///   - message: message/body of the alert.
    ///   - buttonTitles: (Optional)list of button titles for the alert. Default button i.e "OK" will be shown if this parameter is nil.
    ///   - highlightedButtonIndex: (Optional) index of the button from buttonTitles that should be highlighted. If this parameter is nil no button will be highlighted.
    ///   - completion: (Optional) completion block to be invoked when any one of the buttons is tapped. It passes the index of the tapped button as an argument.
    /// - Returns: UIAlertController object (discardable).
    @discardableResult
    public func showAlert(title: String?, message: String?, buttonTitles: [String]? = nil, highlightedButtonIndex: Int? = nil, completion: ((Int) -> Void)? = nil) -> UIAlertController

    /// ReerKit: Helper method to add a UIViewController as a childViewController.
    ///
    /// - Parameters:
    ///   - child: the view controller to add as a child.
    ///   - containerView: the containerView for the child viewController's root view.
    public func addChildViewController(_ child: UIViewController, toContainerView containerView: UIView)

    /// ReerKit: Helper method to remove a UIViewController from its parent.
    public func removeViewAndControllerFromParentViewController()

    /// ReerKit: Helper method for a UIViewController to close itself.
    public func closeSelf(animated: Bool = true, completion: (() -> Void)? = nil)

    /// ReerKit: Helper method to present a UIViewController as a popover.
    ///
    /// - Parameters:
    ///   - popoverContent: the view controller to add as a popover.
    ///   - sourcePoint: the point in which to anchor the popover.
    ///   - size: the size of the popover. Default uses the popover preferredContentSize.
    ///   - delegate: the popover's presentationController delegate. Default is nil.
    ///   - animated: Pass true to animate the presentation; otherwise, pass false.
    ///   - completion: The block to execute after the presentation finishes. Default is nil.
    public func presentPopover(_ popoverContent: UIViewController, sourcePoint: CGPoint, size: CGSize? = nil, delegate: UIPopoverPresentationControllerDelegate? = nil, animated: Bool = true, completion: (() -> Void)? = nil)
}
```

### UIView

```
import UIKit
import SwiftUI
import CoreImage

public extension Reer where Base: UIView {

    /// ReerKit: Shortcut for frame.origin.x
    public var x: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.y
    public var y: CGFloat { get set }

    /// ReerKit: Shortcut for frame.size.width
    public var width: CGFloat { get set }

    /// ReerKit: Shortcut for frame.size.height
    public var height: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.x
    public var left: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.x + frame.size.width
    public var right: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.y
    public var top: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.y + frame.size.height
    public var bottom: CGFloat { get set }

    /// ReerKit: Shortcut for center.x
    public var centerX: CGFloat { get set }

    /// ReerKit: Shortcut for center.y
    public var centerY: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin
    public var origin: CGPoint { get set }

    /// ReerKit: Shortcut for frame.size
    public var size: CGSize { get set }
}

public extension Reer where Base: UIView {

    /// ReerKit: Border color of view.
    public var borderColor: UIColor? { get set }

    /// ReerKit: Border width of view.
    public var borderWidth: CGFloat { get set }

    /// ReerKit: Corner radius of view.
    public var cornerRadius: CGFloat { get set }

    /// ReerKit: Shadow color of view.
    public var shadowColor: UIColor? { get set }

    /// ReerKit: Shadow offset of view.
    public var shadowOffset: CGSize { get set }

    /// ReerKit: Shadow opacity of view.
    public var shadowOpacity: Float { get set }

    /// ReerKit: Shadow radius of view.
    public var shadowRadius: CGFloat { get set }

    /// ReerKit: Shadow path of view.
    public var shadowPath: UIBezierPath? { get set }
}

public extension Reer where Base: UIView {

    /// ReerKit: Create a snapshot image of the complete view hierarchy.
    public var snapshotImage: UIImage? { get }

    /// ReerKit: Find the first responder in its subviews recursively.
    public var firstResponder: UIView? { get }

    /// ReerKit: Get view's ViewController that belongs to.
    public var viewController: UIViewController? { get }

    public var isGrayModeEnabled: Bool { get set }
}

public extension Reer where Base: UIView {

    /// ReerKit: Create a snapshot image of the complete view hierarchy.
    /// It's faster than `snapshotImage`, but may cause screen updates.
    ///
    /// - Parameter afterUpdates: A Boolean value that indicates whether the snapshot should be rendered after recent changes have been incorporated. Specify the value false if you want to render a snapshot in the view hierarchy’s current state, which might not include recent changes.
    /// - Returns: a snapshot image of view
    public func snapshot(afterScreenUpdates afterUpdates: Bool = false) -> UIImage?

    /// ReerKit: Pick the color at a point of the view.
    /// It will return nil if the point is out of bounds.
    public func color(at point: CGPoint) -> UIColor?

    /// ReerKit: Add array of views to the view.
    ///
    /// - Parameter subviews: array of subviews to add to view.
    public func addSubviews(_ subviews: [UIView])

    /// ReerKit: Remove all subviews
    public func removeAllSubviews()

    /// ReerKit: Returns all the subviews of a given type.
    ///
    /// - Parameters:
    ///   - ofType: Class of the view to search.
    ///   - recursive: Whether to find recursively in the view hierarchy.
    /// - Returns: All subviews with a specified type.
    public func subviews<T>(ofType _: T.Type, recursive: Bool = false) -> [T]

    /// ReerKit: Returns the first subview of a given type.
    ///
    /// - Parameters:
    ///   - ofType: Class of the view to search.
    ///   - recursive: Whether to find it recursively in the view hierarchy.
    /// - Returns: All subviews with a specified type.
    public func firstSubview<T>(ofType _: T.Type, recursive: Bool = false) -> T?

    /// ReerKit: Return all the subviews matching the condition.
    /// - Parameters:
    ///   - condition: condition to evaluate each subview against.
    ///   - recursive: Whether to find it recursively in the view hierarchy.
    /// - Returns: All subviews that matching the condition.
    public func subviews(matching condition: (UIView) -> Bool, recursive: Bool = false) -> [UIView]

    /// ReerKit: Return the first subview matching the condition.
    /// - Parameters:
    ///   - condition: condition to evaluate each subview against.
    ///   - recursive: Whether to find it recursively in the view hierarchy.
    /// - Returns: The first subview that matching the condition.
    public func firstSubview(matching condition: (UIView) -> Bool, recursive: Bool = false) -> UIView?

    /// ReerKit: Return the string of subviews tree.
    ///
    /// ```
    /// UIView (0x0000000107c102f0) - frame: (0.0, 0.0, 430.0, 932.0)
    /// ├── UILabel (0x0000000107f08900) - frame: (0.0, 0.0, 0.0, 0.0)
    /// ├── UIButton (0x0000000107c18550) - frame: (0.0, 0.0, 0.0, 0.0)
    /// │   ├── UIImageView (0x0000000107c19660) - frame: (0.0, 0.0, 0.0, 0.0)
    /// │   └── UIImageView (0x0000000107c19bf0) - frame: (0.0, 0.0, 0.0, 0.0)
    /// └── UILabel (0x0000000107c19df0) - frame: (0.0, 0.0, 0.0, 0.0)
    /// ```
    ///
    /// - Parameter maxDepth: The maximum depth you want to find in the view hierarchy
    /// - Returns: The string of subviews tree.
    public func subviewTree(maxDepth: Int = Int.max) -> String

    /// ReerKit: Print the subviews tree.
    ///
    /// ```
    /// UIView (0x0000000107c102f0) - frame: (0.0, 0.0, 430.0, 932.0)
    /// ├── UILabel (0x0000000107f08900) - frame: (0.0, 0.0, 0.0, 0.0)
    /// ├── UIButton (0x0000000107c18550) - frame: (0.0, 0.0, 0.0, 0.0)
    /// │   ├── UIImageView (0x0000000107c19660) - frame: (0.0, 0.0, 0.0, 0.0)
    /// │   └── UIImageView (0x0000000107c19bf0) - frame: (0.0, 0.0, 0.0, 0.0)
    /// └── UILabel (0x0000000107c19df0) - frame: (0.0, 0.0, 0.0, 0.0)
    /// ```
    ///
    /// - Parameter maxDepth: The maximum depth you want to find in the view hierarchy
    public func printSubviewTree(maxDepth: Int = Int.max)

    /// ReerKit: Search all superviews until a view with the condition is found.
    ///
    /// - Parameter condition: predicate to evaluate on superviews.
    public func superview(matching condition: (UIView) -> Bool) -> UIView?

    /// ReerKit: Search all superviews until a view with this class is found.
    public func superview<T>(ofType _: T.Type) -> T? where T : UIView

    /// ReerKit: Returns all superviews of the current view
    /// - Parameter maxLevel: The maximum number of levels to traverse upwards. Defaults to Int.max.
    /// - Returns: An array of superviews, ordered from the immediate superview to the highest level ancestor.
    public func superviews(maxLevel: Int = Int.max) -> [UIView]

    /// ReerKit: Converts a point from the receiver's coordinate system to that of the specified view or window.
    ///
    /// - Parameters:
    ///   - point: A point specified in the local coordinate system (bounds) of the receiver.
    ///   - view: The view or window into whose coordinate system point is to be converted.
    ///           If view is nil, this method instead converts to window base coordinates.
    /// - Returns: The point converted to the coordinate system of view.
    public func convert(point: CGPoint, toViewOrWindow view: UIView?) -> CGPoint

    /// ReerKit: Converts a point from the coordinate system of a given view or window to that of the receiver.
    ///
    /// - Parameters:
    ///   - point: A point specified in the local coordinate system (bounds) of view.
    ///   - view: The view or window with point in its coordinate system.
    ///           If view is nil, this method instead converts from window base coordinates.
    /// - Returns: The point converted to the local coordinate system (bounds) of the receiver.
    public func convert(point: CGPoint, fromViewOrWindow view: UIView?) -> CGPoint

    /// ReerKit: Converts a rectangle from the receiver's coordinate system to that of another view or window.
    ///
    /// - Parameters:
    ///   - rect: A rectangle specified in the local coordinate system (bounds) of the receiver.
    ///   - view: The view or window that is the target of the conversion operation.
    ///           If view is nil, this method instead converts to window base coordinates.
    /// - Returns: The converted rectangle.
    public func convert(rect: CGRect, toViewOrWindow view: UIView?) -> CGRect

    /// ReerKit: Converts a rectangle from the coordinate system of another view or window to that of the receiver.
    ///
    /// - Parameters:
    ///   - rect: A rectangle specified in the local coordinate system (bounds) of view.
    ///   - view: The view or window with rect in its coordinate system.
    ///           If view is nil, this method instead converts from window base coordinates.
    /// - Returns: The converted rectangle.
    public func convert(rect: CGRect, fromViewOrWindow view: UIView?) -> CGRect

    /// ReerKit: Set some or all corners radiuses of view.
    ///
    /// - Parameters:
    ///   - corners: array of corners to change (example: [.bottomLeft, .topRight]).
    ///   - radius: radius for selected corners.
    public func roundCorners(_ corners: UIRectCorner = .allCorners, radius: CGFloat)

    /// ReerKit: Set some or all corners radiuses of view with a continuous curve.
    /// It will make the rectangle to squircle, just like the iPhone/iPad...and all of Apple products's rounded corner.
    /// https://medium.com/minimal-notes/rounded-corners-in-the-apple-ecosystem-1b3f45e18fcc
    ///
    /// - Parameters:
    ///   - corners: array of corners to change (example: [.bottomLeft, .topRight]).
    ///   - radius: radius for selected corners.
    @available(iOS 13.0, tvOS 13.0, *)
    public func squircleRoundCorners(_ corners: UIRectCorner = .allCorners, radius: CGFloat)

    /// ReerKit: Add shadow to view.
    ///
    /// - Note: This method only works with non-clear background color, or if the view has a `shadowPath` set.
    /// See parameter `opacity` for detail.
    ///
    /// - Parameters:
    ///   - color: shadow color (default is #137992).
    ///   - radius: shadow radius (default is 3).
    ///   - offset: shadow offset (default is .zero).
    ///   - opacity: shadow opacity (default is 0.5). It will also be affected by the `alpha` of `backgroundColor`.
    ///   - path: shadow path
    public func addShadow(ofColor color: UIColor = UIColor(red: 0.07, green: 0.47, blue: 0.57, alpha: 1.0), radius: CGFloat = 3, offset: CGSize = .zero, opacity: Float = 0.5, path: CGPath? = nil)

    /// ReerKit: Fade in view.
    ///
    /// - Parameters:
    ///   - duration: animation duration in seconds (default is 1 second).
    ///   - completion: optional completion handler to run with animation finishes (default is nil).
    public func fadeIn(duration: TimeInterval = 1, completion: ((Bool) -> Void)? = nil)

    /// ReerKit: Fade out view.
    ///
    /// - Parameters:
    ///   - duration: animation duration in seconds (default is 1 second).
    ///   - completion: optional completion handler to run with animation finishes (default is nil).
    public func fadeOut(duration: TimeInterval = 1, completion: ((Bool) -> Void)? = nil)

    /// ReerKit: Load view from nib.
    ///
    /// - Parameters:
    ///   - name: nib name.
    ///   - bundle: bundle of nib (default is nil).
    /// - Returns: optional UIView (if applicable).
    public static func loadFromNib(named name: String, bundle: Bundle? = nil) -> UIView?

    /// ReerKit: Load view of a certain type from nib
    ///
    /// - Parameters:
    ///   - name: UIView type.
    ///   - bundle: bundle of nib (default is nil).
    /// - Returns: UIView
    public static func loadFromNib<T>(withClass name: T.Type, bundle: Bundle? = nil) -> T where T : UIView

    /// ReerKit: Remove all gesture recognizers from view.
    public func removeGestureRecognizers()

    /// ReerKit: Attaches gesture recognizers to the view. Attaching gesture recognizers to a view defines the scope of the represented gesture, causing it to receive touches hit-tested to that view and all of its subviews. The view establishes a strong reference to the gesture recognizers.
    ///
    /// - Parameter gestureRecognizers: The array of gesture recognizers to be added to the view.
    public func addGestureRecognizers(_ gestureRecognizers: [UIGestureRecognizer])

    /// ReerKit: Detaches gesture recognizers from the receiving view. This method releases gestureRecognizers in addition to detaching them from the view.
    ///
    /// - Parameter gestureRecognizers: The array of gesture recognizers to be removed from the view.
    public func removeGestureRecognizers(_ gestureRecognizers: [UIGestureRecognizer])
}

public extension Reer where Base: UIView {

    /// ReerKit: Check if view is in RTL format.
    public var isRightToLeft: Bool { get }

    /// ReerKit: Add Visual Format constraints.
    ///
    /// - Parameters:
    ///   - withFormat: visual Format language.
    ///   - views: array of views which will be accessed starting with index 0 (example: [v0], [v1], [v2]..).
    public func addConstraints(withFormat: String, views: UIView...)

    /// ReerKit: Anchor all sides of the view into it's superview.
    public func fillToSuperview()

    /// ReerKit: Add anchors from any side of the current view into the specified anchors and returns the newly added constraints.
    ///
    /// - Parameters:
    ///   - top: current view's top anchor will be anchored into the specified anchor.
    ///   - left: current view's left anchor will be anchored into the specified anchor.
    ///   - bottom: current view's bottom anchor will be anchored into the specified anchor.
    ///   - right: current view's right anchor will be anchored into the specified anchor.
    ///   - topConstant: current view's top anchor margin.
    ///   - leftConstant: current view's left anchor margin.
    ///   - bottomConstant: current view's bottom anchor margin.
    ///   - rightConstant: current view's right anchor margin.
    ///   - widthConstant: current view's width.
    ///   - heightConstant: current view's height.
    /// - Returns: array of newly added constraints (if applicable).
    @discardableResult
    public func anchor(top: NSLayoutYAxisAnchor? = nil, left: NSLayoutXAxisAnchor? = nil, bottom: NSLayoutYAxisAnchor? = nil, right: NSLayoutXAxisAnchor? = nil, topConstant: CGFloat = 0, leftConstant: CGFloat = 0, bottomConstant: CGFloat = 0, rightConstant: CGFloat = 0, widthConstant: CGFloat = 0, heightConstant: CGFloat = 0) -> [NSLayoutConstraint]

    /// ReerKit: Anchor center X into current view's superview with a constant margin value.
    ///
    /// - Parameter constant: constant of the anchor constraint (default is 0).
    public func anchorCenterXToSuperview(constant: CGFloat = 0)

    /// ReerKit: Anchor center Y into current view's superview with a constant margin value.
    ///
    /// - Parameter constant: constant of the anchor constraint (default is 0).
    public func anchorCenterYToSuperview(constant: CGFloat = 0)

    /// ReerKit: Anchor center X and Y into current view's superview.
    public func anchorCenterSuperview()

    /// ReerKit: Search constraints until we find one for the given view
    /// and attribute. This will enumerate ancestors since constraints are
    /// always added to the common ancestor.
    ///
    /// - Parameter attribute: the attribute to find.
    /// - Parameter view: the view to find.
    /// - Returns: matching constraint.
    public func findConstraint(attribute: NSLayoutConstraint.Attribute, for view: UIView) -> NSLayoutConstraint?

    /// ReerKit: First width constraint for this view.
    public var widthConstraint: NSLayoutConstraint? { get }

    /// ReerKit: First height constraint for this view.
    public var heightConstraint: NSLayoutConstraint? { get }

    /// ReerKit: First leading constraint for this view.
    public var leadingConstraint: NSLayoutConstraint? { get }

    /// ReerKit: First trailing constraint for this view.
    public var trailingConstraint: NSLayoutConstraint? { get }

    /// ReerKit: First top constraint for this view.
    public var topConstraint: NSLayoutConstraint? { get }

    /// ReerKit: First bottom constraint for this view.
    public var bottomConstraint: NSLayoutConstraint? { get }
}

@available(iOS 13.0, tvOS 13.0, *)
public extension Reer where Base: UIView {

    /// ReerKit: Adds a SwiftUI view to the end of the receiver’s list of subviews.
    /// - Parameter view: The SwiftUI view to be added. After being added, this view appears on top of any other subviews.
    /// - Returns: A UIKit view that represent a SwiftUI view hierarchy.
    public func addSwiftUIView(_ view: some View) -> UIView

    /// ReerKit: Inserts a SwiftUI at the specified index.
    /// - Parameters:
    ///   - view: The SwiftUI view to insert.
    ///   - index: The index in the array of the subviews property at which to insert the view. Subview indices start at 0 and cannot be greater than the number of subviews.
    /// - Returns: A UIKit view that represent a SwiftUI view hierarchy.
    public func insertSwiftUIView(_ view: some View, at index: Int) -> UIView

    /// ReerKit: Inserts a SwiftUI view below another view in the view hierarchy.
    /// - Parameters:
    ///   - view: The SwiftUI view to insert below another view. It’s removed from its superview if it’s not a sibling of siblingSubview.
    ///   - siblingSubview: The sibling view that will be above the inserted view.
    /// - Returns: A UIKit view that represent a SwiftUI view hierarchy.
    public func insertSwiftUIView(_ view: some View, belowSubview siblingSubview: UIView) -> UIView

    /// ReerKit: Inserts a view above another view in the view hierarchy.
    /// - Parameters:
    ///   - view: The SwiftUI view to insert. It’s removed from its superview if it’s not a sibling of siblingSubview.
    ///   - siblingSubview: The sibling view that will be behind the inserted view.
    /// - Returns: A UIKit view that represent a SwiftUI view hierarchy.
    public func insertSwiftUIView(_ view: some View, aboveSubview siblingSubview: UIView) -> UIView
}
```

### UIWindow

```
import UIKit

public extension Reer where Base: UIWindow {

    /// ReerKit: Switch current root view controller with a new view controller.
    ///
    /// - Parameters:
    ///   - viewController: new view controller.
    ///   - animated: set to true to animate view controller change (default is true).
    ///   - duration: animation duration in seconds (default is 0.5).
    ///   - options: animation options (default is .transitionFlipFromRight).
    ///   - completion: optional completion handler called after view controller is changed.
    public func switchRootViewController(to viewController: UIViewController, animated: Bool = true, duration: TimeInterval = 0.5, options: UIView.AnimationOptions = .transitionFlipFromRight, _ completion: (() -> Void)? = nil)
}
```

## CoreAnimation+REExtensions

### CAGradientLayer

```
import QuartzCore

public extension CAGradientLayer {

    /// ReerKit: Creates a CAGradientLayer with the specified colors, location, startPoint, endPoint, and type.
    ///
    /// - Parameters:
    ///   - colors: An array of colors defining the color of each gradient stop.
    ///   - locations: An array of NSNumber defining the location of each
    ///                gradient stop as a value in the range [0, 1]. The values must be
    ///                monotonically increasing. If a nil array is given, the stops are
    ///                assumed to spread uniformly across the [0, 1] range. When rendered,
    ///                the colors are mapped to the output colorspace before being
    ///                interpolated (default is nil).
    ///   - startPoint: start point corresponds to the first gradient stop (I.e. [0,0] is the bottom-corner of the layer, [1,1] is the top-right corner).
    ///   - endPoint: end point corresponds to the last gradient stop
    ///   - type: The kind of gradient that will be drawn. Currently, the only allowed values are `axial' (the default value), `radial', and `conic'.
    public static func re(colors: [REColor], locations: [CGFloat]? = nil, startPoint: CGPoint = CGPoint(x: 0.5, y: 0), endPoint: CGPoint = CGPoint(x: 0.5, y: 1), type: CAGradientLayerType = .axial) -> CAGradientLayer
}
```

### CALayer

```
import QuartzCore
import UIKit

public extension Reer where Base: CALayer {

    /// ReerKit: Add shadow to layer.
    ///
    /// - Note: This method only works with non-clear background color, or if the view has a `shadowPath` set.
    /// See parameter `opacity` for detail.
    ///
    /// - Parameters:
    ///   - color: shadow color (default is #137992).
    ///   - radius: shadow radius (default is 3).
    ///   - offset: shadow offset (default is .zero).
    ///   - opacity: shadow opacity (default is 0.5). It will also be affected by the `alpha` of `backgroundColor`.
    ///   - path: shadow path
    public func addShadow(ofColor color: REColor = REColor(red: 0.07, green: 0.47, blue: 0.57, alpha: 1.0), radius: CGFloat = 3, offset: CGSize = .zero, opacity: Float = 0.5, path: CGPath? = nil)
}

public extension Reer where Base: CALayer {

    /// ReerKit: Shortcut for frame.origin.x
    public var x: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.y
    public var y: CGFloat { get set }

    /// ReerKit: Shortcut for frame.size.width
    public var width: CGFloat { get set }

    /// ReerKit: Shortcut for frame.size.height
    public var height: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.x
    public var left: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.x + frame.size.width
    public var right: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.y
    public var top: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin.y + frame.size.height
    public var bottom: CGFloat { get set }

    /// ReerKit: Shortcut for position.x
    public var centerX: CGFloat { get set }

    /// ReerKit: Shortcut for position.y
    public var centerY: CGFloat { get set }

    /// ReerKit: Shortcut for frame.origin
    public var origin: CGPoint { get set }

    /// ReerKit: Shortcut for frame.size
    public var size: CGSize { get set }
}

```

### CATransform3D

```
import QuartzCore

extension CATransform3D: ReerCompatibleValue {}

extension CATransform3D : Equatable {

    /// ReerKit: Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == (lhs: CATransform3D, rhs: CATransform3D) -> Bool
}

public extension Reer where Base == CATransform3D {

    /// ReerKit: The identity transform: [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1].
    @inlinable public static var identity: CATransform3D { get }

    /// ReerKit: Returns `true` if the receiver is the identity transform.
    @inlinable public var isIdentity: Bool { get }
}

public extension CATransform3D {

    /// ReerKit: Returns a transform that translates by `(tx, ty, tz)`.
    /// - Parameters:
    ///   - tx: x-axis translation
    ///   - ty: y-axis translation
    ///   - tz: z-axis translation
    @inlinable public static func re(translationX tx: CGFloat, y ty: CGFloat, z tz: CGFloat) -> CATransform3D

    /// ReerKit: Returns a transform that scales by `(sx, sy, sz)`.
    /// - Parameters:
    ///   - sx: x-axis scale
    ///   - sy: y-axis scale
    ///   - sz: z-axis scale
    @inlinable public static func re(scaleX sx: CGFloat, y sy: CGFloat, z sz: CGFloat) -> CATransform3D

    /// ReerKit: Returns a transform that rotates by `angle` radians about the vector `(x, y, z)`.
    ///
    /// If the vector has zero length the behavior is undefined.
    /// - Parameters:
    ///   - angle: The angle of rotation
    ///   - x: x position of the vector
    ///   - y: y position of the vector
    ///   - z: z position of the vector
    @inlinable public static func re(rotationAngle angle: CGFloat, x: CGFloat, y: CGFloat, z: CGFloat) -> CATransform3D
}

public extension Reer where Base == CATransform3D {

    /// ReerKit: Translate the receiver by `(tx, ty, tz)`.
    /// - Parameters:
    ///   - tx: x-axis translation
    ///   - ty: y-axis translation
    ///   - tz: z-axis translation
    /// - Returns: The translated matrix.
    @inlinable public func translatedBy(x tx: CGFloat, y ty: CGFloat, z tz: CGFloat) -> CATransform3D

    /// ReerKit: Scale the receiver by `(sx, sy, sz)`.
    /// - Parameters:
    ///   - sx: x-axis scale
    ///   - sy: y-axis scale
    ///   - sz: z-axis scale
    /// - Returns: The scaled matrix.
    @inlinable public func scaledBy(x sx: CGFloat, y sy: CGFloat, z sz: CGFloat) -> CATransform3D

    /// ReerKit: Rotate the receiver by `angle` radians about the vector `(x, y, z)`.
    ///
    /// If the vector has zero length the behavior is undefined.
    /// - Parameters:
    ///   - angle: The angle of rotation
    ///   - x: x position of the vector
    ///   - y: y position of the vector
    ///   - z: z position of the vector
    /// - Returns: The rotated matrix.
    @inlinable public func rotated(by angle: CGFloat, x: CGFloat, y: CGFloat, z: CGFloat) -> CATransform3D

    /// ReerKit: Invert the receiver.
    ///
    /// Returns the original matrix if the receiver has no inverse.
    /// - Returns: The inverted matrix of the receiver.
    @inlinable public func inverted() -> CATransform3D

    /// ReerKit: Concatenate `transform` to the receiver.
    /// - Parameter t2: The transform to concatenate on to the receiver
    /// - Returns: The concatenated matrix.
    @inlinable public func concatenating(_ t2: CATransform3D) -> CATransform3D
}

extension CATransform3D: ReerReferenceCompatible {}
public extension ReerReference where Base == CATransform3D {

    /// ReerKit: Translate the receiver by `(tx, ty, tz)`.
    /// - Parameters:
    ///   - tx: x-axis translation
    ///   - ty: y-axis translation
    ///   - tz: z-axis translation
    @inlinable public mutating func translateBy(x tx: CGFloat, y ty: CGFloat, z tz: CGFloat)

    /// ReerKit: Scale the receiver by `(sx, sy, sz)`.
    /// - Parameters:
    ///   - sx: x-axis scale
    ///   - sy: y-axis scale
    ///   - sz: z-axis scale
    @inlinable public mutating func scaleBy(x sx: CGFloat, y sy: CGFloat, z sz: CGFloat)

    /// ReerKit: Rotate the receiver by `angle` radians about the vector `(x, y, z)`.
    ///
    /// If the vector has zero length the behavior is undefined.
    /// - Parameters:
    ///   - angle: The angle of rotation
    ///   - x: x position of the vector
    ///   - y: y position of the vector
    ///   - z: z position of the vector
    @inlinable public mutating func rotate(by angle: CGFloat, x: CGFloat, y: CGFloat, z: CGFloat)

    /// ReerKit: Invert the receiver.
    ///
    /// Returns the original matrix if the receiver has no inverse.
    @inlinable public mutating func invert()

    /// ReerKit: Concatenate `transform` to the receiver.
    /// - Parameter t2: The transform to concatenate on to the receiver
    @inlinable public mutating func concatenate(_ t2: CATransform3D)
}
import CoreGraphics

public extension <<error type>> {

    /// ReerKit: Returns true if the receiver can be represented exactly by an affine transform.
    @inlinable public var isAffine: Bool { get }

    /// ReerKit: Returns the affine transform represented by the receiver.
    ///
    /// If the receiver can not be represented exactly by an affine transform the returned value is undefined.
    @inlinable public func affineTransform() -> CGAffineTransform
}
```

## CoreGraphics+REExtensions

### CGAffineTransform

```
import CoreGraphics
import QuartzCore

extension CGAffineTransform: ReerCompatibleValue {}
public extension Reer where Base == CGAffineTransform {

    /// ReerKit: Returns a transform with the same effect as the receiver.
    @inlinable public func transform3D() -> CATransform3D
}
```

### CGColor

```
import CoreGraphics
import UIKit

extension CGColor: ReerCompatible {}
public extension Reer where Base: CGColor {

    /// ReerKit: UIColor.
    public var uiColor: UIColor? { get }
}
```

### CGFloat

```
import CoreGraphics
import Foundation

public extension Reer where Base == CGFloat {

    /// ReerKit: Absolute of CGFloat value.
    public var abs: CGFloat { get }

    /// ReerKit: Ceil of CGFloat value.
    public var ceil: CGFloat { get }

    /// ReerKit: Radian value of degree input.
    public var degreesToRadians: CGFloat { get }

    /// ReerKit: Floor of CGFloat value.
    public var floor: CGFloat { get }

    /// ReerKit: Check if CGFloat is positive.
    public var isPositive: Bool { get }

    /// ReerKit: Check if CGFloat is negative.
    public var isNegative: Bool { get }

    /// ReerKit: Int.
    public var int: Int { get }

    /// ReerKit: Float.
    public var float: Float { get }

    /// ReerKit: Double.
    public var double: Double { get }

    /// ReerKit: Degree value of radian input.
    public var radiansToDegrees: CGFloat { get }
}
```

### CGPoint

```
import CoreGraphics

extension CGPoint: ReerCompatibleValue {}
public extension Reer where Base == CGPoint {

    /// ReerKit: Distance from another CGPoint.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let point2 = CGPoint(x: 30, y: 30)
    ///     let distance = point1.re.distance(from: point2)
    ///     // distance = 28.28
    ///
    /// - Parameter point: CGPoint to get distance from.
    /// - Returns: Distance between self and given CGPoint.
    public func distance(from point: CGPoint) -> CGFloat

    /// ReerKit: Distance between two CGPoints.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let point2 = CGPoint(x: 30, y: 30)
    ///     let distance = CGPoint.re.distance(from: point2, to: point1)
    ///     // distance = 28.28
    ///
    /// - Parameters:
    ///   - point1: first CGPoint.
    ///   - point2: second CGPoint.
    /// - Returns: distance between the two given CGPoints.
    public static func distance(from point1: CGPoint, to point2: CGPoint) -> CGFloat
}

public extension CGPoint {

    /// ReerKit: Add two CGPoints.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let point2 = CGPoint(x: 30, y: 30)
    ///     let point = point1 + point2
    ///     // point = CGPoint(x: 40, y: 40)
    ///
    /// - Parameters:
    ///   - lhs: CGPoint to add to.
    ///   - rhs: CGPoint to add.
    /// - Returns: result of addition of the two given CGPoints.
    public static func + (lhs: CGPoint, rhs: CGPoint) -> CGPoint

    /// ReerKit: Add a CGPoints to self.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let point2 = CGPoint(x: 30, y: 30)
    ///     point1 += point2
    ///     // point1 = CGPoint(x: 40, y: 40)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - rhs: CGPoint to add.
    public static func += (lhs: inout CGPoint, rhs: CGPoint)

    /// ReerKit: Subtract two CGPoints.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let point2 = CGPoint(x: 30, y: 30)
    ///     let point = point1 - point2
    ///     // point = CGPoint(x: -20, y: -20)
    ///
    /// - Parameters:
    ///   - lhs: CGPoint to subtract from.
    ///   - rhs: CGPoint to subtract.
    /// - Returns: result of subtract of the two given CGPoints.
    public static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint

    /// ReerKit: Subtract a CGPoints from self.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let point2 = CGPoint(x: 30, y: 30)
    ///     point1 -= point2
    ///     // point1 = CGPoint(x: -20, y: -20)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - rhs: CGPoint to subtract.
    public static func -= (lhs: inout CGPoint, rhs: CGPoint)

    /// ReerKit: Multiply a CGPoint with a scalar.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let scalar = point1 * 5
    ///     // scalar = CGPoint(x: 50, y: 50)
    ///
    /// - Parameters:
    ///   - point: CGPoint to multiply.
    ///   - scalar: scalar value.
    /// - Returns: result of multiplication of the given CGPoint with the scalar.
    public static func * (point: CGPoint, scalar: CGFloat) -> CGPoint

    /// ReerKit: Multiply self with a scalar.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     point *= 5
    ///     // point1 = CGPoint(x: 50, y: 50)
    ///
    /// - Parameters:
    ///   - point: `self`.
    ///   - scalar: scalar value.
    /// 
    public static func *= (point: inout CGPoint, scalar: CGFloat)

    /// ReerKit: Multiply a CGPoint with a scalar.
    ///
    ///     let point1 = CGPoint(x: 10, y: 10)
    ///     let scalar = 5 * point1
    ///     // scalar = CGPoint(x: 50, y: 50)
    ///
    /// - Parameters:
    ///   - scalar: scalar value.
    ///   - point: CGPoint to multiply.
    /// - Returns: result of multiplication of the given CGPoint with the scalar.
    public static func * (scalar: CGFloat, point: CGPoint) -> CGPoint
}

public extension CGPoint {

    /// ReerKit: Create a `CGPoint` instance with x, y, but without argument label.
    public static func re(_ x: CGFloat, _ y: CGFloat) -> CGPoint
}
```

### CGRect

```
import CoreGraphics

extension CGRect: ReerCompatibleValue {}
public extension Reer where Base == CGRect {

    /// ReerKit: Return center of rect.
    public var center: CGPoint { get }

    /// ReerKit: Create a new `CGRect` by resizing with specified anchor.
    /// - Parameters:
    ///   - size: new size to be applied.
    ///   - anchor: specified anchor, a point in normalized coordinates -
    ///     '(0, 0)' is the top left corner of rect，'(1, 1)' is the bottom right corner of rect,
    ///     defaults to '(0.5, 0.5)'. Example:
    ///
    ///          anchor = CGPoint(x: 0.0, y: 1.0):
    ///
    ///                       A2------B2
    ///          A----B       |        |
    ///          |    |  -->  |        |
    ///          C----D       C-------D2
    ///
    public func resizing(to size: CGSize, anchor: CGPoint = CGPoint(x: 0.5, y: 0.5)) -> CGRect
}

public extension CGRect {

    /// ReerKit: Create a `CGRect` instance with center and size.
    /// - Parameters:
    ///   - center: center of the new rect.
    ///   - size: size of the new rect.
    public static func re(center: CGPoint, size: CGSize) -> CGRect

    /// ReerKit: Create a `CGRect` instance with x, y, width, height, but without argument label.
    public static func re(_ x: CGFloat, _ y: CGFloat, _ width: CGFloat, _ height: CGFloat) -> CGRect
}
```

### CGSize

```
import CoreGraphics
import UIKit

extension CGSize: ReerCompatibleValue {}
public extension Reer where Base == CGSize {

    /// ReerKit: Returns the aspect ratio.
    public var aspectRatio: CGFloat { get }

    /// ReerKit: Returns width or height, whichever is the bigger value.
    public var maxDimension: CGFloat { get }

    /// ReerKit: Returns width or height, whichever is the smaller value.
    public var minDimension: CGFloat { get }

    /// ReerKit: Aspect fit CGSize.
    ///
    ///     let rect = CGSize(width: 120, height: 80)
    ///     let parentRect  = CGSize(width: 100, height: 50)
    ///     let newRect = rect.re.aspectFit(to: parentRect)
    ///     //newRect.width = 75 , newRect.height = 50
    ///
    /// - Parameter boundingSize: bounding size to fit self to.
    /// - Returns: self fitted into given bounding size
    public func aspectFit(to boundingSize: CGSize) -> CGSize

    /// ReerKit: Aspect fill CGSize.
    ///
    ///     let rect = CGSize(width: 20, height: 120)
    ///     let parentRect  = CGSize(width: 100, height: 60)
    ///     let newRect = rect.re.aspectFill(to: parentRect)
    ///     //newRect.width = 100 , newRect.height = 600
    ///
    /// - Parameter boundingSize: bounding size to fill self to.
    /// - Returns: self filled into given bounding size
    public func aspectFill(to boundingSize: CGSize) -> CGSize

    /// ReerKit: Returns a rectangle to fit the @param rect with specified content mode.
    ///
    /// - Parameters:
    ///   - rect: The constrant rect
    ///   - mode: The content mode
    /// - Returns: A rectangle for the given content mode.
    public func fit(inRect rect: CGRect, mode: UIView.ContentMode) -> CGRect
}

public extension CGSize {

    /// ReerKit: Add two CGSize.
    ///
    ///     let sizeA = CGSize(width: 5, height: 10)
    ///     let sizeB = CGSize(width: 3, height: 4)
    ///     let result = sizeA + sizeB
    ///     // result = CGSize(width: 8, height: 14)
    ///
    /// - Parameters:
    ///   - lhs: CGSize to add to.
    ///   - rhs: CGSize to add.
    /// - Returns: The result comes from the addition of the two given CGSize struct.
    public static func + (lhs: CGSize, rhs: CGSize) -> CGSize

    /// ReerKit: Add a tuple to CGSize.
    ///
    ///     let sizeA = CGSize(width: 5, height: 10)
    ///     let result = sizeA + (5, 4)
    ///     // result = CGSize(width: 10, height: 14)
    ///
    /// - Parameters:
    ///   - lhs: CGSize to add to.
    ///   - tuple: tuple value.
    /// - Returns: The result comes from the addition of the given CGSize and tuple.
    public static func + (lhs: CGSize, tuple: (width: CGFloat, height: CGFloat)) -> CGSize

    /// ReerKit: Add a CGSize to self.
    ///
    ///     var sizeA = CGSize(width: 5, height: 10)
    ///     let sizeB = CGSize(width: 3, height: 4)
    ///     sizeA += sizeB
    ///     // sizeA = CGPoint(width: 8, height: 14)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - rhs: CGSize to add.
    public static func += (lhs: inout CGSize, rhs: CGSize)

    /// ReerKit: Add a tuple to self.
    ///
    ///     var sizeA = CGSize(width: 5, height: 10)
    ///     sizeA += (3, 4)
    ///     // result = CGSize(width: 8, height: 14)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - tuple: tuple value.
    public static func += (lhs: inout CGSize, tuple: (width: CGFloat, height: CGFloat))

    /// ReerKit: Subtract two CGSize.
    ///
    ///     let sizeA = CGSize(width: 5, height: 10)
    ///     let sizeB = CGSize(width: 3, height: 4)
    ///     let result = sizeA - sizeB
    ///     // result = CGSize(width: 2, height: 6)
    ///
    /// - Parameters:
    ///   - lhs: CGSize to subtract from.
    ///   - rhs: CGSize to subtract.
    /// - Returns: The result comes from the subtract of the two given CGSize struct.
    public static func - (lhs: CGSize, rhs: CGSize) -> CGSize

    /// ReerKit: Subtract a tuple from CGSize.
    ///
    ///     let sizeA = CGSize(width: 5, height: 10)
    ///     let result = sizeA - (3, 2)
    ///     // result = CGSize(width: 2, height: 8)
    ///
    /// - Parameters:
    ///   - lhs: CGSize to subtract from.
    ///   - tuple: tuple value.
    /// - Returns: The result comes from the subtract of the given CGSize and tuple.
    public static func - (lhs: CGSize, tuple: (width: CGFloat, heoght: CGFloat)) -> CGSize

    /// ReerKit: Subtract a CGSize from self.
    ///
    ///     var sizeA = CGSize(width: 5, height: 10)
    ///     let sizeB = CGSize(width: 3, height: 4)
    ///     sizeA -= sizeB
    ///     // sizeA = CGPoint(width: 2, height: 6)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - rhs: CGSize to subtract.
    public static func -= (lhs: inout CGSize, rhs: CGSize)

    /// ReerKit: Subtract a tuple from self.
    ///
    ///     var sizeA = CGSize(width: 5, height: 10)
    ///     sizeA -= (2, 4)
    ///     // result = CGSize(width: 3, height: 6)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - tuple: tuple value.
    public static func -= (lhs: inout CGSize, tuple: (width: CGFloat, height: CGFloat))

    /// ReerKit: Multiply two CGSize.
    ///
    ///     let sizeA = CGSize(width: 5, height: 10)
    ///     let sizeB = CGSize(width: 3, height: 4)
    ///     let result = sizeA * sizeB
    ///     // result = CGSize(width: 15, height: 40)
    ///
    /// - Parameters:
    ///   - lhs: CGSize to multiply.
    ///   - rhs: CGSize to multiply with.
    /// - Returns: The result comes from the multiplication of the two given CGSize structs.
    public static func * (lhs: CGSize, rhs: CGSize) -> CGSize

    /// ReerKit: Multiply a CGSize with a scalar.
    ///
    ///     let sizeA = CGSize(width: 5, height: 10)
    ///     let result = sizeA * 5
    ///     // result = CGSize(width: 25, height: 50)
    ///
    /// - Parameters:
    ///   - lhs: CGSize to multiply.
    ///   - scalar: scalar value.
    /// - Returns: The result comes from the multiplication of the given CGSize and scalar.
    public static func * (lhs: CGSize, scalar: CGFloat) -> CGSize

    /// ReerKit: Multiply a CGSize with a scalar.
    ///
    ///     let sizeA = CGSize(width: 5, height: 10)
    ///     let result = 5 * sizeA
    ///     // result = CGSize(width: 25, height: 50)
    ///
    /// - Parameters:
    ///   - scalar: scalar value.
    ///   - rhs: CGSize to multiply.
    /// - Returns: The result comes from the multiplication of the given scalar and CGSize.
    public static func * (scalar: CGFloat, rhs: CGSize) -> CGSize

    /// ReerKit: Multiply self with a CGSize.
    ///
    ///     var sizeA = CGSize(width: 5, height: 10)
    ///     let sizeB = CGSize(width: 3, height: 4)
    ///     sizeA *= sizeB
    ///     // result = CGSize(width: 15, height: 40)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - rhs: CGSize to multiply.
    public static func *= (lhs: inout CGSize, rhs: CGSize)

    /// ReerKit: Multiply self with a scalar.
    ///
    ///     var sizeA = CGSize(width: 5, height: 10)
    ///     sizeA *= 3
    ///     // result = CGSize(width: 15, height: 30)
    ///
    /// - Parameters:
    ///   - lhs: `self`.
    ///   - scalar: scalar value.
    public static func *= (lhs: inout CGSize, scalar: CGFloat)
}

public extension CGSize {

    /// ReerKit: Create a `CGSize` instance with side length (same width and height).
    ///
    /// - Parameters:
    ///   - side: side length.
    public static func re(side: CGFloat) -> CGSize

    /// ReerKit: Create a `CGSize` instance with width, height, but without argument label.
    public static func re(_ width: CGFloat, _ height: CGFloat) -> CGSize
}
```

### CGVector

```
import CoreGraphics

extension CGVector: ReerCompatibleValue {}
public extension Reer where Base == CGVector {

    /// ReerKit: The angle of rotation (in radians) of the vector. The range of the angle is -π to π; an angle of 0 points to the right.
    ///
    public var angle: CGFloat { get }

    /// ReerKit: The magnitude (or length) of the vector.
    ///
    public var magnitude: CGFloat { get }
}

public extension CGVector {

    /// ReerKit: Creates a vector with the given magnitude and angle.
    ///
    ///     let vector = CGVector.re(angle: .pi, magnitude: 1)
    ///
    /// - Parameters:
    ///     - angle: The angle of rotation (in radians) counterclockwise from the positive x-axis.
    ///     - magnitude: The length of the vector.
    ///
    public static func re(angle: CGFloat, magnitude: CGFloat) -> CGVector
}

public extension CGVector {

    /// ReerKit: Multiplies a scalar and a vector (commutative).
    ///
    ///     let vector = CGVector(dx: 1, dy: 1)
    ///     let largerVector = vector * 2
    ///
    /// - Parameters:
    ///   - vector: The vector to be multiplied.
    ///   - scalar: The scale by which the vector will be multiplied.
    /// - Returns: The vector with its magnitude scaled.
    public static func * (vector: CGVector, scalar: CGFloat) -> CGVector

    /// ReerKit: Multiplies a scalar and a vector (commutative).
    ///
    ///     let vector = CGVector(dx: 1, dy: 1)
    ///     let largerVector = 2 * vector
    ///
    /// - Parameters:
    ///   - scalar: The scalar by which the vector will be multiplied.
    ///   - vector: The vector to be multiplied.
    /// - Returns: The vector with its magnitude scaled.
    public static func * (scalar: CGFloat, vector: CGVector) -> CGVector

    /// ReerKit: Compound assignment operator for vector-scalar multiplication.
    ///
    ///     var vector = CGVector(dx: 1, dy: 1)
    ///     vector *= 2
    ///
    /// - Parameters:
    ///   - vector: The vector to be multiplied.
    ///   - scalar: The scale by which the vector will be multiplied.
    public static func *= (vector: inout CGVector, scalar: CGFloat)

    /// ReerKit: Negates the vector. The direction is reversed, but magnitude remains the same.
    ///
    ///     let vector = CGVector(dx: 1, dy: 1)
    ///     let reversedVector = -vector
    ///
    /// - Parameter vector: The vector to be negated.
    /// - Returns: The negated vector.
    prefix public static func - (vector: CGVector) -> CGVector
}
```

## Dispatch+REExtensions

### DispatchQueue

```
import Dispatch

public extension Reer where Base: DispatchQueue {

    /// ReerKit: A Boolean value indicating whether the current dispatch queue is the main queue.
    public static var isOnMainQueue: Bool { get }

    /// ReerKit: Returns a Boolean value indicating whether the current dispatch queue is the specified queue.
    ///
    /// - Returns: `true` if the current queue is the specified queue, otherwise `false`.
    public var isExecuting: Bool { get }
}
public typealias DelayTimeInSecond = Double
public extension Reer where Base: DispatchQueue {

    /// ReerKit: Runs passed closure asynchronous after certain time interval.
    ///
    /// - Parameters:
    ///   - delay: The time interval(second) after which the closure will run.
    ///   - qos: Quality of service at which the work item should be executed.
    ///   - flags: Flags that control the execution environment of the work item.
    ///   - work: The closure to run after certain time interval.
    public func asyncAfter(delay: DelayTimeInSecond, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping () -> Void)
}
```

## WKWebView+REExtensions

### WKWebView

```
import WebKit

public extension Reer where Base: WKWebView {

    /// ReerKit: Navigate to `url`.
    /// - Parameter url: URL to navigate.
    /// - Returns: A new navigation for given `url`.
    @discardableResult
    public func loadURL(_ url: URL) -> WKNavigation?

    /// ReerKit: Navigate to url using `String`.
    /// - Parameter urlString: The string specifying the URL to navigate to.
    /// - Parameter timeout: Timeout duration.
    /// - Returns: A new navigation for given `urlString`.
    @discardableResult
    public func loadURLString(_ urlString: String, timeout: TimeInterval? = nil) -> WKNavigation?
}
```